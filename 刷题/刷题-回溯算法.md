# <span style="color: cornflowerblue;">å›æº¯ç®—æ³•</span>

è´´ä¸ªå›æº¯ç®—æ³•åŸºç¡€å†…å®¹çš„å¸–å­ï¼šhttps://blog.csdn.net/JarvisChu/article/details/16067319?spm=1001.2014.3001.5502

ç›´æ¥ä¸Šé¢˜ï¼š

## <span style="color: orange;">77\. ç»„åˆ</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/combinations/
>
> é¢˜ç›®æè¿°ï¼š
>
> ç»™å®šä¸¤ä¸ªæ•´æ•° `n` å’Œ `k`ï¼Œè¿”å›èŒƒå›´ `[1, n]` ä¸­æ‰€æœ‰å¯èƒ½çš„ `k` ä¸ªæ•°çš„ç»„åˆã€‚
>
> ä½ å¯ä»¥æŒ‰ **ä»»ä½•é¡ºåº** è¿”å›ç­”æ¡ˆã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šn = 4, k = 2
> è¾“å‡ºï¼š
> [
> [2,4],
> [3,4],
> [2,3],
> [1,2],
> [1,3],
> [1,4],
> ]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šn = 1, k = 1
> è¾“å‡ºï¼š[[1]]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= n <= 20`
> - `1 <= k <= n`

### <span style="color: burlywood;">è§£æ³•ï¼šé€’å½’</span>

- <span style="color: red;">cç‰ˆæœ¬</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** ans;
int* path;
int pathTop;
int ansTop;
void backtrack(int cur, int n, int k){
    // è‹¥æ»¡è¶³æ¡ä»¶ï¼Œæ”¶é›†ç»“æœ
    if(pathTop == k){
        int* temp = malloc(sizeof(int) * k);
        for(int i = 0; i < k; i++)
            temp[i] = path[i];
        ans[ansTop++] = temp;
        return;
    }
    // forç¡®å®šé¦–ä¸ªå…ƒç´ ï¼Œé€’å½’ç¡®å®šä¹‹åçš„å…ƒç´ 
    for(int i = cur; i <= k; i++){
        path[pathTop++] = i;
        backtrack(i + 1, n, k);
        // i > n åï¼Œå›æº¯
        pathTop--;
    }
}

int** combine(int n, int k, int* returnSize, int** returnColumnSizes){
    path = malloc(sizeof(int) * k);
    ans = malloc(sizeof(int*) * 10001);
    pathTop = ansTop = 0;
    backtrack(1, n, k);
    *returnSize = ansTop;
    *returnColumnSizes = malloc(sizeof(int) * ansTop);
    // å‚æ•°æ•°ç»„èµ‹å€¼
    for(int i = 0; i < ansTop; i++)
        (*returnColumnSizes)[i] = k;
    return ans;
}
```

- <span style="color: red;">å‰ªæ</span>

> å‰ªæå°±æ˜¯æŠŠå¤šä½™çš„æ­¥éª¤é€šè¿‡æ¡ä»¶åˆ¤æ–­è¿‡æ»¤æ‰

```c
// æŠŠä¸Šè¿°ä»£ç ç¬¬20è¡Œæ›¿æ¢ä¸º
for(int i = cur; k - pathTop <= n + 1 - i; i++)
/*
æ¡ä»¶å·¦è¾¹æ˜¯è¿˜éœ€æ”¶é›†çš„ä¸ªæ•°/èŒƒå›´ï¼Œå³è¾¹æ˜¯å¯æ”¶é›†çš„ä¸ªæ•°/èŒƒå›´
ä¾‹å¦‚ï¼šn = 4, k = 4ï¼Œåˆ™è¾“å‡º[1,2,3,4]
ç¬¬ä¸€æ¬¡ï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯1æ—¶/i = 1ï¼‰ï¼š
    è¿˜éœ€4ä¸ªå…ƒç´ ï¼Œk-pathTop = 4
    å¯æ”¶é›†çš„èŒƒå›´æ—¶[1,2,3,4], n+1-i = 4
ç¬¬äºŒæ¬¡ï¼ˆç¬¬ä¸€ä¸ªå…ƒç´ æ˜¯2æ—¶/ i = 2ï¼‰
    è¿˜éœ€4ä¸ªå…ƒç´ ï¼Œk-pathTop = 4
    å¯æ”¶é›†çš„èŒƒå›´æ—¶[2,3,4], n+1-i = 3
*/
```

- <span style="color: red;">pythonç‰ˆæœ¬</span>

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        # ç”³è¯·ä¸¤ä¸ªæ•°ç»„resï¼Œpath
        res = []
        path = []
        # å‡½æ•°ä¸­å®šä¹‰å‡½æ•°ï¼Œç§°ä¸ºå±€éƒ¨å‡½æ•°
        def backtrack(cur, n, k):
            # è‹¥æ»¡è¶³æ”¶é›†æ¡ä»¶
            if len(path) == k:
                # æŠŠpathèµ‹å€¼åˆ°resä¸­
                res.append(path[:])	# [:]æ˜¯åˆ‡ç‰‡è¯­æ³•
                return
            # ç›¸å½“äºfor(int i = cur; i < n + 1; i++) å®ç°é€‰æ‹©
            for i in range(cur, n + 1):
                # å°†iæ·»åŠ åˆ°pathå°¾éƒ¨
                path.append(i)
                backtrack(i + 1, n, k)
                # å°†pathå°¾éƒ¨å…ƒç´ å¼¹å‡ºï¼Œè¿›è¡Œå›æº¯
                path.pop()
        backtrack(1, n, k)
        return res
```

- <span style="color: red;">å‰ªæ</span>

```python
# ä¸Šè¿°ä»£ç ç¬¬14è¡Œæ¢ä¸º
for i in range(cur, n - (k - len(path)) + 2):
```

### <span style="color: burlywood;">ä»£ç å‰–æ</span>

æ•´ä½“è¯´æ˜ï¼šç¬¬20è¡Œä¸­çš„forå¾ªç¯ç”¨äºå®Œæˆç»“æœä¸­çš„ä¸€æ¬¡é€‰æ‹©ï¼Œç¬¬12è¡Œçš„ifè¯­å¥å®ç°å¯¹pathä¸­çš„å†…å®¹è¿›è¡Œæ”¶é›†

é€‰æ‹©çš„è¯¦ç»†è¯´æ˜ï¼š

```c
// forå¾ªç¯å®ç°å¯¹é¦–ä¸ªå…ƒç´ çš„é€‰æ‹©ï¼Œé€’å½’å®ç°å¯¹å…¶åå…ƒç´ çš„é€‰æ‹©
for(int i = cur; i <= n; i++){
    path[pathTop++] = i;
    backtrack(i + 1, n, k);
    // å½“i > nåï¼Œå›æº¯
    pathTop--;
}
```

```c
/* n = 4, k = 2 ç»“æœæ˜¯
[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
å¯¹äºæœ¬ä»£ç ï¼š
    curåˆå€¼æ˜¯1, 1ä½œä¸ºé¦–ä¸ªå…ƒç´ å­˜å…¥pathï¼ŒpathTop = 1
    è¿è¡Œåˆ°ç¬¬å››è¡Œï¼Œè¿›å…¥ç¬¬ä¸€å±‚é€’å½’ï¼Œcurä½œä¸ºå‚æ•°å˜ä¸º2ï¼Œä½œä¸ºç¬¬äºŒä¸ªå…ƒç´ å­˜å…¥, pathTop = 2
    è¿è¡Œåˆ°ç¬¬å››è¡Œï¼Œè¿›å…¥ç¬¬äºŒå±‚é€’å½’ï¼Œæ»¡è¶³æ”¶é›†æ¡ä»¶ï¼Œæ”¶é›†, return åˆ°ç¬¬ä¸€å±‚é€’å½’
    ï¼ˆcur = 2ï¼Œi = 2ï¼‰è¿è¡Œåˆ°ç¬¬å…­è¡Œï¼ŒpathTop = 1ï¼Œç¬¬ä¸€å±‚é€’å½’çš„ç¬¬ä¸€å±‚forå¾ªç¯ç»“æŸï¼Œi = 3
    iå­˜å…¥pathï¼Œè¿›å…¥ç¬¬äºŒå±‚é€’å½’ï¼Œæ»¡è¶³æ”¶é›†æ¡ä»¶ï¼Œæ”¶é›†ï¼Œreturn åˆ°ç¬¬ä¸€å±‚é€’å½’
    ï¼ˆcur = 2ï¼Œi = 3ï¼‰è¿è¡Œåˆ°ç¬¬å…­è¡Œï¼Œå›æº¯pathï¼Œç¬¬ä¸€å±‚é€’å½’çš„ç¬¬äºŒå±‚forå¾ªç¯ç»“æŸï¼Œi = 4
    â€¦â€¦ï¼ˆé‡å¤ä¸Šè¿°8,9è¡Œçš„æ­¥éª¤ç›´åˆ°ä¸æ»¡è¶³forå¾ªç¯çš„æ¡ä»¶ï¼‰
    è·³å‡ºç¬¬ä¸€å±‚é€’å½’
    (cur = 1, i = 1) è¿è¡Œåˆ°ç¬¬å…­è¡Œï¼Œå›æº¯pathï¼Œæœ€å¤–å±‚ï¼ˆæœªè¿›é€’å½’çš„ä»£ç ï¼‰çš„ç¬¬äºŒå±‚forå¾ªç¯ç»“æŸï¼Œi = 2
    iå­˜å…¥pathï¼Œè¿›å…¥ç¬¬ä¸€å±‚é€’å½’

ä»ç¬¬4è¡Œåˆ°ç¬¬12è¡Œçš„æè¿°ï¼Œæ˜¯é¦–ä¸ªå…ƒç´ çš„å®Œæ•´è¿è¡Œè¿‡ç¨‹
æœ¬ä¾‹çš„é¦–ä¸ªå…ƒç´ åˆ†åˆ«æ˜¯ï¼š1,2,3
ä¹‹åçš„ä»£ç ï¼Œå°†é‡å¤ç¬¬4è¡Œåˆ°ç¬¬12è¡Œçš„æè¿°
*/
```

æ”¶é›†çš„ç®€ç•¥è¯´æ˜

```c
// è‹¥æ»¡è¶³é•¿åº¦è¦æ±‚ï¼Œåˆ™æ”¶é›†
if(pathTop == k){
    // ç”±äºpathæ˜¯å…¨å±€å˜é‡ï¼Œåˆ™ä½¿ç”¨ä¸´æ—¶æ•°ç»„tempè¿›è¡Œæ”¶é›†
    int* temp = malloc(sizeof(int) * k);
    for(int i = 0; i < k; i++)
        temp[i] = path[i];
    // ç”¨æŒ‡é’ˆèµ‹å€¼
    ans[ansTop++] = temp;
    return;
}
```

å¦‚æœå¯¹æœ¬è§£æ³•è¿˜æœ‰ç–‘é—®ï¼Œå¯ä»¥ç»™æˆ‘å‘æ¶ˆæ¯ï¼Œç”¨ä¸€ä¸ªmidä½œä¸ºå›æº¯ç®—æ³•çš„ç¬¬ä¸€é¢˜è·¨åº¦æœ‰ç‚¹å¤§ï¼Œä½†è¿˜æ˜¯å¸Œæœ›å„ä½å¥½å¥½æ¨¡æ‹Ÿä¸€ä¸‹ï¼

### <span style="color: burlywood;">é—²èŠ</span>

å‰ä¸¤å¤©å»ç©äº†ï¼Œå¤§æ¦‚ä¸€å‘¨æ—¶é—´å§ï¼Œè¿™æœŸé—´æ²¡æ€ä¹ˆåˆ·é¢˜ï¼Œæ›´æ–°çš„å†…å®¹éƒ½æ˜¯ä¹‹å‰å­˜ä¸‹çš„ï¼ˆæ˜¨å¤©åˆšå›æ¥

ä¹‹åçš„å†…å®¹ä¼šè¿›è¡Œéƒ¨åˆ†è°ƒæ•´ï¼Œæ¯”å¦‚ï¼š

- å¢åŠ pythonçš„ä»£ç 
- è‹¥è¿‡ç¨‹å¤æ‚ï¼Œåˆ™ä¼šå•ç‹¬ç”¨ä¸€partè¿›è¡Œæ¨¡æ‹Ÿè§£é‡Š
- é—²èŠå†…å®¹æ˜¯å½©è›‹ğŸ˜‰

## <span style="color: orange;">216\. ç»„åˆæ€»å’Œ III</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/combination-sum-iii/
>
> é¢˜ç›®æè¿°ï¼š
>
> æ‰¾å‡ºæ‰€æœ‰ç›¸åŠ ä¹‹å’Œä¸º `n` çš„ `k` ä¸ªæ•°çš„ç»„åˆï¼Œä¸”æ»¡è¶³ä¸‹åˆ—æ¡ä»¶ï¼š
>
> - åªä½¿ç”¨æ•°å­—1åˆ°9
> - æ¯ä¸ªæ•°å­— **æœ€å¤šä½¿ç”¨ä¸€æ¬¡**
>
> è¿”å› *æ‰€æœ‰å¯èƒ½çš„æœ‰æ•ˆç»„åˆçš„åˆ—è¡¨* ã€‚è¯¥åˆ—è¡¨ä¸èƒ½åŒ…å«ç›¸åŒçš„ç»„åˆä¸¤æ¬¡ï¼Œç»„åˆå¯ä»¥ä»¥ä»»ä½•é¡ºåºè¿”å›ã€‚
>
> **ç¤ºä¾‹ 1:**
>
> ```
> è¾“å…¥: k = 3, n = 7
> è¾“å‡º: [[1,2,4]]
> è§£é‡Š:
> 1 + 2 + 4 = 7
> æ²¡æœ‰å…¶ä»–ç¬¦åˆçš„ç»„åˆäº†ã€‚
> ```
>
> **ç¤ºä¾‹ 2:**
>
> ```
> è¾“å…¥: k = 3, n = 9
> è¾“å‡º: [[1,2,6], [1,3,5], [2,3,4]]
> è§£é‡Š:
> 1 + 2 + 6 = 9
> 1 + 3 + 5 = 9
> 2 + 3 + 4 = 9
> æ²¡æœ‰å…¶ä»–ç¬¦åˆçš„ç»„åˆäº†ã€‚
> ```
>
> **ç¤ºä¾‹ 3:**
>
> ```
> è¾“å…¥: k = 4, n = 1
> è¾“å‡º: []
> è§£é‡Š: ä¸å­˜åœ¨æœ‰æ•ˆçš„ç»„åˆã€‚
> åœ¨[1,9]èŒƒå›´å†…ä½¿ç”¨4ä¸ªä¸åŒçš„æ•°å­—ï¼Œæˆ‘ä»¬å¯ä»¥å¾—åˆ°çš„æœ€å°å’Œæ˜¯1+2+3+4 = 10ï¼Œå› ä¸º10 > 1ï¼Œæ²¡æœ‰æœ‰æ•ˆçš„ç»„åˆã€‚
> ```
>
> **æç¤º:**
>
> - `2 <= k <= 9`
> - `1 <= n <= 60`

- <span style="color: red;">è¶…æ—¶è§£æ³•Â cè¯­è¨€ç‰ˆ</span>

    > å¦‚æœæŒ‰ç…§æ˜¨å¤©çš„æ€è·¯

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int len;
int ** res;
int* path;
int pathIndex;
int sum;
void combine(int k, int n, int cur){
    // æ”¶é›†ç»“æœ
    if(pathIndex == k - 1 && n - sum >= cur && n - sum <= 9){
        path[k - 1] = n - sum;
        int* tmp = malloc(sizeof(int) * k);
        for(int i = 0; i < k; i++)
            tmp[i] = path[i];
        res[len++] = tmp;
        return;
    }
    // é€‰æ‹©ç»“æœ
    for(int i = cur; i <= n; i++){
        sum += i;
        path[pathIndex++] = i;
        combine(k, n, i + 1);
        sum -= i;
        pathIndex--;
    }
}

int** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 10001);
    path = malloc(sizeof(int) * 10001);
    len = pathIndex = sum = 0;
    combine(k, n, 1);
    *returnSize = len;
    *returnColumnSizes = malloc(sizeof(int) * len);
    for(int i = 0; i < len; i++)
        (*returnColumnSizes)[i] = k;
    return res;
}
```

è¶…æ—¶çš„æœ¬è´¨åœ¨äºç¬¬22è¡Œçš„åˆ¤æ–­ï¼Œä¼šå¯¼è‡´ç¨‹åºçš„åå¤å›æº¯ã€‚

```c
// è¿›è¡Œå¦‚ä¸‹æ›´æ”¹å³å¯
for(int i = cur; i <= n - sum; i++)
```

```c
// è¿˜èƒ½è¿›ä¸€æ­¥ä¼˜åŒ–
for(int i = cur; (k - pathIndex) * i <= n - sum && n - sum <= 9 * (k - pathIndex); i++)
// å¯ä»¥æŠŠ k - pathIndex å®šä¹‰ä¸ºä¸€ä¸ªå˜é‡
```

ç”±äºè¦æ‰¾çš„æ•°åªèƒ½å‡ºç°ä¸€æ¬¡ï¼Œå› æ­¤å‰©ä½™å€¼$n - sum$è¦æ¯”å½“å‰å€¼çš„å‰©ä½™ä¸ªæ•°$k - pathIndex$å€å¤§/ç›¸ç­‰ï¼Œå‰©ä½™å€¼è¦æ¯”æœ€å¤§å€¼9çš„å‰©ä½™ä¸ªæ•° å€ å¤§/ç›¸ç­‰ã€‚

- <span style="color: red;">pythonç‰ˆæœ¬</span>

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        ans = []
        path = []
        def dfs(i: int, t: int) -> None:
            d = k - len(path)  # è¿˜è¦é€‰ d ä¸ªæ•°
            if t < 0 or t > (i * 2 - d + 1) * d // 2:  # å‰ªæ
                return
            if d == 0:
                ans.append(path.copy())
                return
            for j in range(i, d - 1, -1):
                path.append(j)
                dfs(j - 1, t - j)
                path.pop()
        dfs(9, n)
        return ans
```

pythonçš„ä»£ç æˆ‘æ˜¯cvçš„ï¼Œæˆ‘ä¸çŸ¥é“ä¸ºå•¥æ”¹å†™ä¹‹åè¿‡ä¸äº†ï¼Œæˆ‘å¾…ä¼šå†è¯•è¯•

## <span style="color: orange;">17\. ç”µè¯å·ç çš„å­—æ¯ç»„åˆ</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/letter-combinations-of-a-phone-number/
>
> é¢˜ç›®æè¿°ï¼š
>
> ç»™å®šä¸€ä¸ªä»…åŒ…å«æ•°å­— `2-9` çš„å­—ç¬¦ä¸²ï¼Œè¿”å›æ‰€æœ‰å®ƒèƒ½è¡¨ç¤ºçš„å­—æ¯ç»„åˆã€‚ç­”æ¡ˆå¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›ã€‚
>
> ç»™å‡ºæ•°å­—åˆ°å­—æ¯çš„æ˜ å°„å¦‚ä¸‹ï¼ˆä¸ç”µè¯æŒ‰é”®ç›¸åŒï¼‰ã€‚æ³¨æ„ 1 ä¸å¯¹åº”ä»»ä½•å­—æ¯ã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šdigits = "23"
> è¾“å‡ºï¼š["ad","ae","af","bd","be","bf","cd","ce","cf"]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šdigits = ""
> è¾“å‡ºï¼š[]
> ```
>
> **ç¤ºä¾‹ 3ï¼š**
>
> ```
> è¾“å…¥ï¼šdigits = "2"
> è¾“å‡ºï¼š["a","b","c"]
> ```
>
> **æç¤ºï¼š**
>
> - `0 <= digits.length <= 4`
> - `digits[i]` æ˜¯èŒƒå›´ `['2', '9']` çš„ä¸€ä¸ªæ•°å­—ã€‚

### <span style="color: burlywood;">è§£æ³•-å›æº¯</span>

- <span style="color: red;">cè¯­è¨€ç‰ˆ</span>

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char map[8][5] = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
char* path;
char** res;
int pathIndex;
int resIndex;
int n;  // resåˆ—æ•°

void backtrace(int index, char* digits){
    // æ³¨æ„æ”¶é›†æ¡ä»¶
    if(index == n){
        char* tmp = malloc(sizeof(char) * (n + 1));
        for(int i = 0; i < n; i++){
            tmp[i] = path[i];
        }
        tmp[n] = '\0'; 
        res[resIndex++] = tmp;
        return;
    }
    // é€‰æ‹©
    char* words = map[digits[index] - '2'];
    for(int i = 0; i < strlen(words); i++){
        path[pathIndex++] = words[i];
        backtrace(index + 1, digits);
        pathIndex--;
    }
}

char ** letterCombinations(char * digits, int* returnSize){
    n = strlen(digits);
    if(n == 0){
        *returnSize = 0;
        return NULL;
    }
    path = malloc(sizeof(char) * n);
    res = malloc(sizeof(char*) * 300);
    resIndex = pathIndex = 0;
    backtrace(0, digits);
    *returnSize = resIndex;
    return res;
}
```

- <span style="color: red;">pythonç‰ˆ</span>

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        # ç‰¹åˆ¤
        if not digits:
            return []
        arr = ["abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
        res = []
        def backtrace(index, tmp) -> None:
            if index == len(digits):
                res.append(tmp)
                return
            # ä¸‹é¢ä¸¤è¡ŒæŠŠdigitsä¸­çš„æ•°å­—æ˜ å°„ä¸ºarrä¸­å¯¹åº”çš„å­—ç¬¦ä¸²
            c = digits[index]
            # ordè·å–asciiå€¼ï¼Œ48æ˜¯0çš„asciiå€¼
            letters = arr[ord(c) - 50]
            for i in letters:
                # tmp + iæ˜¯å­—ç¬¦ä¸²çš„æ‹¼æ¥
                backtrace(index + 1, tmp + i)
        backtrace(0, "")
        return res
```

### <span style="color: burlywood;">å¥‡æŠ€æ·«å·§</span>

> æ·«ï¼šè¿‡åˆ†çš„ï¼›è¿™ä¸ªæˆè¯­çš„æ„æ€æ˜¯åˆ›æ–°çš„è§‚å¿µ
>
> å¥‡æŠ€æ·«å·§ï¼Œä»¥æ‚¦å¦‡å­ºï¼šè¿™ç§æ–°å¥‡çš„ç©æ„å„¿ï¼Œåªç”¨ç”¨æ¥å–æ‚¦å¥³äººå’Œå°å­©ï¼ˆå¤ä»£è§‚ç‚¹

```c
n = strlen(digits);
if(n == 0){
    *returnSize = 0;
    return NULL;
}
// ä¸Šè¿°å¯æ”¹ä¸º
if((n = strlen(digits)) == 0){
        *returnSize = 0;
        return NULL;
}
/*
èµ‹å€¼è¯­å¥çš„è¿”å›å€¼æ˜¯èµ‹å€¼çš„ç»“æœ
å°±æ˜¯è¯´ç¬¬7è¡Œçš„èµ‹å€¼è¯­å¥çš„è¿”å›å€¼æ˜¯strlen(digits)
ä¸å»ºè®®è¿™æ ·å†™ï¼Œå¯è¯»æ€§å¤ªå·®
*/
```

```c
tmp[n] = '\0';  // ä¹Ÿå¯å†™æˆ tmp[n] = 0;
/*
intå‹çš„0è½¬ä¸ºasciiä¸ºcharå‹çš„NULLï¼Œä¸'\0'ç­‰ä»·
å³ tmp[n] = 0 <=> tmp[n] = NULL <=> tmp[n] = '\0'
*/
```

## <span style="color: orange;">39\. ç»„åˆæ€»å’Œ</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/combination-sum/
>
> é¢˜ç›®æè¿°ï¼š
>
> ç»™ä½ ä¸€ä¸ª **æ— é‡å¤å…ƒç´ ** çš„æ•´æ•°æ•°ç»„ `candidates` å’Œä¸€ä¸ªç›®æ ‡æ•´æ•° `target` ï¼Œæ‰¾å‡º `candidates` ä¸­å¯ä»¥ä½¿æ•°å­—å’Œä¸ºç›®æ ‡æ•° `target` çš„ æ‰€æœ‰ **ä¸åŒç»„åˆ** ï¼Œå¹¶ä»¥åˆ—è¡¨å½¢å¼è¿”å›ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›è¿™äº›ç»„åˆã€‚
>
> `candidates` ä¸­çš„ **åŒä¸€ä¸ª** æ•°å­—å¯ä»¥ **æ— é™åˆ¶é‡å¤è¢«é€‰å–** ã€‚å¦‚æœè‡³å°‘ä¸€ä¸ªæ•°å­—çš„è¢«é€‰æ•°é‡ä¸åŒï¼Œåˆ™ä¸¤ç§ç»„åˆæ˜¯ä¸åŒçš„ã€‚
>
> å¯¹äºç»™å®šçš„è¾“å…¥ï¼Œä¿è¯å’Œä¸º `target` çš„ä¸åŒç»„åˆæ•°å°‘äº `150` ä¸ªã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šcandidates = [2,3,6,7], target = 7
> è¾“å‡ºï¼š[[2,2,3],[7]]
> è§£é‡Šï¼š
> 2 å’Œ 3 å¯ä»¥å½¢æˆä¸€ç»„å€™é€‰ï¼Œ2 + 2 + 3 = 7 ã€‚æ³¨æ„ 2 å¯ä»¥ä½¿ç”¨å¤šæ¬¡ã€‚
> 7 ä¹Ÿæ˜¯ä¸€ä¸ªå€™é€‰ï¼Œ 7 = 7 ã€‚
> ä»…æœ‰è¿™ä¸¤ç§ç»„åˆã€‚
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥: candidates = [2,3,5], target = 8
> è¾“å‡º: [[2,2,2,2],[2,3,3],[3,5]]
> ```
>
> **ç¤ºä¾‹ 3ï¼š**
>
> ```
> è¾“å…¥: candidates = [2], target = 1
> è¾“å‡º: []
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= candidates.length <= 30`
> - `2 <= candidates[i] <= 40`
> - `candidates` çš„æ‰€æœ‰å…ƒç´  **äº’ä¸ç›¸åŒ**
> - `1 <= target <= 40`

### <span style="color: burlywood;">è§£æ³•ï¼šå›æº¯</span>

- <span style="color: red;">cè¯­è¨€ç‰ˆ</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** res;
int resIndex;
int paths[10001];
int pathIndex;
int idx;
void backtrace(int* candidates, int len, int idx, int target, int** columnSizes, int* returnSize){
    if(idx == len)
        return;
    // æ”¶é›†
    if(target == 0){
        int* tmp = malloc(sizeof(int) * pathIndex);
        for(int i = 0; i < pathIndex; i++)
            tmp[i] = paths[i];
        (*columnSizes)[*returnSize] = pathIndex;
        res[(*returnSize)++] = tmp;
        return;
    }
    backtrace(candidates, len, idx + 1, target, columnSizes, returnSize);
    // é€‰æ‹©
    if(target - candidates[idx] >= 0){
        paths[pathIndex++] = candidates[idx];
        backtrace(candidates, len, idx, target - candidates[idx], columnSizes, returnSize);
        pathIndex--;
    }
}

int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 10001);
    *returnColumnSizes = malloc(sizeof(int) * 10001);
    resIndex = pathIndex = idx = 0;
    *returnSize = 0;
    backtrace(candidates, candidatesSize, idx, target, returnColumnSizes, returnSize);
    return res;
}
```

- <span style="color: red;">pythonç‰ˆ</span>

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        def backtrace(idx, target):
            if idx == len(candidates):
                return
            # æ”¶é›†
            if target == 0:
                res.append(path[:])
                return;
            backtrace(idx + 1, target)
            # é€‰æ‹©
            if target >= candidates[idx]:
                path.append(candidates[idx])
                # index = -1,è¡¨ç¤ºè®¿é—®åˆ—è¡¨çš„æœ€åä¸€ä¸ªå…ƒç´ 
                backtrace(idx, target - path[-1])
                path.pop()
        backtrace(0, target)
        return res    
```

### <span style="color: burlywood;">ä»£ç å‰–æ</span>

> ä»¥cè¯­è¨€ä»£ç çš„ä¸ºå‡†

æ­¤å¤„è´´ä¸Šæˆ‘çš„æ‰‹ç¨¿ï¼Œ~~å­—ä¸‘åˆ«å«Œå¼ƒ~~

![å›æº¯ç®—æ³•-ç»„åˆ.png](C:/Users/MrFeng/.config/joplin-desktop/resources/0fca277ceb40465181a3e6bda8729ec9.png)

å›æº¯ç®—æ³•-ç»„åˆ.png

å›æº¯ç®—æ³•-ç»„åˆ.png

```c
/* ç¤ºä¾‹ï¼šcandidates = [2, 3, 5], target = 8
 result = [[3, 5], [2, 3, 3], [2, 2, 2, 2]]
```

- çº¢è‰²ï¼šä»£ç æµç¨‹ï¼ˆä»ä¸Šåˆ°ä¸‹ï¼Œä»å·¦åˆ°å³ï¼‰
- ç´«è‰²ï¼šç¤ºä¾‹
- ç»¿è‰²ï¼šå½“å‰é€’å½’ä¸­è®¿é—®çš„candidatesçš„ç´¢å¼•ï¼Œä¸€å®šç¨‹åº¦åæ˜ é€’å½’å±‚æ•°
- è“è‰²ï¼šæ»¡è¶³æ”¶é›†æ¡ä»¶

ç”»åœˆåœˆä»£è¡¨æ˜¯ä¸€å±‚ä»£ç ï¼Œè¿è¡Œåˆ°æŸå¤„è¿›å…¥é€’å½’ï¼›å‘ä¸Šç®­å¤´æ˜¯è·³å‡ºé€’å½’ï¼›

ç®­å¤´çš„å°¾ç«¯ï¼ˆèµ·å§‹çš„ä½ç½®ï¼‰æ˜¯åœˆåœˆï¼Œè¯´æ˜ä»£ç æ˜¯åœ¨13è¡Œï¼Œå³å½“å‰candidatesç´¢å¼•ç­‰äºcandidatesé•¿åº¦æ˜¯è¿”å›çš„ï¼›ç®­å¤´çš„å°¾ç«¯æ˜¯æ•°å­—ï¼Œè¯´æ˜ä»£ç è¿è¡Œåˆ°25è¡Œçš„é€‰æ‹©å¤„ï¼Œä¸æ»¡è¶³ifæ¡ä»¶ï¼ˆå½“å‰target å°äºidxæŒ‡å‘çš„æ•°å­—ï¼‰æ—¶è·³å‡ºé€’å½’çš„ï¼›å¦‚æœæ•°å­—ä¸‹é¢æœ‰è“è‰²çš„âˆšï¼Œè¯´æ˜ä»£ç è¿›å…¥äº†ç¬¬15è¡Œçš„æ”¶é›†ï¼Œé€šè¿‡returnè¿”å›çš„ã€‚

æœ¬ä»£ç æœ€å¤§çš„é—®é¢˜ï¼šcandidatesä¸­å­˜åœ¨å¤šä¸ªå°æ•°å­—æ„æˆtargetï¼Œéœ€è¦åå¤å›æº¯ã€‚

## <span style="color: orange;">40.ç»„åˆæ€»å’ŒII</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/combination-sum-ii/
>
> é¢˜ç›®æè¿°ï¼š
>
> ç»™å®šä¸€ä¸ªå€™é€‰äººç¼–å·çš„é›†åˆ `candidates` å’Œä¸€ä¸ªç›®æ ‡æ•° `target` ï¼Œæ‰¾å‡º `candidates` ä¸­æ‰€æœ‰å¯ä»¥ä½¿æ•°å­—å’Œä¸º `target` çš„ç»„åˆã€‚
>
> `candidates` ä¸­çš„æ¯ä¸ªæ•°å­—åœ¨æ¯ä¸ªç»„åˆä¸­åªèƒ½ä½¿ç”¨ **ä¸€æ¬¡** ã€‚
>
> **æ³¨æ„ï¼š**è§£é›†ä¸èƒ½åŒ…å«é‡å¤çš„ç»„åˆã€‚
>
> **ç¤ºä¾‹ 1:**
>
> ```
> è¾“å…¥: candidates = [10,1,2,7,6,1,5], target = 8,
> è¾“å‡º:
> [
> [1,1,6],
> [1,2,5],
> [1,7],
> [2,6]
> ]
> ```
>
> **ç¤ºä¾‹ 2:**
>
> ```
> è¾“å…¥: candidates = [2,5,2,1,2], target = 5,
> è¾“å‡º:
> [
> [1,2,2],
> [5]
> ]
> ```
>
> **æç¤º:**
>
> - `1 <= candidates.length <= 100`
> - `1 <= candidates[i] <= 50`
> - `1 <= target <= 30`

### <span style="color: burlywood;">è§£æ³•-å›æº¯</span>

- <span style="color: red;">cè¯­è¨€ç‰ˆ</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
int* paths;
int pathIndex;
void backtrace(int* candidates, int len, int target, int* returnSize, int** colSizes, int idx){
    // æ”¶é›†
    if(target == 0){
        int* tmp = malloc(sizeof(int) * pathIndex);
        for(int i = 0; i < pathIndex; i++)
            tmp[i] = paths[i];
        res[*returnSize] = tmp;
        (*colSizes)[(*returnSize)++] = pathIndex;
        return;
    }
    // é€‰æ‹©
    for(int i = idx; i < len; i++){
        if(target >= candidates[i]){    
            paths[pathIndex++] = candidates[i];
            backtrace(candidates, len, target - candidates[i], returnSize, colSizes, i + 1);
            pathIndex--;
        }
    }
}

int cmp(const void* a1, const void* a2) {
    return *((int*)a1) - *((int*)a2);
}

int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 2001);
    paths = malloc(sizeof(int*) * 2001);
    *returnColumnSizes = malloc(sizeof(int) * 2001);
    *returnSize = 0;
    pathIndex = 0;
    qsort(candidates, candidatesSize, sizeof(int), cmp);
    backtrace(candidates, candidatesSize, target, returnSize, returnColumnSizes, 0);
    return res;
}
```

ä¸Šè¿°ä»£ç çš„é—®é¢˜åœ¨äºæ²¡æœ‰å»é‡ï¼Œå»é‡çš„æ–¹å¼ï¼š

```c
// é€‰æ‹©
for(int i = idx; i < len; i++){
    if(i > idx && candidates[i] == candidates[i - 1])	// æ­¤å¤„å»é‡ï¼ˆç”±äºæ•°ç»„æœ‰åºï¼‰
        continue;
    if(target >= candidates[i]){    
        paths[pathIndex++] = candidates[i];
        backtrace(candidates, len, target - candidates[i], returnSize, colSizes, i + 1);
        pathIndex--;
    }
}
```

ç”±äºæ•°ç»„è¦æ’åºæ•°ç»„ï¼Œå› æ­¤ä¸‹é¢è¿™ç§å†™æ³•æ›´ä½³

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
int* paths;
int pathIndex;
void backtrace(int* candidates, int len, int target, int* returnSize, int** colSizes, int idx){
    if(target < 0)
        return;
    // æ”¶é›†
    if(target == 0){
        int* tmp = malloc(sizeof(int) * pathIndex);
        for(int i = 0; i < pathIndex; i++)
            tmp[i] = paths[i];
        res[*returnSize] = tmp;
        (*colSizes)[(*returnSize)++] = pathIndex;
        return;
    }
    // é€‰æ‹©
    for(int i = idx; i < len; i++){
        if(i > idx && candidates[i] == candidates[i - 1])
            continue;
        if(candidates[i] > target)	// æ­¤å¤„å‰ªæ
            break;
        paths[pathIndex++] = candidates[i];
        backtrace(candidates, len, target - candidates[i], returnSize, colSizes, i + 1);
        pathIndex--;
    }
}

int cmp(const void* a1, const void* a2) {
    return *((int*)a1) - *((int*)a2);
}

int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 2001);
    paths = malloc(sizeof(int*) * 2001);
    *returnColumnSizes = malloc(sizeof(int) * 2001);
    *returnSize = 0;
    pathIndex = 0;
    qsort(candidates, candidatesSize, sizeof(int), cmp);
    backtrace(candidates, candidatesSize, target, returnSize, returnColumnSizes, 0);
    return res;
}
```

*æ’æ’­ä¸€ç‚¹debugï¼š*

```c
// bug1
store to null pointer of type 'int'
/*åŸå› ï¼šå¦‚æœç”³æ˜pathsæ•°ç»„æ—¶ï¼Œæ²¡æœ‰æŒ‡æ˜é•¿åº¦ï¼Œåˆ™åœ¨å›æº¯è¿‡ç¨‹ä¸­ï¼Œpathsä¼šæŒ‡å‘ç©º
*/
// æŒ‡æ˜é•¿åº¦çš„ä¸¤ç§æ–¹æ³•:
int paths[1001];	
int* paths = malloc(sizeof(int) * 1001);
```

```c
// bug2
AddressSanitizer:DEADLYSIGNAL
=================================================================
==20==ERROR: AddressSanitizer: SEGV on unknown address 0x00067fff8005 (pc 0x55d49764e1bc bp 0x7ffda15477c0 sp 0x7ffda1547770 T0)
==20==The signal is caused by a READ memory access.
    #6 0x7f8106c08082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)
AddressSanitizer can not provide additional info.
==20==ABORTING

/*è¿™ä¸ªåŸå› æœ‰å¾ˆå¤šï¼Œæˆ‘æœ¬æ¬¡é‡åˆ°çš„æ˜¯ï¼š
å‚æ•°ä¸­çš„æ•°ç»„æŒ‡é’ˆæ²¡æœ‰malloc
*/
```

- <span style="color: red;">pythonç‰ˆ</span>

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        def backtrace(idx, target):
            if target < 0:
                return
            # æ”¶é›†
            if target == 0:
                res.append(path[:])
                return
            # é€‰æ‹©
            for i in range(idx, len(candidates)):
                if i > idx and candidates[i] == candidates[i - 1]:
                    continue
                if candidates[i] > target:	# å‰ªæ
                    break
                path.append(candidates[i])
                backtrace(i + 1, target - path[-1])
                path.pop()
        candidates.sort()
        backtrace(0, target)
        return res
```

<span style="color: red;">**é’ˆå¯¹ç»„åˆé—®é¢˜ï¼Œå¯ä»¥æ€»ç»“ä¸ºï¼šé€‰æ‹©+æ”¶é›†**</span>

## <span style="color: orange;">131.åˆ†å‰²å›æ–‡ä¸²</span>

å›æº¯ç®—æ³•å¯ä»¥è§£å†³çš„é—®é¢˜æœ‰ï¼š

- ç»„åˆ
- åˆ‡å‰²
- å­é›†
- æ’åˆ—
- æ£‹ç›˜

> leetcodeé“¾æ¥ï¼šhttps://leetcode.cn/problems/palindrome-partitioning/
>
> é¢˜ç›®æè¿°ï¼š
>
> ç»™ä½ ä¸€ä¸ªå­—ç¬¦ä¸² `s`ï¼Œè¯·ä½ å°† `s` åˆ†å‰²æˆä¸€äº›å­ä¸²ï¼Œä½¿æ¯ä¸ªå­ä¸²éƒ½æ˜¯ **å›æ–‡ä¸²** ã€‚è¿”å› `s` æ‰€æœ‰å¯èƒ½çš„åˆ†å‰²æ–¹æ¡ˆã€‚
>
> **å›æ–‡ä¸²** æ˜¯æ­£ç€è¯»å’Œåç€è¯»éƒ½ä¸€æ ·çš„å­—ç¬¦ä¸²ã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šs = "aab"
> è¾“å‡ºï¼š[["a","a","b"],["aa","b"]]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šs = "a"
> è¾“å‡ºï¼š[["a"]]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= s.length <= 16`
> - `s` ä»…ç”±å°å†™è‹±æ–‡å­—æ¯ç»„æˆ

### <span style="color: burlywood;">è§£æ³•-å›æº¯</span>

- <span style="color: red;">cè¯­è¨€ç‰ˆ</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
char *** res;
char** path;
int pathIndex;
int len;
bool isPalindrome(char* s){
    int n = strlen(s);
    for(int i = 0; i < n / 2; i++)
        if(s[i] != s[n - 1 - i])
            return false;
    return true;
}

char* cut(char* s, int start, int end){
    int idx = 0;
    char* words = malloc(sizeof(char) * (end - start + 2));
    for(int i = start; i <= end; i++){
        words[idx++] = s[i];
    }
    words[idx] = 0;
    return words;
}

// idxæ˜¯sçš„ç´¢å¼•
void backtrace(char* s, int* returnSize, int** colSizes, int idx){
    if(idx > len)
        return;
    // æ”¶é›†ã€é€’å½’åˆ°æœ€æ·±å¤„è¿›è¡Œæ”¶é›†ã€‘
    if(idx == len){
        char ** tmp = malloc(sizeof(char*) * pathIndex);
        // memcpy(tmp, path, sizeof(path)); sizeof(path) = 4,pathçš„é•¿åº¦ä¸å¤ªå¥½ç®—ï¼Œè¿˜æ˜¯ç”¨forå§
        for(int i = 0; i < pathIndex; i++)
            tmp[i] = path[i];	// ä¼ é€’çš„æ˜¯åœ°å€
        res[*returnSize] = tmp;
        (*colSizes)[(*returnSize)++] = pathIndex;
        return;
    }
    // åˆ†å‰²ã€forå¾ªç¯å¢åŠ æ¨ªå‘æ­¥é•¿ã€‘
    for(int i = idx; i < len; i++){
        char* part = cut(s, idx, i);
        if(!isPalindrome(part))
            continue;
        path[pathIndex++] = part;
        backtrace(s, returnSize, colSizes, i + 1);
        pathIndex--;
    }
    
}

char *** partition(char * s, int* returnSize, int** returnColumnSizes){
    len = strlen(s);
    res = malloc(sizeof(char**) * 40000);
    path = malloc(sizeof(char*) * len);
    *returnColumnSizes = malloc(sizeof(int) * 40000);
    pathIndex = *returnSize = 0;
    backtrace(s, returnSize, returnColumnSizes, 0);
    return res;
}
```

å…¶å®å’Œç»„åˆæœ‰å¼‚æ›²åŒå·¥ä¹‹å¦™

- <span style="color: red;">pythonç‰ˆ</span>

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res = []
        path = []
        def backtrace(idx) -> None:
            if idx > len(s):
                return
            # æ”¶é›†
            if idx == len(s):
                res.append(path.copy())
                return
            # åˆ†å‰²
            for i in range(idx, len(s)):
                # åˆ‡ç‰‡
                tmp = s[idx: i + 1]
                # è‹¥ä¸æ˜¯å›æ–‡ï¼Œåˆ™è·³è¿‡
                if tmp != tmp[::-1]: # [::-1]è¡¨ç¤ºå€’åºè¾“å‡ºtmp; 1æ˜¯æ­¥é•¿ï¼Œè´Ÿæ•°æ˜¯ä»åå¾€å‰
                    continue
                path.append(tmp)
                backtrace(i + 1)
                path.pop()
        backtrace(0)
        return res
```

æœ‰æ—¶å€™å¤§å®¶ä¼šçœ‹åˆ°è¿™æ ·çš„é¢˜è§£

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        ans = []
        path = []
        n = len(s)

        # start è¡¨ç¤ºå½“å‰è¿™æ®µå›æ–‡å­ä¸²çš„å¼€å§‹ä½ç½®
        def dfs(i: int, start: int) -> None:
            if i == n:
                ans.append(path.copy())  # å›ºå®šç­”æ¡ˆ
                return

            # ä¸é€‰ i å’Œ i+1 ä¹‹é—´çš„é€—å·ï¼ˆi=n-1 æ—¶å³è¾¹æ²¡æœ‰é€—å·ï¼‰
            if i < n - 1:
                dfs(i + 1, start)

            # é€‰ i å’Œ i+1 ä¹‹é—´çš„é€—å·
            t = s[start: i + 1]
            if t == t[::-1]:  # åˆ¤æ–­æ˜¯å¦å›æ–‡
                path.append(t)
                dfs(i + 1, i + 1)
                path.pop()  # æ¢å¤ç°åœº

        dfs(0, 0)
        return ans

# ä½œè€…ï¼šendlesscheng(çµä½¬çš„ä»£ç )
```

ä¸¤æ¬¡é€’å½’ï¼ˆ15è¡Œå’Œ21è¡Œï¼‰ï¼Œä¸¤æ¬¡å›æº¯çš„ä»£ç ï¼Œå¦‚æœä½ èƒ½çœ‹å®Œä¹‹åï¼Œåœ¨å¦ä¸€ä¸ªå›æº¯é¢˜å†™å‡ºæ¥ï¼Œé‚£ä½ å¯ä»¥å¥½å¥½å­¦å­¦ï¼Œä¸ç„¶æ¨èforé‡Œå¥—é€’å½’ï¼Œå› ä¸ºä¸¤æ¬¡é€’å½’æƒ…å†µå¤ªå¤æ‚äº†ã€‚

## <span style="color: orange;">93\. å¤åŸ IP åœ°å€</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/restore-ip-addresses/
>
> é¢˜ç›®æè¿°ï¼š
>
> **æœ‰æ•ˆ IP åœ°å€** æ­£å¥½ç”±å››ä¸ªæ•´æ•°ï¼ˆæ¯ä¸ªæ•´æ•°ä½äº `0` åˆ° `255` ä¹‹é—´ç»„æˆï¼Œä¸”ä¸èƒ½å«æœ‰å‰å¯¼ `0`ï¼‰ï¼Œæ•´æ•°ä¹‹é—´ç”¨ `'.'` åˆ†éš”ã€‚
>
> - ä¾‹å¦‚ï¼š`"0.1.2.201"` å’Œ `"192.168.1.1"` æ˜¯ **æœ‰æ•ˆ** IP åœ°å€ï¼Œä½†æ˜¯ `"0.011.255.245"`ã€`"192.168.1.312"` å’Œ `"192.168@1.1"` æ˜¯ **æ— æ•ˆ** IP åœ°å€ã€‚
>
> ç»™å®šä¸€ä¸ªåªåŒ…å«æ•°å­—çš„å­—ç¬¦ä¸² `s` ï¼Œç”¨ä»¥è¡¨ç¤ºä¸€ä¸ª IP åœ°å€ï¼Œè¿”å›æ‰€æœ‰å¯èƒ½çš„**æœ‰æ•ˆ IP åœ°å€**ï¼Œè¿™äº›åœ°å€å¯ä»¥é€šè¿‡åœ¨ `s` ä¸­æ’å…¥ `'.'` æ¥å½¢æˆã€‚ä½  **ä¸èƒ½** é‡æ–°æ’åºæˆ–åˆ é™¤ `s` ä¸­çš„ä»»ä½•æ•°å­—ã€‚ä½ å¯ä»¥æŒ‰ **ä»»ä½•** é¡ºåºè¿”å›ç­”æ¡ˆã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šs = "25525511135"
> è¾“å‡ºï¼š["255.255.11.135","255.255.111.35"]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šs = "0000"
> è¾“å‡ºï¼š["0.0.0.0"]
> ```
>
> **ç¤ºä¾‹ 3ï¼š**
>
> ```
> è¾“å…¥ï¼šs = "101023"
> è¾“å‡ºï¼š["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= s.length <= 20`
> - `s` ä»…ç”±æ•°å­—ç»„æˆ

### <span style="color: burlywood;">è§£æ³•</span>

- <span style="color: red;">cè¯­è¨€ç‰ˆ -Â å›æº¯</span>

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
/*
    è‹¥æœ€åˆé•¿åº¦ä¸æ»¡è¶³è¦æ±‚ï¼Œè¿”å›NULL
    åˆ†å‰²ï¼š
    åˆ¤æ–­char* word åœ¨[0, 255]
    åœ¨wordååŠ .
    æ”¶é›†ï¼š
    å¦‚æœæœ‰å››ä¸ªæ•´æ•°ï¼Œå¼€å§‹åˆ¤æ–­ï¼š
        sä¸ºç©º
            å¯ä»¥æ”¶é›†
        sä¸ä¸ºç©º
            æœ¬æ¬¡åˆ†å‰²å¤±è´¥ï¼Œè·³å‡ºæœ¬å±‚é€’å½’
    éœ€è¦å‡½æ•°ï¼š
    åˆ¤æ–­å­—ç¬¦å†…å®¹å‡½æ•°å’Œé•¿åº¦ bool isEligible(char* word, int i, int j)
*/
char* path;
char** res;
int len;
// word[i, j]
bool isEligible(char* word, int i, int j){
    word[j - i + 1] = 0;
    // aotl å­—ç¬¦ä¸²è½¬é•¿æ•´å‹ï¼Œæ— æ•ˆè¿”å›0
    if(atol(word) > 255 || (word[0] == '0' && j - i > 0))
        return false;
    return true;
}

// path ä¸­æ•´æ•°ä¸ªæ•°ï¼šcount 
void backtrace(char* s, int* resSize, int pathSize, int count){
    // æ”¶é›†
    if(count == 4){
        if(*s != NULL)  return;
        path[pathSize] = 0;
        // æ— è®ºæ€æ ·åˆ†å‰²ï¼Œresçš„æ¯ä¸ªå­—ç¬¦ä¸²éƒ½æ˜¯strlen(s) + 4 çš„é•¿åº¦ã€sæ˜¯æœ€åˆé•¿åº¦ã€‘
        res[(*resSize)] = malloc(sizeof(char) * (len + 4));
        // strcpy å…¨éƒ¨å¤åˆ¶
        strcpy(res[*resSize], path);
        res[(*resSize)++][len + 3] = 0;    // æœ¬æ¬¡æ”¶é›†æœ«å°¾å†™å…¥'\0'
        return;
    }

    // åˆ†å‰²
    int sLen = strlen(s);
    for(int i = 0; i < sLen; i++){
        char* word = malloc(sizeof(char) * (len + 4));
        strcpy(word, s);
        // æ¯æ¬¡éƒ½æ”¹å˜sçš„ä½ç½®ï¼Œä»è€Œä½¿åˆ†å‰²çš„èµ·å§‹ç‚¹ä¸º0
        if(isEligible(word, 0, i)){
            // strncpyæŒ‡å®šå¤åˆ¶é•¿åº¦ï¼Œi + 1 æ˜¯wordçš„é•¿åº¦
            strncpy(path + pathSize, s, i + 1);
            if(count < 3){
                path[pathSize + i + 1] = '.';
                backtrace(s + i + 1, resSize, pathSize + i + 2, count + 1);
            }
            else if(count == 3)   // å¯ä»¥ç”¨elseï¼Œä½†æ˜¯else ifä½¿ç¨‹åºæ›´å¯æ§ï¼Œæ›´ç›´è§‚
                backtrace(s + i + 1, resSize, pathSize + i + 1, count + 1);
        }
    }
   
}

char ** restoreIpAddresses(char * s, int* returnSize){
    len = strlen(s);
    *returnSize = 0;
    if(len < 4 || len > 12)
        return NULL;
    res = malloc(sizeof(char*) * 10001);
    path = malloc(sizeof(char) * (len + 4));
    backtrace(s, returnSize, 0, 0);
    return res;
}
```

- <span style="color: red;">pythonç‰ˆ -Â ä¸‰å±‚for</span>

    > cä¹Ÿå¯ç”¨ä¸‰å±‚forï¼Œå½“æ—¶å†™çš„æ—¶å€™æ²¡æƒ³åˆ°

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        for i in range(1, len(s)-2):
            for j in range(i+1, len(s)-1):
                for k in range(j+1, len(s)):
                    # å‰iä¸ªï¼Œ [i, j), [j, k), [k, len(s))
                    paths = [s[:i], s[i:j], s[j:k], s[k:]]
                    
                        # all(å¯è¿­ä»£å‚æ•°) æ¯ä¸ªéƒ½ä¸ä¸º0æˆ–ç©º
                    if all([(len(path) == 1 or path[0] != '0') and
                           (int(path) >= 0 and int(path) <= 255) 
                            for path in paths]) :
                        # è¿æ¥ç¬¦.join(å…ƒç´ åºåˆ—) å…ƒç´ 1.å…ƒç´ 2.å…ƒç´ 3.å…ƒç´ 4
                        res.append('.'.join(paths))
                            
        return res 
```

æœ¬ä»£ç ä¸­çš„ä¸€äº›æ ¼å¼é—®é¢˜çš„è¯´æ˜ï¼š

æ˜¨å¤©çœ‹ã€Špythonï¼šä»å…¥é—¨åˆ°å®è·µã€‹é‡Œè¯´çš„ï¼Œå½¢å‚å’Œå®å‚ä¸­ç­‰å·ä¸¤è¾¹ä¸è¦ç”¨ç©ºæ ¼ï¼ˆå…³é”®å­—å®å‚ï¼‰ï¼Œä»Šå¤©å‘ç°å½¢å‚å’Œå®å‚æ˜¯è¡¨è¾¾å¼æ—¶ï¼Œå †ä¸€å—å¯è¯»æ€§æ›´é«˜ï¼Œäºæ˜¯ä»¥åå°±è¿™æ ·å†™äº†ã€‚

- <span style="color: red;">pythonç‰ˆ - å›æº¯</span>

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        # ç‰¹åˆ¤
        if not s or len(s) < 4:
            return []
        res = list()
        self.backtrace(s, 0, '', res)
        return res
    # é€‰æ‹©ä¸€ä¸ªæ•° count+1
    def backtrace(self, s: str, count: int, path: str, res: List[str]):
        if count > 4:
            return
        # æ”¶é›†
        if count == 4 and not s:
            res.append(path[ : -1])
            return
        # é€‰æ‹©
        for i in range(len(s)):
            # é€‰æ‹©çš„ä¸¤ç§æƒ…å†µ
            # é¦–å­—ç¬¦ä¸º'0' || å­—ç¬¦å†…å®¹åœ¨èŒƒå›´å†…[0, 255]
            if s[ : i+1] == '0' or (s[0] != '0' and 0 < int(s[ : i+1]) < 256):
                self.backtrace(s[i+1 : ], count+1, path + s[ : i+1] + '.', res)
```

æœ¬æ¬¡`python`ä»£ç å®šä¹‰äº†ä¸€ä¸ªæ­£å¸¸çš„å‡½æ•°ï¼Œè€Œä¸æ˜¯å‡½æ•°å†…å‡½æ•°ï¼Œ`python`çš„å¤„ç†æ€è·¯å’Œ`c`çš„å¤„ç†æ€è·¯çš„æ¡†æ¶ç›¸åŒï¼Œä½†ç»†èŠ‚ä¸Šå·®è·è¿˜æ˜¯ä¸å°ã€‚

## <span style="color: orange;">78\. å­é›†</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/subsets/
>
> é¢˜ç›®æè¿°ï¼š
>
> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œæ•°ç»„ä¸­çš„å…ƒç´  **äº’ä¸ç›¸åŒ** ã€‚è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚
>
> è§£é›† **ä¸èƒ½** åŒ…å«é‡å¤çš„å­é›†ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›è§£é›†ã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šnums = [1,2,3]
> è¾“å‡ºï¼š[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šnums = [0]
> è¾“å‡ºï¼š[[],[0]]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= nums.length <= 10`
> - `-10 <= nums[i] <= 10`
> - `nums` ä¸­çš„æ‰€æœ‰å…ƒç´  **äº’ä¸ç›¸åŒ**

### <span style="color: burlywood;">è§£æ³•-å›æº¯</span>

- <span style="color: red;">cè¯­è¨€ç‰ˆ</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
// å…ˆè´´ä¸€ä¸ªé”™è¯¯çš„æ€è·¯
int** res;
void backtrace(int* nums, int len, int* resSize, int** colSizes, int idx){
    for(int step = idx; step <= len; step++){
        int col = 0;
        res[*resSize] = malloc(sizeof(int) * len);
        for(int i = idx - 1; i < step && i < len; i++)
            res[*resSize][col++] = nums[i];
        (*colSizes)[(*resSize)++] = col;
        backtrace(nums, len, resSize, colSizes, step + 1);
    }
}

int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 10001);
    *returnColumnSizes = malloc(sizeof(int) * 100001);
    *returnSize = 0;
    *returnColumnSizes[(*returnSize)++] = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 1);
    return res;    
}
```

æœ¬ä»£ç çš„é—®é¢˜åœ¨äºä»¥ä¸ºä¸éœ€è¦å›æº¯ï¼Œå…·ä½“å“ªé‡Œæœ‰é—®é¢˜ï¼Œå„ä½æµ‹è¯•ä¸€ä¸‹å°±çŸ¥é“äº†ï¼ˆç®—æ˜¯æ€è€ƒé¢˜ï¼‰

```c
// å›æº¯çš„é‡ç‚¹åœ¨äºæ”¶é›†çš„æ¡ä»¶ å’Œ é€‰æ‹©çš„é€»è¾‘
```

å¯¹äºcï¼Œæ”¶é›†æœ‰ä¸¤ç§å†™æ³•()ï¼š

```c
// å†™æ³•1 mallocä¸´æ—¶æ•°ç»„èµ‹ç»™res
int col = 0;
int* tmp = malloc(sizeof(int) * len);
for(int i = idx - 1; i < step && i < len; i++)
    tmp[col++] = nums[i];
res[*resSize] = tmp;
```

```c
// å†™æ³•2 äºŒç»´æ•°ç»„mallocåˆ—æ•°
int col = 0;
res[*resSize] = malloc(sizeof(int) * len);
for(int i = idx - 1; i < step && i < len; i++)
    res[*resSize][col++] = nums[i];
```

- <span style="color: red;">cç‰ˆ</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
int* path;
int pathIndex;
void backtrace(int* nums, int len, int* resSize, int** colSizes, int idx){
    // æ”¶é›† æ”¶é›†æ¡ä»¶ä¸ºæ— æ¡ä»¶æ”¶é›†
    int* tmp = malloc(sizeof(int) * pathIndex);
    for(int i = 0; i < pathIndex; i++)
        tmp[i] = path[i];
    res[*resSize] = tmp;
    (*colSizes)[(*resSize)++] = pathIndex;
    // åˆ‡å‰²
    for(int i = idx; i < len; i++){
        path[pathIndex++] = nums[i];
        backtrace(nums, len, resSize, colSizes, i + 1);
        pathIndex--;
    }
}

int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 10001);
    *returnColumnSizes = malloc(sizeof(int) * 10001);
    path = malloc(sizeof(int) * 10001);
    pathIndex = *returnSize = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 0);
    return res;    
}
```

- <span style="color: red;">pythonç‰ˆ</span>

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        def backtrace(idx: int) -> None:
            # æ— æ¡ä»¶æ”¶é›†
            res.append(path[:])
            # é€‰æ‹©
            for i in range(idx, len(nums)):
                path.append(nums[i])
                backtrace(i + 1)
                path.pop()
        backtrace(0)
        return res
```

å¦‚æœç»å¸¸çœ‹æˆ‘çš„æ–‡ç« ï¼Œä¼šå‘ç°æˆ‘å†™çš„`py`ä»£ç å¤§éƒ½æ˜¯å‡½æ•°ä¸­å®šä¹‰å‡½æ•°ï¼Œè¿™ç§å†™æ³•çš„å¥½å¤„æ˜¯å¯¹åº”å†…å±‚å‡½æ•°æ¥è¯´ï¼Œå¤–å±‚å‡½æ•°çš„å˜é‡å°±æ˜¯å…¨å±€å˜é‡ï¼Œå¯ä»¥å°‘ä¼ å‡ ä¸ªå‚æ•°ï¼Œå¯¹äºé€’å½’æ¥è®²ï¼Œæ€§èƒ½ä¼šå¥½ä¸€ç‚¹ã€‚

ä¸‹é¢è´´ä¸Šéå‡½æ•°ä¸­çš„å‡½æ•°ä»£ç ï¼š

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        self.backtrace(nums, res, path, 0)
        return res
        
    def backtrace(self, nums: List[int], res: List[int], path: List[int], idx: int) -> None:
        res.append(path.copy())
        for i in range(idx, len(nums)):
            path.append(nums[i])
            self.backtrace(nums, res, path, i + 1)
            path.pop()
```

å¦‚æœä½ å‘ç°å“ªé‡Œçœ‹ä¸æ˜ç™½ï¼Œå»ºè®®å†å›çœ‹ä¹‹å‰çš„æ–‡ç« ï¼Œæˆ‘çš„æ–‡ç« æœ‰äº›å†…å®¹æ˜¯ç¯ç¯ç›¸æ‰£çš„ï¼Œå¦‚æœè¿˜æ˜¯ä¸æ˜ç™½ï¼Œå¯ä»¥ç§æˆ‘ã€‚

## <span style="color: orange;">90\. å­é›† II</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/subsets-ii/
>
> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œå…¶ä¸­å¯èƒ½åŒ…å«é‡å¤å…ƒç´ ï¼Œè¯·ä½ è¿”å›è¯¥æ•°ç»„æ‰€æœ‰å¯èƒ½çš„å­é›†ï¼ˆå¹‚é›†ï¼‰ã€‚
>
> è§£é›† **ä¸èƒ½** åŒ…å«é‡å¤çš„å­é›†ã€‚è¿”å›çš„è§£é›†ä¸­ï¼Œå­é›†å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** æ’åˆ—ã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šnums = [1,2,2]
> è¾“å‡ºï¼š[[],[1],[1,2],[1,2,2],[2],[2,2]]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šnums = [0]
> è¾“å‡ºï¼š[[],[0]]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= nums.length <= 10`
> - `-10 <= nums[i] <= 10`

### <span style="color: burlywood;">è§£æ³•-å›æº¯</span>

- <span style="color: red;">cè¯­è¨€ç‰ˆ</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
int* path;
int pathIndex;
int cmp(const void* a, const void* b){
    return *(int*)a - *(int*)b;
}
void backtrace(int* nums, int len, int* resSize, int** colSizes, int idx){
    // æ”¶é›†
    int col = 0;
    int* tmp = malloc(sizeof(int) * pathIndex);
    for(int i = 0; i < pathIndex; i++)
        tmp[i] = path[i];
    res[*resSize] = tmp;
    (*colSizes)[(*resSize)++] = pathIndex;
    // é€‰æ‹©
    for(int i = idx; i < len; i++){
        // å¯¹å¿«æ’å¥½çš„numså»é‡
        if(i > idx && nums[i] == nums[i - 1])
            continue;
        path[pathIndex++] = nums[i];
        backtrace(nums, len, resSize, colSizes, i + 1);
        pathIndex--;
    }
}

int** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    qsort(nums, numsSize, sizeof(int), cmp);
    res = malloc(sizeof(int*) * 10001);
    path = malloc(sizeof(int) * numsSize);
    *returnColumnSizes = malloc(sizeof(int) * 10001);
    pathIndex = *returnSize = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 0);
    return res;
}
```

ç›¸æ¯”äºæ˜¨å¤©çš„é¢˜ï¼Œæœ¬é¢˜çš„éš¾ç‚¹åœ¨äºå»é‡ï¼Œå¥½åœ¨å‰å‡ å¤©çš„ã€Šã€å›æº¯ç®—æ³•ã€‘ç»„åˆæ€»å’ŒIIã€‹ä¸­ï¼Œæˆ‘ä»¬å·²ç»å­¦ä¼šäº†æ€ä¹ˆå»é‡ï¼šå¿«æ’+`continue`

- <span style="color: red;">pythonç‰ˆ</span>

```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        def backtrace(idx: int) -> None:
            # æ”¶é›†
            res.append(path.copy())
            # é€‰æ‹©
            for i in range(idx, len(nums)):
                # å»é‡
                if i > idx and nums[i] == nums[i - 1]:
                    continue
                path.append(nums[i])
                backtrace(i+1)
                path.pop()
        nums.sort()
        backtrace(0)
        return res 
```

## <span style="color: orange;">491\. é€’å¢å­åºåˆ—</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/non-decreasing-subsequences/
>
> é¢˜ç›®æè¿°ï¼š
>
> ç»™ä½ ä¸€ä¸ªæ•´æ•°æ•°ç»„ `nums` ï¼Œæ‰¾å‡ºå¹¶è¿”å›æ‰€æœ‰è¯¥æ•°ç»„ä¸­ä¸åŒçš„é€’å¢å­åºåˆ—ï¼Œé€’å¢å­åºåˆ—ä¸­ **è‡³å°‘æœ‰ä¸¤ä¸ªå…ƒç´ ** ã€‚ä½ å¯ä»¥æŒ‰ **ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚
>
> æ•°ç»„ä¸­å¯èƒ½å«æœ‰é‡å¤å…ƒç´ ï¼Œå¦‚å‡ºç°ä¸¤ä¸ªæ•´æ•°ç›¸ç­‰ï¼Œä¹Ÿå¯ä»¥è§†ä½œé€’å¢åºåˆ—çš„ä¸€ç§ç‰¹æ®Šæƒ…å†µã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šnums = [4,6,7,7]
> è¾“å‡ºï¼š[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šnums = [4,4,3,2,1]
> è¾“å‡ºï¼š[[4,4]]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= nums.length <= 15`
> - `-100 <= nums[i] <= 100`

### <span style="color: burlywood;">è§£æ³•-å›æº¯</span>

> ç›¸æ¯”äºæ˜¨å¤©çš„é¢˜ï¼Œæœ¬é¢˜çš„éš¾ç‚¹åœ¨äºå¦‚ä½•å»é‡

- <span style="color: red;">cè¯­è¨€ç‰ˆ</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
int* path;
int pathIndex;
void backtrace(int* nums, int len, int* resSize, int** colSizes, int idx){
    if(pathIndex >= 2){
        // æ–°çš„æ”¶é›†æ–¹æ³• - è°ƒç”¨memcpyå‡½æ•°
        int* tmp = malloc(sizeof(int) * pathIndex);
        memcpy(tmp, path, sizeof(int) * pathIndex);
        res[*resSize] = tmp;
        (*colSizes)[(*resSize)++] = pathIndex;
        //return;
    }
    int used[201] = {0};
    for(int i = idx; i < len; i++){        
        // nums[i] å±äº [-100, 100]ï¼Œ+100ä½¿ç´¢å¼•åœ¨[0, 200]
        if(pathIndex > 0 && path[pathIndex - 1] > nums[i] 
           || used[nums[i] + 100] == 1)	// ä¸æ»¡è¶³å•è°ƒä¸å‡ æˆ– ç”¨è¿‡çš„
            continue;
        
        path[pathIndex++] = nums[i];
        used[nums[i] + 100] = 1;	// ç”¨å®Œæ ‡è®°
        backtrace(nums, len, resSize, colSizes, i + 1);
        pathIndex--;
    }
}

int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 1000001);
    path = malloc(sizeof(int) * numsSize);
    *returnColumnSizes = malloc(sizeof(int) * 1000001);
    pathIndex = *returnSize = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 0);
    return res;
}
```

```c
// å»é‡
/*  æ˜¨å¤©çš„å»é‡æ–¹æ³•åœ¨æ­¤å¤„ä¸ä¸å¹²å‡€
if(i > idx && nums[i] == nums[i - 1])
    continue;
å¦‚ï¼š[1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]
[1, 1], [1, 1, 1], [1, 1, 1, 1]å°±ä¼šå¤šå‡ºç°ä¸€æ¬¡
ç©¶å…¶åŸå› ï¼šæœ¬é¢˜ä¸èƒ½æ’åº
*/
```

å¦‚ä»Šå·²å­¦ä¸¤ç§**å»é‡**æ–¹æ³•ï¼Œä¸‰ç§**æ”¶é›†**æ–¹æ³•ï¼Œè¯·æ³¨æ„ç§¯ç´¯

- <span style="color: red;">pythonç‰ˆ</span>

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        def backtrace(idx):
            if len(path) >= 2:
                res.append(path.copy())
            # cä¸­çš„å»é‡æ•°ç»„ç”¨pythonä¸­çš„setå®ç°
            used = set()
            for i in range(idx, len(nums)):
                if len(path) > 0 and path[-1] > nums[i] or nums[i] in used:
                    continue
                used.add(nums[i])
                path.append(nums[i])
                backtrace(i+1)
                path.pop()
        backtrace(0)
        return res
```

```python
# set() - æ— åºä¸é‡å¤å…ƒç´ é›†
# setItems.add(item) å‘setItemså¢åŠ å…ƒç´ 
# item in setItems æ£€æŸ¥itemæ˜¯å¦åœ¨setItemsä¸­ï¼Œè¿”å›boolå€¼
# è¿˜å¯ä»¥è®¡ç®— äº¤å¹¶å·®è¡¥
```

## <span style="color: orange;">46\. å…¨æ’åˆ—</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/permutations/
>
> é¢˜ç›®æè¿°ï¼š
>
> ç»™å®šä¸€ä¸ªä¸å«é‡å¤æ•°å­—çš„æ•°ç»„ `nums` ï¼Œè¿”å›å…¶ *æ‰€æœ‰å¯èƒ½çš„å…¨æ’åˆ—* ã€‚ä½ å¯ä»¥ **æŒ‰ä»»æ„é¡ºåº** è¿”å›ç­”æ¡ˆã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šnums = [1,2,3]
> è¾“å‡ºï¼š[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šnums = [0,1]
> è¾“å‡ºï¼š[[0,1],[1,0]]
> ```
>
> **ç¤ºä¾‹ 3ï¼š**
>
> ```
> è¾“å…¥ï¼šnums = [1]
> è¾“å‡ºï¼š[[1]]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= nums.length <= 6`
> - `-10 <= nums[i] <= 10`
> - `nums` ä¸­çš„æ‰€æœ‰æ•´æ•° **äº’ä¸ç›¸åŒ**

### <span style="color: burlywood;">è§£æ³•-å›æº¯</span>

- <span style="color: red;">cè¯­è¨€ç‰ˆ</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
void swap(int* nums, int idx1, int idx2){
    int tmp = nums[idx1];
    nums[idx1] = nums[idx2];
    nums[idx2] = tmp;
}

void backtrace(int* nums, int len, int* resSize, int** colSizes, int count){
    // æ”¶é›†
    if(count == len){
        int* tmp = malloc(sizeof(int) * len);
        // copy numså³å¯
        memcpy(tmp, nums, sizeof(int) * len);
        (*colSizes)[*resSize] = len;
        res[(*resSize)++] = tmp;
        return;
    }
    // é€‰æ‹©
    for(int i = count; i < len; i++){
        // é€šè¿‡äº¤æ¢çš„æ–¹å¼æ¨¡æ‹Ÿæ’åˆ—
        swap(nums, i, count);
        // æ­¤å¤„ä¼ å…¥çš„å‚æ•°æ˜¯count+1 ä¸æ˜¯i+1
        backtrace(nums, len, resSize, colSizes, count + 1);
        swap(nums, i, count);
    }
}

int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 1001);
    *returnColumnSizes = malloc(sizeof(int) * 1001);
    *returnSize = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 0);
    return res;
}
```

- <span style="color: red;">pythonç‰ˆ</span>

```python
 class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrace(idx):
            if(idx == len(nums)):
                res.append(nums[:])
            for i in range(idx, len(nums)):
                # python å†…ç½®äº¤æ¢ä¸¤ä¸ªæ•°çš„æ–¹æ³•
                nums[i], nums[idx] = nums[idx], nums[i]
                backtrace(idx+1)
                nums[i], nums[idx] = nums[idx], nums[i]
        
        backtrace(0)
        return res
```

## <span style="color: orange;">47\. å…¨æ’åˆ— II</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/permutations-ii/
>
> é¢˜ç›®æè¿°ï¼š
>
> ç»™å®šä¸€ä¸ªå¯åŒ…å«é‡å¤æ•°å­—çš„åºåˆ— `nums` ï¼Œ***æŒ‰ä»»æ„é¡ºåº*** è¿”å›æ‰€æœ‰ä¸é‡å¤çš„å…¨æ’åˆ—ã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šnums = [1,1,2]
> è¾“å‡ºï¼š
> [[1,1,2],
> [1,2,1],
> [2,1,1]]
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šnums = [1,2,3]
> è¾“å‡ºï¼š[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= nums.length <= 8`
> - `-10 <= nums[i] <= 10`

### <span style="color: burlywood;">è§£æ³•-å›æº¯</span>

- <span style="color: red;">cè¯­è¨€ç‰ˆ</span>

```c
  /**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
void swap(int* nums, int i, int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

void backtrace(int* nums, int len, int* resSize, int** colSizes, int idx){
    // æ”¶é›†
    if(idx == len){
        int* tmp = malloc(sizeof(int) * len);
        memcpy(tmp, nums, sizeof(int) * len);
        res[*resSize] = tmp;
        (*colSizes)[(*resSize)++] = len;
    }
    // å‰ä¸¤å¤©çš„å»é‡æ–¹æ³•
    int used[21] = {0};
    for(int i = idx; i < len; i++){
        if(used[nums[i] + 10] == 1)
            continue;
        used[nums[i] + 10] = 1;
        swap(nums, i, idx);
        backtrace(nums, len, resSize, colSizes, idx + 1);
        swap(nums, i, idx);
    }
}

int** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 10001);
    *returnColumnSizes = malloc(sizeof(int) * 10001);
    *returnSize = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 0);
    return res;
}
```

- <span style="color: red;">pythonç‰ˆ</span>

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrace(idx):
            # æ”¶é›†
            if(idx == len(nums)):
                res.append(nums.copy())
            # é€‰æ‹©
            # setæ— åºä¸é‡å¤å…ƒç´ é›†ï¼Œå¯è¿­ä»£å¯¹è±¡
            used = set()
            for i in range(idx, len(nums)):
                if nums[i] in used:
                    continue
                used.add(nums[i])
                nums[i], nums[idx] = nums[idx], nums[i]
                backtrace(idx + 1)
                nums[i], nums[idx] = nums[idx], nums[i]
        
        backtrace(0)
        return res
```

### <span style="color: burlywood;">å…³äºå»é‡é—®é¢˜</span>

å…³äºå»é‡é—®é¢˜ï¼Œæœ‰æ—¶å€™çš„ç”¨è¿™ç§é€»è¾‘ã€é€»è¾‘ä¸€ã€‘å»é‡ï¼š

```c
// candidateså·²æ’åº
if(i > idx && candidates[i] == candidates[i - 1])	// æ­¤å¤„å»é‡ï¼ˆç”±äºæ•°ç»„æœ‰åºï¼‰
        continue;
```

æœ‰æ—¶å€™å»é‡çš„é€»è¾‘ã€é€»è¾‘äºŒã€‘åˆæ˜¯è¿™æ ·çš„ï¼š

```c
if(used[nums[i] + 10] == 1)
            continue;
        used[nums[i] + 10] = 1;
```

æ‰€æœ‰é—®é¢˜åœ¨äºä»€ä¹ˆæ—¶å€™ç”¨ä»€ä¹ˆé€»è¾‘ï¼Œæˆ‘çš„ç†è§£æ˜¯ï¼š

- é—®é¢˜å’Œå•ä¸ªå…ƒç´ çš„é‡å¤ç›¸å…³æ—¶ï¼Œç”¨ã€é€»è¾‘ä¸€ã€‘

    - ç»„åˆæ€»å’ŒII
    - å­é›† II
- é—®é¢˜å’Œå¤šä¸ªå…ƒç´ çš„é‡å¤ç›¸å…³æ—¶ï¼Œç”¨ã€é€»è¾‘äºŒã€‘

    - é€’å¢å­åºåˆ—
    - å…¨æ’åˆ— II

å†è¯´æ¸…æ¥šä¸€ç‚¹å°±æ˜¯ï¼Œ**å¤„ç†çš„é—®é¢˜æ˜¯å•å…µä½œæˆ˜è¿˜æ˜¯å›¢ä¼™ä½œæ¡ˆ**ã€‚æ¯”å¦‚å­é›†é—®é¢˜ï¼Œå°±æ˜¯ä¸€ä¸ªä¸€ä¸ªå–ï¼Œé€’å¢åºåˆ—åˆ™æ˜¯éœ€è¦è€ƒè™‘å‰ä¸€ä¸ªå…ƒç´ ã€‚ä¹‹æ‰€ä»¥è¯´çš„è¿™ä¹ˆéšæ„ï¼Œæ˜¯å› ä¸ºæˆ‘çš„ç†è§£æ°´å¹³ä»…é™ç›®å‰çš„å±‚æ¬¡ã€‚ä½†æ˜¯å¯¹å¤§å®¶ç»å¯¹æ˜¯çŸ¥æ— ä¸è¨€è¨€æ— ä¸å°½ï¼

### <span style="color: burlywood;">é—²èŠ</span>

æ¥ä¸‹æ¥ä¸‰å¤©ä¼šæœ‰è¿ç»­çš„`hard`é¢˜å‡ºç°ï¼Œè¯·æå‰åšå¥½å¿ƒç†å‡†å¤‡

åŸæœ¬æ‰“ç®—å†å­¦ä¸‹cppçš„ï¼Œä¸è¿‡ç²¾åŠ›æœ‰é™ï¼Œç­‰æˆ‘æŠŠpythonå…¥é—¨åï¼Œä¹‹åçš„ä»£ç ä¼šåŠ å…¥cppçš„å†…å®¹ï¼Œå¦‚æœæŠŠè´ªå¿ƒç®—æ³•ã€åŠ¨æ€è§„åˆ’ã€å›¾è®ºè¿™äº›å†…å®¹æ›´å®Œï¼Œæˆ‘åæœŸä¼šè¡¥ä¸Šä¹‹å‰æ–‡ç« ä¸­pythonå’Œcppçš„è§£æ³•ã€‚ç”±äºä¸€å¤©åªèƒ½å‘å¸ƒä¸€ç¯‡æ–‡ç« ï¼Œæ‰€ä»¥è¿™éƒ¨åˆ†å†…å®¹å¯èƒ½éœ€è¦åœ¨ä¸»é¡µé‡Œæ‰¾ï¼Œæˆ‘å±Šæ—¶ä¼šæ”¾åœ¨ä¸€ä¸ªå¥½æ‰¾çš„åœ°æ–¹ğŸ¤

ç®—æ³•çš„è¿™äº›å†…å®¹æˆ‘ä¼šæŒ‰æ¯æ—¥ä¸€æ›´çš„é€Ÿåº¦æ›´å®Œï¼Œè¿‘æœŸå°±ä¸æ‰“å‘¨èµ›äº†ï¼Œç­‰åˆ°è¿™äº›éƒ½æ›´å®Œï¼Œä¹‹åå…¬ä¼—å·çš„å†…å®¹å°±æ˜¯ï¼š

- æ¯å‘¨çš„å‘¨èµ›ã€1/7ã€‘
- è¡¥ä¹‹å‰æ–‡ç« çš„ä»£ç ï¼ˆå«pyå’Œcppï¼‰ã€å°½é‡2/7ã€‘
- å®˜æ–¹æ¯æ—¥ä¸€é¢˜ã€éšç¼˜ã€‘
- share è½¯ä»¶ã€ç”µå­ä¹¦ã€éšç¼˜ã€‘

## <span style="color: orange;">51\. N çš‡å</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/n-queens/
>
> é¢˜ç›®æè¿°ï¼ˆç¤ºä¾‹å›¾ç‰‡è¯·è®¿é—®åŠ›æ‰£æŸ¥çœ‹ï¼‰ï¼š
>
> æŒ‰ç…§å›½é™…è±¡æ£‹çš„è§„åˆ™ï¼Œçš‡åå¯ä»¥æ”»å‡»ä¸ä¹‹å¤„åœ¨åŒä¸€è¡Œæˆ–åŒä¸€åˆ—æˆ–åŒä¸€æ–œçº¿ä¸Šçš„æ£‹å­ã€‚
>
> **n çš‡åé—®é¢˜** ç ”ç©¶çš„æ˜¯å¦‚ä½•å°† `n` ä¸ªçš‡åæ”¾ç½®åœ¨ `nÃ—n` çš„æ£‹ç›˜ä¸Šï¼Œå¹¶ä¸”ä½¿çš‡åå½¼æ­¤ä¹‹é—´ä¸èƒ½ç›¸äº’æ”»å‡»ã€‚
>
> ç»™ä½ ä¸€ä¸ªæ•´æ•° `n` ï¼Œè¿”å›æ‰€æœ‰ä¸åŒçš„ **n çš‡åé—®é¢˜** çš„è§£å†³æ–¹æ¡ˆã€‚
>
> æ¯ä¸€ç§è§£æ³•åŒ…å«ä¸€ä¸ªä¸åŒçš„ **n çš‡åé—®é¢˜** çš„æ£‹å­æ”¾ç½®æ–¹æ¡ˆï¼Œè¯¥æ–¹æ¡ˆä¸­ `'Q'` å’Œ `'.'` åˆ†åˆ«ä»£è¡¨äº†çš‡åå’Œç©ºä½ã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šn = 4
> è¾“å‡ºï¼š[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
> è§£é‡Šï¼šå¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œ4 çš‡åé—®é¢˜å­˜åœ¨ä¸¤ä¸ªä¸åŒçš„è§£æ³•ã€‚
> ```
>
> **ç¤ºä¾‹ 2ï¼š**
>
> ```
> è¾“å…¥ï¼šn = 1
> è¾“å‡ºï¼š[["Q"]]
> ```
>
> **æç¤ºï¼š**
>
> - `1 <= n <= 9`

å¥½æ¶ˆæ¯ï¼Œ`hard`é¢˜è¢«æˆ‘ç äº†ä¸€ä¸ªï¼Œå› ä¸ºé‚£é“é¢˜è¦ç”¨åˆ°å›¾è®ºï¼Œè¿˜æ˜¯åœ¨å›¾è®ºçš„æ—¶å€™å†åˆ·

è¿™é“é¢˜æœ‰ç‚¹æŠ½è±¡ï¼Œå¤§å®¶å¯èƒ½æƒ³ä¸æ¥è§£çš„æƒ…å†µï¼Œè¿™é‡Œç»™å‡ºæç¤ºï¼š

-   æœ¬é¢˜ä¸æ•°ç‹¬é—®é¢˜ç›¸ä¼¼
-   æŒ‰è±¡æ£‹é¦¬èµ°æ—¥ç†è§£é¢˜ç›®æ„æ€

### <span style="color: burlywood;">è§£æ³•-å›æº¯</span>

- <font color='red'>cè¯­è¨€ç‰ˆ</font>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
bool isValid(char** chessboard, int row, int col, int n){
    // åˆ¤æ–­åˆ—ï¼ˆbacktrackä¸­å·²åˆ¤æ–­è¡Œï¼‰
    for(int i = 0; i < row; i++){
        if(chessboard[i][col] == 'Q')
            return false;
    }
    // åˆ¤æ–­45Â°
    for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){
        if(chessboard[i][j] == 'Q')
            return false;
    }
    // åˆ¤æ–­135Â°
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){
        if(chessboard[i][j] == 'Q')
            return false;
    }
    return true;
}

void backtrace(char*** res, char** chessboard, int n, int* resSize, int** colSizes, int idx){
    // æ”¶é›†
    if(idx == n){
        res[*resSize] = malloc(sizeof(char*) * n);
        for(int i = 0; i < n; i++){
            res[*resSize][i] = malloc(sizeof(char) * (n + 1));
            memcpy(res[*resSize][i], chessboard[i], sizeof(char) * (n + 1));
        }
        (*colSizes)[(*resSize)++] = n;
        return;
    }
    // é€‰æ‹© - é€è¡Œæ£€æŸ¥ï¼Œç›¸å½“äºåˆ¤æ–­è¡Œ
    for(int i = 0; i < n; i++){
        if(isValid(chessboard, idx, i, n)){
            chessboard[idx][i] = 'Q';
            backtrace(res, chessboard, n, resSize, colSizes, idx + 1);
            chessboard[idx][i] = '.';   // å›æº¯æ—¶å¡«å……å¥å·
        }
    }
    
}

char *** solveNQueens(int n, int* returnSize, int** returnColumnSizes){
    char *** res = malloc(sizeof(char**) * 1000);
    *returnColumnSizes = malloc(sizeof(int) * 1000);
    // åˆå§‹åŒ–æ£‹ç›˜
    char ** chessboard = malloc(sizeof(char*) * n);
    for(int i = 0; i < n; i++){
        chessboard[i] = malloc(sizeof(char) * (n + 1));
        memset(chessboard[i], '.', sizeof(char) * n);
        chessboard[i][n] = 0;
    }
    *returnSize = 0;
    backtrace(res, chessboard, n, returnSize, returnColumnSizes, 0);
    return res;
}
```

- <font color='red'>pythonç‰ˆ</font>

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        chessboard = [ ['.'] * n for _ in range(n)]
        
        def backtrace(row):
            if(row == len(chessboard)):
                # joinè¿æ¥å­—ç¬¦ä¸²
                tmp = [''.join(i) for i in chessboard]
                res.append(tmp)
                return
            for col in range(n):
                if not self.isValid(chessboard, row, col):
                    continue
                chessboard[row][col] = 'Q'
                backtrace(row+1)
                chessboard[row][col] = '.'
                
        backtrace(0)
        return res

    # æ£€æŸ¥æ­¤å¤„æ”¾Queenæ˜¯å¦åˆæ³•
    def isValid(self, board, row, col):
        n = len(board)

        # æ£€æŸ¥åˆ—
        for i in range(row):
            if board[i][col] == 'Q':
                return False

        # æ£€æŸ¥å³ä¸Š
        # zip å°†å¯¹è±¡æ‰“åŒ…ä¸ºä¸€ä¸ªå…ƒç»„
        for i, j in zip(range(row -1, -1, -1), range(col + 1, n, 1)):
            if board[i][j] == 'Q':
                return False

        # æ£€æŸ¥å·¦ä¸Š
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):
            if board[i][j] == 'Q':
                return False

        return True
```

## <span style="color: orange;">37\. è§£æ•°ç‹¬</span>

> åŠ›æ‰£é“¾æ¥ï¼šhttps://leetcode.cn/problems/sudoku-solver/
>
> é¢˜ç›®æè¿°ï¼ˆç¤ºä¾‹å›¾ç‰‡è¯·è®¿é—®åŠ›æ‰£æŸ¥çœ‹ï¼‰ï¼š
>
> ç¼–å†™ä¸€ä¸ªç¨‹åºï¼Œé€šè¿‡å¡«å……ç©ºæ ¼æ¥è§£å†³æ•°ç‹¬é—®é¢˜ã€‚
>
> æ•°ç‹¬çš„è§£æ³•éœ€ **éµå¾ªå¦‚ä¸‹è§„åˆ™**ï¼š
>
> 1.  æ•°å­— `1-9` åœ¨æ¯ä¸€è¡Œåªèƒ½å‡ºç°ä¸€æ¬¡ã€‚
> 2.  æ•°å­— `1-9` åœ¨æ¯ä¸€åˆ—åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚
> 3.  æ•°å­— `1-9` åœ¨æ¯ä¸€ä¸ªä»¥ç²—å®çº¿åˆ†éš”çš„ `3x3` å®«å†…åªèƒ½å‡ºç°ä¸€æ¬¡ã€‚ï¼ˆè¯·å‚è€ƒç¤ºä¾‹å›¾ï¼‰
>
> æ•°ç‹¬éƒ¨åˆ†ç©ºæ ¼å†…å·²å¡«å…¥äº†æ•°å­—ï¼Œç©ºç™½æ ¼ç”¨ `'.'` è¡¨ç¤ºã€‚
>
> **ç¤ºä¾‹ 1ï¼š**
>
> ```
> è¾“å…¥ï¼šboard = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
> è¾“å‡ºï¼š[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
> è§£é‡Šï¼šè¾“å…¥çš„æ•°ç‹¬å¦‚ä¸Šå›¾æ‰€ç¤ºï¼Œå”¯ä¸€æœ‰æ•ˆçš„è§£å†³æ–¹æ¡ˆå¦‚ä¸‹æ‰€ç¤ºï¼š
> ```
>
> **æç¤ºï¼š**
>
> - `board.length == 9`
> - `board[i].length == 9`
> - `board[i][j]` æ˜¯ä¸€ä½æ•°å­—æˆ–è€… `'.'`
> - é¢˜ç›®æ•°æ® **ä¿è¯** è¾“å…¥æ•°ç‹¬ä»…æœ‰ä¸€ä¸ªè§£

### <span style="color: burlywood;">è§£æ³•-å›æº¯</span>

- <font color='red'>cè¯­è¨€ç‰ˆ</font>

```c
bool isValid(char** board, int row, int col, char val){
    // æ£€æŸ¥è¡Œ
    for(int i = 0; i < 9; i++){
        if(board[row][i] == val)
            return false;
    }
    // æ£€æŸ¥åˆ—
    for(int i = 0; i < 9; i++){
        if(board[i][col] == val)
            return false;
    }
    // æ£€æŸ¥ä¹æ–¹æ ¼
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for(int i = startRow; i < startRow + 3; i++){
        for(int j = startCol; j < startCol + 3; j++){
            if(board[i][j] == val)
                return false;
        }
    }
    
    return true;
}

bool backtrace(char** board, int n){
   for(int i = 0; i < n; i++){
       for(int j = 0; j < n; j++){
           if(board[i][j] != '.')
               continue;
           for(char k = '1'; k <= '9'; k++){
               // åˆæ³•åˆ™ä¿å­˜
               if(isValid(board, i, j, k)){
                   board[i][j] = k;
                   // å¦‚æœä¸‹ä¸ªä½ç½®ä¹Ÿåˆæ³•ï¼Œè¿”å›true
                   if(backtrace(board, n))
                       return true;
                   // ä¸‹ä¸€ä¸ªä½ç½®ä¸åˆæ³•ï¼Œé‡ç½®å½“å‰ä½ç½®ï¼ˆå›æº¯ï¼‰
                   board[i][j] = '.';
               }
           }//for(char k)
           // å¦‚æœ1-9éƒ½ä¸èƒ½è®©ä¸‹ä¸ªä½ç½®åˆæ³•ï¼Œè¯´æ˜æ­¤æ•°ç‹¬æ— è§£
           return false;    
       }//for(int j)
   }// for(int i)
    return true;
}

void solveSudoku(char** board, int boardSize, int* boardColSize){
    backtrace(board, boardSize);
    return;
}
```

æœ¬é¢˜çš„è§£æ³•å½¢å¼ä¸å…¶ä»–é¢˜ä¸å¤ªä¸€æ ·ï¼Œä¸»è¦åŸå› æ˜¯æœ¬é¢˜éœ€è¦æŠŠæ¯ä¸ªç©ºéƒ½å¿…é¡»å¡«ä¸€ä¸ªæ•°ï¼Œè€Œå…¶ä»–é¢˜æ˜¯æ¯ä¸ªç©ºé€‰æ‹©åˆé€‚çš„å€¼ï¼Œå¦‚æœæ²¡æœ‰å°±ä¸å¡«ã€‚

- <font color='red'>pythonç‰ˆ</font>

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        nums = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
        def backtrace():
            for i in range(9):
                for j in range(9):
                    if board[i][j] != '.':
                        continue
                    for k in nums:
                        # å¦‚æœåˆæ³•
                        if isValid(i, j, k):
                            board[i][j] = k
                            # å¦‚æœä¸‹ä¸€ä¸ªä¹Ÿåˆæ³•ï¼Œè¿”å›true
                            if backtrace():
                                return True
                            # å¦åˆ™å›æº¯
                            board[i][j] = '.'
                    # æ— è§£
                    return False
            return True
        
        def isValid(row: int, col: int, k: str):
            # æ£€æŸ¥è¡Œ
            for i in range(0, 9):
                if board[row][i] == k:
                    return False
                
            # æ£€æŸ¥åˆ—
            for i in range(0, 9):
                if board[i][col] == k:
                    return False
                
            # æ£€æŸ¥ä¹å®«æ ¼
            startRow = int(row / 3) * 3
            startCol = int(col / 3) * 3
            for i in range(startRow, startRow+3):
                for j in range(startCol, startCol+3):
                    if(board[i][j] == k):
                        return False
                    
            return True
        backtrace()
```

æ„Ÿè§‰pythonæ²¡cå†™ä¸Šèˆ’æœï¼Œçº³é—·åŠå¤©ä¸ºå•¥æ²¡è¿‡ï¼Œç»“æœæ˜¯å› ä¸ºæ²¡è°ƒç”¨backtrack()ï¼Œä¸è¿‡æŠŠå‡½æ•°å†™å¤–è¾¹å°±å¥½äº†ï¼š

```python
# è°ƒç”¨å‡½æ•°æ—¶è¦ç”¨selfï¼Œselfè¡¨ç¤ºå½“å‰ç±»çš„å¯¹è±¡
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        nums = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
        self.backtrace(board, nums)
        
    def backtrace(self, board, nums):
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    continue
                for k in nums:
                    if self.isValid(board, i, j, k):
                        board[i][j] = k
                        if self.backtrace(board, nums):
                            return True
                        board[i][j] = '.'

                return False
        return True
        

    def isValid(self, board: List[List[str]], row: int, col: int, k: str):
        # æ£€æŸ¥è¡Œ
        for i in range(0, 9):
            if board[row][i] == k:
                return False

        # æ£€æŸ¥åˆ—
        for i in range(0, 9):
            if board[i][col] == k:
                return False

        # æ£€æŸ¥ä¹å®«æ ¼
        startRow = int(row / 3) * 3
        startCol = int(col / 3) * 3
        for i in range(startRow, startRow+3):
            for j in range(startCol, startCol+3):
                if(board[i][j] == k):
                    return False

        return True
```

### <font color='BurlyWood'>å…³äºåŠ›æ‰£ä¸Šçš„self</font>

åŠ›æ‰£çš„`python3`é¢˜è§£ï¼Œå…¶å®æ˜¯å®ç°ä¸€ä¸ª`Solution`ç±»ï¼Œç³»ç»Ÿæµ‹è¯•è¿™ä¸ªç±»ï¼Œå¦‚æœé€šè¿‡æ‰€æœ‰æ ·ä¾‹ï¼Œåˆ™ACã€‚

æ‰€ä»¥åœ¨è°ƒç”¨å‡½æ•°æ—¶ï¼Œå°±è¦åƒå¤„ç†ç±»æ–¹æ³•ä¸€æ ·å¤„ç†è§£é¢˜æ–¹æ³•ï¼ˆè°ƒç”¨åŠ selfï¼Œæ¯ä¸ªç±»æ–¹æ³•çš„ç¬¬ä¸€ä¸ªå‚æ•°æ˜¯`self`ï¼‰ã€‚

é‚£`self`åˆ°åº•æ˜¯ä»€ä¹ˆï¼Œæ£€ç´¢å¯çŸ¥ï¼šè¡¨ç¤ºå½“å‰ç±»çš„å¯¹è±¡ã€‚åªè¦å­¦è¿‡ä¸€é—¨é¢å‘å¯¹è±¡è¯­è¨€å°±çŸ¥é“ï¼Œç±»æ–¹æ³•çš„è°ƒç”¨å¿…é¡»ç”±ç±»å¯¹è±¡å®ç°ï¼Œæ‰€æœ‰`self`å¯ä»¥ç†è§£ä¸ºä¸€ä¸ªä¸´æ—¶çš„å¯¹è±¡ï¼Œä¸»è¦ä¸ºäº†å®Œæˆ`python`çš„`valid`è¯­æ³•è€Œå­˜åœ¨

# <font color='cornflowerblue'>æ€»ç»“</font>

æœ¬ç« èƒ½æ­£å„¿å…«ç»çš„æ€»ç»“ä¸€ä¸‹äº†ï¼Œå…¶ä»–ç« èŠ‚æ„Ÿè§‰å†…å®¹å¤ªå°‘ï¼Œæ²¡å¿…è¦ç”¨ä¸€ç¯‡æ–‡ç« å»æ€»ç»“ï¼Œç©¿æ’åœ¨ä¹‹å‰çš„æ–‡ç« ä¸­å³å¯

## <font color='orange'>å›æº¯ç®—æ³•çš„ç²¾é«“</font>

### <font color='BurlyWood'>è‹¥å¹²ç§æ”¶é›†æ³•</font>

>   å¯¹cè¯­è¨€è€Œè¨€ï¼Œå¦‚æœæ˜¯pythonï¼Œ`res.append(path.copy())`å³å¯
>
>   ç”¨ N çš‡åé—®é¢˜ä¸¾ä¾‹

å’Œå‡ ç»´æ•°ç»„æ²¡å…³ç³»ï¼Œä¸»è¦æ˜¯æ€æƒ³

-   æ˜¯å¦ä½¿ç”¨åº“å‡½æ•°memcpy
-   `malloc`ä¸´æ—¶æ•°ç»„ç»™`res`èµ‹æŒ‡é’ˆï¼Œè¿˜æ˜¯`malloc res`ï¼Œç›´æ¥èµ‹å€¼

```c
/* part 1:ä½¿ç”¨åº“å‡½æ•°memcpy / strcpy
	case 1:æŠŠresçœ‹æˆä¸€ç»´æ•°ç»„ï¼Œæ¯ä¸ªæ•°ç»„ä¸­å­˜æ”¾äºŒç»´æŒ‡é’ˆ
		  å› æ­¤éœ€è¦malloc äºŒç»´æŒ‡é’ˆï¼ˆå¯¹äºresè€Œè¨€ï¼‰ï¼Œé•¿åº¦ä¸ºn
		  åœ¨å¤åˆ¶å­—ç¬¦ä¸²æ—¶ï¼ŒäºŒç»´æŒ‡é’ˆå°±æ˜¯å­˜æ”¾å­—ç¬¦ä¸²ï¼ˆå­—ç¬¦æŒ‡é’ˆæ¨¡æ‹Ÿå­—ç¬¦ä¸²ï¼‰çš„ä¸€ç»´æ•°ç»„
		  å› æ­¤éœ€è¦malloc nä¸ªå­—ç¬¦ä¸²ï¼Œæ¯ä¸ªå­—ç¬¦ä¸²åˆæ˜¯é•¿åº¦ä¸º n+1çš„å­—ç¬¦æŒ‡é’ˆ
*/
char ** tmp = malloc(sizeof(char*) * n);
for(int i = 0; i < n; i++){
    char* tmp1 = malloc(sizeof(char) * (n + 1));
    strcpy(tmp1, chessboard[i]);
    tmp[i] = tmp1;
}
res[*resSize] = tmp;

/*	case 2:æŠŠresçœ‹æˆäºŒç»´æ•°ç»„ï¼Œæ•°ç»„ä¸­çš„å…ƒç´ æ˜¯å­—ç¬¦ä¸²ï¼Œç”¨memcpyèµ‹å€¼
		   å› æ­¤éœ€è¦malloc nè¡Œï¼Œn+1åˆ—ç©ºé—´
*/
res[*resSize] = malloc(sizeof(char*) * n);
for(int i = 0; i < n; i++){
    res[*resSize][i] = malloc(sizeof(char) * (n + 1));
    memcpy(res[*resSize][i], chessboard[i], sizeof(char) * (n + 1));
}
```

>   é—®ï¼š`malloc tmp`æ—¶ä¸ºä»€ä¹ˆä¸å†™æˆ`memcpy(tmp, chessboard, sizeof(char) * (n + 1) * n)`
>
>   ç­”ï¼štmpæ˜¯äºŒç»´å­—ç¬¦æ•°ç»„æ¨¡æ‹Ÿä¸€ç»´å­—ç¬¦ä¸²æ•°ç»„ï¼Œä½†æœ¬è´¨è¿˜æ˜¯äºŒç»´æ•°ç»„ï¼Œæ¯ä¸ªå…ƒç´ æ˜¯`char*`ç±»å‹ï¼Œå¦‚æœä¸å¯¹æ¯ä¸ªå…ƒç´ `malloc`ï¼Œå°±ä¼šå‡ºç°å†…å­˜é—®é¢˜ã€‚åŒæ—¶å­—ç¬¦ä¸²æœ‰`'\0'`é—®é¢˜ï¼Œç›´æ¥memcpyäºŒç»´æ•°ç»„å­˜åœ¨å†…å­˜é—®é¢˜ã€‚

$n$ç»´æ•°ç»„éœ€è¦`malloc` $n - 1$æ¬¡

```c
/* part 2: ä¸ä½¿ç”¨ strcpy / memcpy
		case 1: æŠŠresçœ‹æˆä¸‰ç»´æ•°ç»„ï¼Œæ¯ä¸ªæ•°ç»„ä¸­å­˜æ”¾nè¡Œï¼Œnåˆ—çš„å…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ åˆæ˜¯é•¿åº¦ä¸ºn+1çš„charå‹æ•°æ®
*/
res[*resSize] = malloc(sizeof(char*) * n);
for(int i = 0; i < n; i++){
    res[*resSize][i] = malloc(sizeof(char) * (n + 1));
    memcpy(res[*resSize][i], chessboard[i], sizeof(char) * (n + 1));
    for(int j = 0; j < n + 1; j++)
        res[*resSize][i][j] = chessboard[i][j];
}
```

<font color='red'>å°ç»“</font>

>   å¦‚æœä»ä»£ç è§’åº¦çœ‹ï¼Œæ— éæ˜¯ç”¨ä¸ç”¨åº“å‡½æ•°ï¼Œæ˜¯å¦ä½¿ç”¨`malloc`è¿‡çš„ä¸­é—´å˜é‡æ”¶é›†ç»“æœï¼Œå¦‚æœä»è¿”å›å€¼çš„è§’åº¦æ€è€ƒï¼Œä¼šå‘ç°ç”¨ä¸åŒçš„æ–¹æ³•å®é™…ä¸Šæ˜¯å¯¹`res`ä¸åŒè§’åº¦çš„çœ‹æ³•ï¼Œè€Œè¿™ç§æ€è€ƒæ–¹å¼ä»¤ä¸åŒæ–¹å¼çš„æ”¶é›†å˜å¾—æ¸…æ™°èµ·æ¥

### <font color='BurlyWood'>ä¸¤ç§å»é‡æ–¹å¼</font>

>   åœ¨ã€Šã€å›æº¯ç®—æ³•ã€‘å…¨æ’åˆ— IIã€‹ä¸­æ€»ç»“è¿‡ï¼Œç°åœ¨è´´è¿‡æ¥

å…³äºå»é‡é—®é¢˜ï¼Œæœ‰æ—¶å€™çš„ç”¨è¿™ç§é€»è¾‘ã€é€»è¾‘ä¸€ã€‘å»é‡ï¼š

```c
// candidateså·²æ’åº
if(i > idx && candidates[i] == candidates[i - 1])	// æ­¤å¤„å»é‡ï¼ˆç”±äºæ•°ç»„æœ‰åºï¼‰
        continue;
```

æœ‰æ—¶å€™å»é‡çš„é€»è¾‘ã€é€»è¾‘äºŒã€‘åˆæ˜¯è¿™æ ·çš„ï¼š

```c
if(used[nums[i] + 10] == 1)
            continue;
        used[nums[i] + 10] = 1;
```

æ‰€æœ‰é—®é¢˜åœ¨äºä»€ä¹ˆæ—¶å€™ç”¨ä»€ä¹ˆé€»è¾‘ï¼Œæˆ‘çš„ç†è§£æ˜¯ï¼š

- é—®é¢˜å’Œå•ä¸ªå…ƒç´ çš„é‡å¤ç›¸å…³æ—¶ï¼Œç”¨ã€é€»è¾‘ä¸€ã€‘

    - ç»„åˆæ€»å’ŒII
    - å­é›† II
- é—®é¢˜å’Œå¤šä¸ªå…ƒç´ çš„é‡å¤ç›¸å…³æ—¶ï¼Œç”¨ã€é€»è¾‘äºŒã€‘

    - é€’å¢å­åºåˆ—
    - å…¨æ’åˆ— II

å†è¯´æ¸…æ¥šä¸€ç‚¹å°±æ˜¯ï¼Œ<font color='red'>**å¤„ç†çš„é—®é¢˜æ˜¯å•å…µä½œæˆ˜è¿˜æ˜¯å›¢ä¼™ä½œæ¡ˆ**</font>ã€‚æ¯”å¦‚å­é›†é—®é¢˜ï¼Œå°±æ˜¯ä¸€ä¸ªä¸€ä¸ªå–ï¼Œé€’å¢åºåˆ—åˆ™æ˜¯éœ€è¦è€ƒè™‘å‰ä¸€ä¸ªå…ƒç´ ã€‚

## <font color='orange'>é—²èŠ</font>

å¦‚æœæŠŠè¿™partè·Ÿä¸‹æ¥ï¼Œå¹¶ä¸”è‡ªå·±æ•²äº†ï¼Œé‚£è‡ªå·±æ€»ç»“ä¸ªæ¨¡ç‰ˆå°±æ˜¯ä¿¡æ‰‹ææ¥ï¼š

```python
if isCollections:
    collections()
select()
```

å¦‚æœåœ¨è¯¦ç»†ä¸€ç‚¹ï¼Œå°±æ˜¯ï¼š

```python 
def backtrace(*parameters, idx):
    if isCollections:
        res.append(path.copy())
	for i in range(idx):
        path.append(contents)
        backtrace(..., idx + 1)	# ä¹Ÿå¯èƒ½æ˜¯i + 1, ...æ˜¯çœç•¥å·
        path.pop()
```

ä½†æ˜¯æˆ‘çš„è§‚ç‚¹æ˜¯ä¸å»ºè®®å»æ‰¾æ¨¡ç‰ˆï¼Œçœ‹æ¨¡ç‰ˆï¼ŒèƒŒæ¨¡ç‰ˆï¼ˆè¿™ä¸‰ä»¶äº‹å“ªä¸€ä»¶éƒ½æ²¡å¿…è¦ï¼‰

æ¨¡ç‰ˆä¼šåƒµåŒ–ä½ çš„æ€ç»´ï¼Œè®©ä½ äº§ç”Ÿæ€ç»´æƒ°æ€§ï¼Œä¸æ„¿æ„å»æ€è€ƒå›æº¯çš„è¿‡ç¨‹ã€‚è¿™ä¸ªé—®é¢˜åœ¨æˆ‘åˆ·å›æº¯ç®—æ³•é—®é¢˜çš„åŒç±»å‹é¢˜æ—¶å°±å‘ç°äº†ï¼ˆæ¯”å¦‚xxIIï¼ŒxxIIIï¼‰ï¼Œè¿™ä¸”æ˜¯æˆ‘ä¸ç”¨æ¨¡ç‰ˆçš„æ—¶å€™ï¼Œå¦‚æœç”¨æ¨¡ç‰ˆï¼Œæˆ‘è§‰å¾—è¿™ä¸ªè¿‡ç¨‹ä¼šæ¥å¾—æ›´æ—©ã€‚

è€Œè¿™æ ·çš„é—®é¢˜ä¼šå¸¦æ¥ä»€ä¹ˆç»“æœï¼šé¦–å…ˆï¼Œå¦‚æœæ˜¯æ‰“æ¯”èµ›æˆ–æ˜¯é¢è¯•ï¼Œæ²¡äººå‘Šè¯‰ä½ è¿™ä¸ªé¢˜æ˜¯å›æº¯é—®é¢˜ï¼Œä½ èƒ½åˆ¤æ–­æ¸…æ¥šè¿™ä¸ªé—®é¢˜ç±»å‹å—ï¼›å…¶æ¬¡ï¼Œå¦‚æœä½ ç¬¬ä¸€æ­¥æ²¡é—®é¢˜ï¼Œä½†æ˜¯é‡åˆ°çš„é—®é¢˜å’Œä¹‹å‰çš„é—®é¢˜åŒºåˆ«æœ‰ç‚¹å¤§ï¼Œä½ èƒ½ä¸é€šè¿‡æ¨¡æ‹Ÿå›æº¯çš„è¿‡ç¨‹ï¼Œè€Œä»…é æ¨¡ç‰ˆå®Œæˆå—ã€‚

ç§ä»¥ä¸ºäººä¸äººçš„å·®è·åœ¨äºæ•ˆç‡ï¼Œ<font color='red'>åœ¨åŸºç¡€çš„çŸ¥è¯†éƒ½æŒæ¡çš„æƒ…å†µä¸‹ï¼Œå·®è·å¹¶ä¸å–å†³äºè§å¤šå°‘é¢˜ï¼Œè€Œé‡åœ¨å¸æ”¶è´¨é‡</font>ã€‚è¿™å¥è¯é€‚ç”¨äºä¸å­¦ä¹ ç›¸å…³çš„ä»»ä½•åœ°æ–¹ï¼Œè€ƒç ”æ•°å­¦ä¹Ÿæ˜¯ä¸€æ ·ï¼Œåœ¨æ™ºåŠ›ç›¸å½“çš„æƒ…å†µä¸‹ï¼Œå¤§å®¶éƒ½åˆ·880ï¼Œä½†æ˜¯ä¸ºä»€ä¹ˆåˆ·å®Œä¹‹åçš„æ•ˆæœè‰¯è ä¸é½ã€‚