# <span style="color: cornflowerblue;">回溯算法</span>

贴个回溯算法基础内容的帖子：https://blog.csdn.net/JarvisChu/article/details/16067319?spm=1001.2014.3001.5502

直接上题：

## <span style="color: orange;">77\. 组合</span>

> 力扣链接：https://leetcode.cn/problems/combinations/
>
> 题目描述：
>
> 给定两个整数 `n` 和 `k`，返回范围 `[1, n]` 中所有可能的 `k` 个数的组合。
>
> 你可以按 **任何顺序** 返回答案。
>
> **示例 1：**
>
> ```
> 输入：n = 4, k = 2
> 输出：
> [
> [2,4],
> [3,4],
> [2,3],
> [1,2],
> [1,3],
> [1,4],
> ]
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1, k = 1
> 输出：[[1]]
> ```
>
> **提示：**
>
> - `1 <= n <= 20`
> - `1 <= k <= n`

### <span style="color: burlywood;">解法：递归</span>

- <span style="color: red;">c版本</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** ans;
int* path;
int pathTop;
int ansTop;
void backtrack(int cur, int n, int k){
    // 若满足条件，收集结果
    if(pathTop == k){
        int* temp = malloc(sizeof(int) * k);
        for(int i = 0; i < k; i++)
            temp[i] = path[i];
        ans[ansTop++] = temp;
        return;
    }
    // for确定首个元素，递归确定之后的元素
    for(int i = cur; i <= k; i++){
        path[pathTop++] = i;
        backtrack(i + 1, n, k);
        // i > n 后，回溯
        pathTop--;
    }
}

int** combine(int n, int k, int* returnSize, int** returnColumnSizes){
    path = malloc(sizeof(int) * k);
    ans = malloc(sizeof(int*) * 10001);
    pathTop = ansTop = 0;
    backtrack(1, n, k);
    *returnSize = ansTop;
    *returnColumnSizes = malloc(sizeof(int) * ansTop);
    // 参数数组赋值
    for(int i = 0; i < ansTop; i++)
        (*returnColumnSizes)[i] = k;
    return ans;
}
```

- <span style="color: red;">剪枝</span>

> 剪枝就是把多余的步骤通过条件判断过滤掉

```c
// 把上述代码第20行替换为
for(int i = cur; k - pathTop <= n + 1 - i; i++)
/*
条件左边是还需收集的个数/范围，右边是可收集的个数/范围
例如：n = 4, k = 4，则输出[1,2,3,4]
第一次（第一个元素是1时/i = 1）：
    还需4个元素，k-pathTop = 4
    可收集的范围时[1,2,3,4], n+1-i = 4
第二次（第一个元素是2时/ i = 2）
    还需4个元素，k-pathTop = 4
    可收集的范围时[2,3,4], n+1-i = 3
*/
```

- <span style="color: red;">python版本</span>

```python
class Solution:
    def combine(self, n: int, k: int) -> List[List[int]]:
        # 申请两个数组res，path
        res = []
        path = []
        # 函数中定义函数，称为局部函数
        def backtrack(cur, n, k):
            # 若满足收集条件
            if len(path) == k:
                # 把path赋值到res中
                res.append(path[:])	# [:]是切片语法
                return
            # 相当于for(int i = cur; i < n + 1; i++) 实现选择
            for i in range(cur, n + 1):
                # 将i添加到path尾部
                path.append(i)
                backtrack(i + 1, n, k)
                # 将path尾部元素弹出，进行回溯
                path.pop()
        backtrack(1, n, k)
        return res
```

- <span style="color: red;">剪枝</span>

```python
# 上述代码第14行换为
for i in range(cur, n - (k - len(path)) + 2):
```

### <span style="color: burlywood;">代码剖析</span>

整体说明：第20行中的for循环用于完成结果中的一次选择，第12行的if语句实现对path中的内容进行收集

选择的详细说明：

```c
// for循环实现对首个元素的选择，递归实现对其后元素的选择
for(int i = cur; i <= n; i++){
    path[pathTop++] = i;
    backtrack(i + 1, n, k);
    // 当i > n后，回溯
    pathTop--;
}
```

```c
/* n = 4, k = 2 结果是
[[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
对于本代码：
    cur初值是1, 1作为首个元素存入path，pathTop = 1
    运行到第四行，进入第一层递归，cur作为参数变为2，作为第二个元素存入, pathTop = 2
    运行到第四行，进入第二层递归，满足收集条件，收集, return 到第一层递归
    （cur = 2，i = 2）运行到第六行，pathTop = 1，第一层递归的第一层for循环结束，i = 3
    i存入path，进入第二层递归，满足收集条件，收集，return 到第一层递归
    （cur = 2，i = 3）运行到第六行，回溯path，第一层递归的第二层for循环结束，i = 4
    ……（重复上述8,9行的步骤直到不满足for循环的条件）
    跳出第一层递归
    (cur = 1, i = 1) 运行到第六行，回溯path，最外层（未进递归的代码）的第二层for循环结束，i = 2
    i存入path，进入第一层递归

从第4行到第12行的描述，是首个元素的完整运行过程
本例的首个元素分别是：1,2,3
之后的代码，将重复第4行到第12行的描述
*/
```

收集的简略说明

```c
// 若满足长度要求，则收集
if(pathTop == k){
    // 由于path是全局变量，则使用临时数组temp进行收集
    int* temp = malloc(sizeof(int) * k);
    for(int i = 0; i < k; i++)
        temp[i] = path[i];
    // 用指针赋值
    ans[ansTop++] = temp;
    return;
}
```

如果对本解法还有疑问，可以给我发消息，用一个mid作为回溯算法的第一题跨度有点大，但还是希望各位好好模拟一下！

### <span style="color: burlywood;">闲聊</span>

前两天去玩了，大概一周时间吧，这期间没怎么刷题，更新的内容都是之前存下的（昨天刚回来

之后的内容会进行部分调整，比如：

- 增加python的代码
- 若过程复杂，则会单独用一part进行模拟解释
- 闲聊内容是彩蛋😉

## <span style="color: orange;">216\. 组合总和 III</span>

> 力扣链接：https://leetcode.cn/problems/combination-sum-iii/
>
> 题目描述：
>
> 找出所有相加之和为 `n` 的 `k` 个数的组合，且满足下列条件：
>
> - 只使用数字1到9
> - 每个数字 **最多使用一次**
>
> 返回 *所有可能的有效组合的列表* 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。
>
> **示例 1:**
>
> ```
> 输入: k = 3, n = 7
> 输出: [[1,2,4]]
> 解释:
> 1 + 2 + 4 = 7
> 没有其他符合的组合了。
> ```
>
> **示例 2:**
>
> ```
> 输入: k = 3, n = 9
> 输出: [[1,2,6], [1,3,5], [2,3,4]]
> 解释:
> 1 + 2 + 6 = 9
> 1 + 3 + 5 = 9
> 2 + 3 + 4 = 9
> 没有其他符合的组合了。
> ```
>
> **示例 3:**
>
> ```
> 输入: k = 4, n = 1
> 输出: []
> 解释: 不存在有效的组合。
> 在[1,9]范围内使用4个不同的数字，我们可以得到的最小和是1+2+3+4 = 10，因为10 > 1，没有有效的组合。
> ```
>
> **提示:**
>
> - `2 <= k <= 9`
> - `1 <= n <= 60`

- <span style="color: red;">超时解法 c语言版</span>

    > 如果按照昨天的思路

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int len;
int ** res;
int* path;
int pathIndex;
int sum;
void combine(int k, int n, int cur){
    // 收集结果
    if(pathIndex == k - 1 && n - sum >= cur && n - sum <= 9){
        path[k - 1] = n - sum;
        int* tmp = malloc(sizeof(int) * k);
        for(int i = 0; i < k; i++)
            tmp[i] = path[i];
        res[len++] = tmp;
        return;
    }
    // 选择结果
    for(int i = cur; i <= n; i++){
        sum += i;
        path[pathIndex++] = i;
        combine(k, n, i + 1);
        sum -= i;
        pathIndex--;
    }
}

int** combinationSum3(int k, int n, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 10001);
    path = malloc(sizeof(int) * 10001);
    len = pathIndex = sum = 0;
    combine(k, n, 1);
    *returnSize = len;
    *returnColumnSizes = malloc(sizeof(int) * len);
    for(int i = 0; i < len; i++)
        (*returnColumnSizes)[i] = k;
    return res;
}
```

超时的本质在于第22行的判断，会导致程序的反复回溯。

```c
// 进行如下更改即可
for(int i = cur; i <= n - sum; i++)
```

```c
// 还能进一步优化
for(int i = cur; (k - pathIndex) * i <= n - sum && n - sum <= 9 * (k - pathIndex); i++)
// 可以把 k - pathIndex 定义为一个变量
```

由于要找的数只能出现一次，因此剩余值$n - sum$要比当前值的剩余个数$k - pathIndex$倍大/相等，剩余值要比最大值9的剩余个数 倍 大/相等。

- <span style="color: red;">python版本</span>

```python
class Solution:
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        ans = []
        path = []
        def dfs(i: int, t: int) -> None:
            d = k - len(path)  # 还要选 d 个数
            if t < 0 or t > (i * 2 - d + 1) * d // 2:  # 剪枝
                return
            if d == 0:
                ans.append(path.copy())
                return
            for j in range(i, d - 1, -1):
                path.append(j)
                dfs(j - 1, t - j)
                path.pop()
        dfs(9, n)
        return ans
```

python的代码我是cv的，我不知道为啥改写之后过不了，我待会再试试

## <span style="color: orange;">17\. 电话号码的字母组合</span>

> 力扣链接：https://leetcode.cn/problems/letter-combinations-of-a-phone-number/
>
> 题目描述：
>
> 给定一个仅包含数字 `2-9` 的字符串，返回所有它能表示的字母组合。答案可以按 **任意顺序** 返回。
>
> 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。
>
> **示例 1：**
>
> ```
> 输入：digits = "23"
> 输出：["ad","ae","af","bd","be","bf","cd","ce","cf"]
> ```
>
> **示例 2：**
>
> ```
> 输入：digits = ""
> 输出：[]
> ```
>
> **示例 3：**
>
> ```
> 输入：digits = "2"
> 输出：["a","b","c"]
> ```
>
> **提示：**
>
> - `0 <= digits.length <= 4`
> - `digits[i]` 是范围 `['2', '9']` 的一个数字。

### <span style="color: burlywood;">解法-回溯</span>

- <span style="color: red;">c语言版</span>

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
char map[8][5] = {"abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
char* path;
char** res;
int pathIndex;
int resIndex;
int n;  // res列数

void backtrace(int index, char* digits){
    // 注意收集条件
    if(index == n){
        char* tmp = malloc(sizeof(char) * (n + 1));
        for(int i = 0; i < n; i++){
            tmp[i] = path[i];
        }
        tmp[n] = '\0'; 
        res[resIndex++] = tmp;
        return;
    }
    // 选择
    char* words = map[digits[index] - '2'];
    for(int i = 0; i < strlen(words); i++){
        path[pathIndex++] = words[i];
        backtrace(index + 1, digits);
        pathIndex--;
    }
}

char ** letterCombinations(char * digits, int* returnSize){
    n = strlen(digits);
    if(n == 0){
        *returnSize = 0;
        return NULL;
    }
    path = malloc(sizeof(char) * n);
    res = malloc(sizeof(char*) * 300);
    resIndex = pathIndex = 0;
    backtrace(0, digits);
    *returnSize = resIndex;
    return res;
}
```

- <span style="color: red;">python版</span>

```python
class Solution:
    def letterCombinations(self, digits: str) -> List[str]:
        # 特判
        if not digits:
            return []
        arr = ["abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
        res = []
        def backtrace(index, tmp) -> None:
            if index == len(digits):
                res.append(tmp)
                return
            # 下面两行把digits中的数字映射为arr中对应的字符串
            c = digits[index]
            # ord获取ascii值，48是0的ascii值
            letters = arr[ord(c) - 50]
            for i in letters:
                # tmp + i是字符串的拼接
                backtrace(index + 1, tmp + i)
        backtrace(0, "")
        return res
```

### <span style="color: burlywood;">奇技淫巧</span>

> 淫：过分的；这个成语的意思是创新的观念
>
> 奇技淫巧，以悦妇孺：这种新奇的玩意儿，只用用来取悦女人和小孩（古代观点

```c
n = strlen(digits);
if(n == 0){
    *returnSize = 0;
    return NULL;
}
// 上述可改为
if((n = strlen(digits)) == 0){
        *returnSize = 0;
        return NULL;
}
/*
赋值语句的返回值是赋值的结果
就是说第7行的赋值语句的返回值是strlen(digits)
不建议这样写，可读性太差
*/
```

```c
tmp[n] = '\0';  // 也可写成 tmp[n] = 0;
/*
int型的0转为ascii为char型的NULL，与'\0'等价
即 tmp[n] = 0 <=> tmp[n] = NULL <=> tmp[n] = '\0'
*/
```

## <span style="color: orange;">39\. 组合总和</span>

> 力扣链接：https://leetcode.cn/problems/combination-sum/
>
> 题目描述：
>
> 给你一个 **无重复元素** 的整数数组 `candidates` 和一个目标整数 `target` ，找出 `candidates` 中可以使数字和为目标数 `target` 的 所有 **不同组合** ，并以列表形式返回。你可以按 **任意顺序** 返回这些组合。
>
> `candidates` 中的 **同一个** 数字可以 **无限制重复被选取** 。如果至少一个数字的被选数量不同，则两种组合是不同的。
>
> 对于给定的输入，保证和为 `target` 的不同组合数少于 `150` 个。
>
> **示例 1：**
>
> ```
> 输入：candidates = [2,3,6,7], target = 7
> 输出：[[2,2,3],[7]]
> 解释：
> 2 和 3 可以形成一组候选，2 + 2 + 3 = 7 。注意 2 可以使用多次。
> 7 也是一个候选， 7 = 7 。
> 仅有这两种组合。
> ```
>
> **示例 2：**
>
> ```
> 输入: candidates = [2,3,5], target = 8
> 输出: [[2,2,2,2],[2,3,3],[3,5]]
> ```
>
> **示例 3：**
>
> ```
> 输入: candidates = [2], target = 1
> 输出: []
> ```
>
> **提示：**
>
> - `1 <= candidates.length <= 30`
> - `2 <= candidates[i] <= 40`
> - `candidates` 的所有元素 **互不相同**
> - `1 <= target <= 40`

### <span style="color: burlywood;">解法：回溯</span>

- <span style="color: red;">c语言版</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int ** res;
int resIndex;
int paths[10001];
int pathIndex;
int idx;
void backtrace(int* candidates, int len, int idx, int target, int** columnSizes, int* returnSize){
    if(idx == len)
        return;
    // 收集
    if(target == 0){
        int* tmp = malloc(sizeof(int) * pathIndex);
        for(int i = 0; i < pathIndex; i++)
            tmp[i] = paths[i];
        (*columnSizes)[*returnSize] = pathIndex;
        res[(*returnSize)++] = tmp;
        return;
    }
    backtrace(candidates, len, idx + 1, target, columnSizes, returnSize);
    // 选择
    if(target - candidates[idx] >= 0){
        paths[pathIndex++] = candidates[idx];
        backtrace(candidates, len, idx, target - candidates[idx], columnSizes, returnSize);
        pathIndex--;
    }
}

int** combinationSum(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 10001);
    *returnColumnSizes = malloc(sizeof(int) * 10001);
    resIndex = pathIndex = idx = 0;
    *returnSize = 0;
    backtrace(candidates, candidatesSize, idx, target, returnColumnSizes, returnSize);
    return res;
}
```

- <span style="color: red;">python版</span>

```python
class Solution:
    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        def backtrace(idx, target):
            if idx == len(candidates):
                return
            # 收集
            if target == 0:
                res.append(path[:])
                return;
            backtrace(idx + 1, target)
            # 选择
            if target >= candidates[idx]:
                path.append(candidates[idx])
                # index = -1,表示访问列表的最后一个元素
                backtrace(idx, target - path[-1])
                path.pop()
        backtrace(0, target)
        return res    
```

### <span style="color: burlywood;">代码剖析</span>

> 以c语言代码的为准

此处贴上我的手稿，~~字丑别嫌弃~~

![回溯算法-组合.png](C:/Users/MrFeng/.config/joplin-desktop/resources/0fca277ceb40465181a3e6bda8729ec9.png)

回溯算法-组合.png

回溯算法-组合.png

```c
/* 示例：candidates = [2, 3, 5], target = 8
 result = [[3, 5], [2, 3, 3], [2, 2, 2, 2]]
```

- 红色：代码流程（从上到下，从左到右）
- 紫色：示例
- 绿色：当前递归中访问的candidates的索引，一定程度反映递归层数
- 蓝色：满足收集条件

画圈圈代表是一层代码，运行到某处进入递归；向上箭头是跳出递归；

箭头的尾端（起始的位置）是圈圈，说明代码是在13行，即当前candidates索引等于candidates长度是返回的；箭头的尾端是数字，说明代码运行到25行的选择处，不满足if条件（当前target 小于idx指向的数字）时跳出递归的；如果数字下面有蓝色的√，说明代码进入了第15行的收集，通过return返回的。

本代码最大的问题：candidates中存在多个小数字构成target，需要反复回溯。

## <span style="color: orange;">40.组合总和II</span>

> 力扣链接：https://leetcode.cn/problems/combination-sum-ii/
>
> 题目描述：
>
> 给定一个候选人编号的集合 `candidates` 和一个目标数 `target` ，找出 `candidates` 中所有可以使数字和为 `target` 的组合。
>
> `candidates` 中的每个数字在每个组合中只能使用 **一次** 。
>
> **注意：**解集不能包含重复的组合。
>
> **示例 1:**
>
> ```
> 输入: candidates = [10,1,2,7,6,1,5], target = 8,
> 输出:
> [
> [1,1,6],
> [1,2,5],
> [1,7],
> [2,6]
> ]
> ```
>
> **示例 2:**
>
> ```
> 输入: candidates = [2,5,2,1,2], target = 5,
> 输出:
> [
> [1,2,2],
> [5]
> ]
> ```
>
> **提示:**
>
> - `1 <= candidates.length <= 100`
> - `1 <= candidates[i] <= 50`
> - `1 <= target <= 30`

### <span style="color: burlywood;">解法-回溯</span>

- <span style="color: red;">c语言版</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
int* paths;
int pathIndex;
void backtrace(int* candidates, int len, int target, int* returnSize, int** colSizes, int idx){
    // 收集
    if(target == 0){
        int* tmp = malloc(sizeof(int) * pathIndex);
        for(int i = 0; i < pathIndex; i++)
            tmp[i] = paths[i];
        res[*returnSize] = tmp;
        (*colSizes)[(*returnSize)++] = pathIndex;
        return;
    }
    // 选择
    for(int i = idx; i < len; i++){
        if(target >= candidates[i]){    
            paths[pathIndex++] = candidates[i];
            backtrace(candidates, len, target - candidates[i], returnSize, colSizes, i + 1);
            pathIndex--;
        }
    }
}

int cmp(const void* a1, const void* a2) {
    return *((int*)a1) - *((int*)a2);
}

int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 2001);
    paths = malloc(sizeof(int*) * 2001);
    *returnColumnSizes = malloc(sizeof(int) * 2001);
    *returnSize = 0;
    pathIndex = 0;
    qsort(candidates, candidatesSize, sizeof(int), cmp);
    backtrace(candidates, candidatesSize, target, returnSize, returnColumnSizes, 0);
    return res;
}
```

上述代码的问题在于没有去重，去重的方式：

```c
// 选择
for(int i = idx; i < len; i++){
    if(i > idx && candidates[i] == candidates[i - 1])	// 此处去重（由于数组有序）
        continue;
    if(target >= candidates[i]){    
        paths[pathIndex++] = candidates[i];
        backtrace(candidates, len, target - candidates[i], returnSize, colSizes, i + 1);
        pathIndex--;
    }
}
```

由于数组要排序数组，因此下面这种写法更佳

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
int* paths;
int pathIndex;
void backtrace(int* candidates, int len, int target, int* returnSize, int** colSizes, int idx){
    if(target < 0)
        return;
    // 收集
    if(target == 0){
        int* tmp = malloc(sizeof(int) * pathIndex);
        for(int i = 0; i < pathIndex; i++)
            tmp[i] = paths[i];
        res[*returnSize] = tmp;
        (*colSizes)[(*returnSize)++] = pathIndex;
        return;
    }
    // 选择
    for(int i = idx; i < len; i++){
        if(i > idx && candidates[i] == candidates[i - 1])
            continue;
        if(candidates[i] > target)	// 此处剪枝
            break;
        paths[pathIndex++] = candidates[i];
        backtrace(candidates, len, target - candidates[i], returnSize, colSizes, i + 1);
        pathIndex--;
    }
}

int cmp(const void* a1, const void* a2) {
    return *((int*)a1) - *((int*)a2);
}

int** combinationSum2(int* candidates, int candidatesSize, int target, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 2001);
    paths = malloc(sizeof(int*) * 2001);
    *returnColumnSizes = malloc(sizeof(int) * 2001);
    *returnSize = 0;
    pathIndex = 0;
    qsort(candidates, candidatesSize, sizeof(int), cmp);
    backtrace(candidates, candidatesSize, target, returnSize, returnColumnSizes, 0);
    return res;
}
```

*插播一点debug：*

```c
// bug1
store to null pointer of type 'int'
/*原因：如果申明paths数组时，没有指明长度，则在回溯过程中，paths会指向空
*/
// 指明长度的两种方法:
int paths[1001];	
int* paths = malloc(sizeof(int) * 1001);
```

```c
// bug2
AddressSanitizer:DEADLYSIGNAL
=================================================================
==20==ERROR: AddressSanitizer: SEGV on unknown address 0x00067fff8005 (pc 0x55d49764e1bc bp 0x7ffda15477c0 sp 0x7ffda1547770 T0)
==20==The signal is caused by a READ memory access.
    #6 0x7f8106c08082 in __libc_start_main (/lib/x86_64-linux-gnu/libc.so.6+0x24082)
AddressSanitizer can not provide additional info.
==20==ABORTING

/*这个原因有很多，我本次遇到的是：
参数中的数组指针没有malloc
*/
```

- <span style="color: red;">python版</span>

```python
class Solution:
    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:
        res = []
        path = []
        def backtrace(idx, target):
            if target < 0:
                return
            # 收集
            if target == 0:
                res.append(path[:])
                return
            # 选择
            for i in range(idx, len(candidates)):
                if i > idx and candidates[i] == candidates[i - 1]:
                    continue
                if candidates[i] > target:	# 剪枝
                    break
                path.append(candidates[i])
                backtrace(i + 1, target - path[-1])
                path.pop()
        candidates.sort()
        backtrace(0, target)
        return res
```

<span style="color: red;">**针对组合问题，可以总结为：选择+收集**</span>

## <span style="color: orange;">131.分割回文串</span>

回溯算法可以解决的问题有：

- 组合
- 切割
- 子集
- 排列
- 棋盘

> leetcode链接：https://leetcode.cn/problems/palindrome-partitioning/
>
> 题目描述：
>
> 给你一个字符串 `s`，请你将 `s` 分割成一些子串，使每个子串都是 **回文串** 。返回 `s` 所有可能的分割方案。
>
> **回文串** 是正着读和反着读都一样的字符串。
>
> **示例 1：**
>
> ```
> 输入：s = "aab"
> 输出：[["a","a","b"],["aa","b"]]
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "a"
> 输出：[["a"]]
> ```
>
> **提示：**
>
> - `1 <= s.length <= 16`
> - `s` 仅由小写英文字母组成

### <span style="color: burlywood;">解法-回溯</span>

- <span style="color: red;">c语言版</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
char *** res;
char** path;
int pathIndex;
int len;
bool isPalindrome(char* s){
    int n = strlen(s);
    for(int i = 0; i < n / 2; i++)
        if(s[i] != s[n - 1 - i])
            return false;
    return true;
}

char* cut(char* s, int start, int end){
    int idx = 0;
    char* words = malloc(sizeof(char) * (end - start + 2));
    for(int i = start; i <= end; i++){
        words[idx++] = s[i];
    }
    words[idx] = 0;
    return words;
}

// idx是s的索引
void backtrace(char* s, int* returnSize, int** colSizes, int idx){
    if(idx > len)
        return;
    // 收集【递归到最深处进行收集】
    if(idx == len){
        char ** tmp = malloc(sizeof(char*) * pathIndex);
        // memcpy(tmp, path, sizeof(path)); sizeof(path) = 4,path的长度不太好算，还是用for吧
        for(int i = 0; i < pathIndex; i++)
            tmp[i] = path[i];	// 传递的是地址
        res[*returnSize] = tmp;
        (*colSizes)[(*returnSize)++] = pathIndex;
        return;
    }
    // 分割【for循环增加横向步长】
    for(int i = idx; i < len; i++){
        char* part = cut(s, idx, i);
        if(!isPalindrome(part))
            continue;
        path[pathIndex++] = part;
        backtrace(s, returnSize, colSizes, i + 1);
        pathIndex--;
    }
    
}

char *** partition(char * s, int* returnSize, int** returnColumnSizes){
    len = strlen(s);
    res = malloc(sizeof(char**) * 40000);
    path = malloc(sizeof(char*) * len);
    *returnColumnSizes = malloc(sizeof(int) * 40000);
    pathIndex = *returnSize = 0;
    backtrace(s, returnSize, returnColumnSizes, 0);
    return res;
}
```

其实和组合有异曲同工之妙

- <span style="color: red;">python版</span>

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        res = []
        path = []
        def backtrace(idx) -> None:
            if idx > len(s):
                return
            # 收集
            if idx == len(s):
                res.append(path.copy())
                return
            # 分割
            for i in range(idx, len(s)):
                # 切片
                tmp = s[idx: i + 1]
                # 若不是回文，则跳过
                if tmp != tmp[::-1]: # [::-1]表示倒序输出tmp; 1是步长，负数是从后往前
                    continue
                path.append(tmp)
                backtrace(i + 1)
                path.pop()
        backtrace(0)
        return res
```

有时候大家会看到这样的题解

```python
class Solution:
    def partition(self, s: str) -> List[List[str]]:
        ans = []
        path = []
        n = len(s)

        # start 表示当前这段回文子串的开始位置
        def dfs(i: int, start: int) -> None:
            if i == n:
                ans.append(path.copy())  # 固定答案
                return

            # 不选 i 和 i+1 之间的逗号（i=n-1 时右边没有逗号）
            if i < n - 1:
                dfs(i + 1, start)

            # 选 i 和 i+1 之间的逗号
            t = s[start: i + 1]
            if t == t[::-1]:  # 判断是否回文
                path.append(t)
                dfs(i + 1, i + 1)
                path.pop()  # 恢复现场

        dfs(0, 0)
        return ans

# 作者：endlesscheng(灵佬的代码)
```

两次递归（15行和21行），两次回溯的代码，如果你能看完之后，在另一个回溯题写出来，那你可以好好学学，不然推荐for里套递归，因为两次递归情况太复杂了。

## <span style="color: orange;">93\. 复原 IP 地址</span>

> 力扣链接：https://leetcode.cn/problems/restore-ip-addresses/
>
> 题目描述：
>
> **有效 IP 地址** 正好由四个整数（每个整数位于 `0` 到 `255` 之间组成，且不能含有前导 `0`），整数之间用 `'.'` 分隔。
>
> - 例如：`"0.1.2.201"` 和 `"192.168.1.1"` 是 **有效** IP 地址，但是 `"0.011.255.245"`、`"192.168.1.312"` 和 `"192.168@1.1"` 是 **无效** IP 地址。
>
> 给定一个只包含数字的字符串 `s` ，用以表示一个 IP 地址，返回所有可能的**有效 IP 地址**，这些地址可以通过在 `s` 中插入 `'.'` 来形成。你 **不能** 重新排序或删除 `s` 中的任何数字。你可以按 **任何** 顺序返回答案。
>
> **示例 1：**
>
> ```
> 输入：s = "25525511135"
> 输出：["255.255.11.135","255.255.111.35"]
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "0000"
> 输出：["0.0.0.0"]
> ```
>
> **示例 3：**
>
> ```
> 输入：s = "101023"
> 输出：["1.0.10.23","1.0.102.3","10.1.0.23","10.10.2.3","101.0.2.3"]
> ```
>
> **提示：**
>
> - `1 <= s.length <= 20`
> - `s` 仅由数字组成

### <span style="color: burlywood;">解法</span>

- <span style="color: red;">c语言版 - 回溯</span>

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
/*
    若最初长度不满足要求，返回NULL
    分割：
    判断char* word 在[0, 255]
    在word后加.
    收集：
    如果有四个整数，开始判断：
        s为空
            可以收集
        s不为空
            本次分割失败，跳出本层递归
    需要函数：
    判断字符内容函数和长度 bool isEligible(char* word, int i, int j)
*/
char* path;
char** res;
int len;
// word[i, j]
bool isEligible(char* word, int i, int j){
    word[j - i + 1] = 0;
    // aotl 字符串转长整型，无效返回0
    if(atol(word) > 255 || (word[0] == '0' && j - i > 0))
        return false;
    return true;
}

// path 中整数个数：count 
void backtrace(char* s, int* resSize, int pathSize, int count){
    // 收集
    if(count == 4){
        if(*s != NULL)  return;
        path[pathSize] = 0;
        // 无论怎样分割，res的每个字符串都是strlen(s) + 4 的长度【s是最初长度】
        res[(*resSize)] = malloc(sizeof(char) * (len + 4));
        // strcpy 全部复制
        strcpy(res[*resSize], path);
        res[(*resSize)++][len + 3] = 0;    // 本次收集末尾写入'\0'
        return;
    }

    // 分割
    int sLen = strlen(s);
    for(int i = 0; i < sLen; i++){
        char* word = malloc(sizeof(char) * (len + 4));
        strcpy(word, s);
        // 每次都改变s的位置，从而使分割的起始点为0
        if(isEligible(word, 0, i)){
            // strncpy指定复制长度，i + 1 是word的长度
            strncpy(path + pathSize, s, i + 1);
            if(count < 3){
                path[pathSize + i + 1] = '.';
                backtrace(s + i + 1, resSize, pathSize + i + 2, count + 1);
            }
            else if(count == 3)   // 可以用else，但是else if使程序更可控，更直观
                backtrace(s + i + 1, resSize, pathSize + i + 1, count + 1);
        }
    }
   
}

char ** restoreIpAddresses(char * s, int* returnSize){
    len = strlen(s);
    *returnSize = 0;
    if(len < 4 || len > 12)
        return NULL;
    res = malloc(sizeof(char*) * 10001);
    path = malloc(sizeof(char) * (len + 4));
    backtrace(s, returnSize, 0, 0);
    return res;
}
```

- <span style="color: red;">python版 - 三层for</span>

    > c也可用三层for，当时写的时候没想到

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        res = []
        for i in range(1, len(s)-2):
            for j in range(i+1, len(s)-1):
                for k in range(j+1, len(s)):
                    # 前i个， [i, j), [j, k), [k, len(s))
                    paths = [s[:i], s[i:j], s[j:k], s[k:]]
                    
                        # all(可迭代参数) 每个都不为0或空
                    if all([(len(path) == 1 or path[0] != '0') and
                           (int(path) >= 0 and int(path) <= 255) 
                            for path in paths]) :
                        # 连接符.join(元素序列) 元素1.元素2.元素3.元素4
                        res.append('.'.join(paths))
                            
        return res 
```

本代码中的一些格式问题的说明：

昨天看《python：从入门到实践》里说的，形参和实参中等号两边不要用空格（关键字实参），今天发现形参和实参是表达式时，堆一块可读性更高，于是以后就这样写了。

- <span style="color: red;">python版 - 回溯</span>

```python
class Solution:
    def restoreIpAddresses(self, s: str) -> List[str]:
        # 特判
        if not s or len(s) < 4:
            return []
        res = list()
        self.backtrace(s, 0, '', res)
        return res
    # 选择一个数 count+1
    def backtrace(self, s: str, count: int, path: str, res: List[str]):
        if count > 4:
            return
        # 收集
        if count == 4 and not s:
            res.append(path[ : -1])
            return
        # 选择
        for i in range(len(s)):
            # 选择的两种情况
            # 首字符为'0' || 字符内容在范围内[0, 255]
            if s[ : i+1] == '0' or (s[0] != '0' and 0 < int(s[ : i+1]) < 256):
                self.backtrace(s[i+1 : ], count+1, path + s[ : i+1] + '.', res)
```

本次`python`代码定义了一个正常的函数，而不是函数内函数，`python`的处理思路和`c`的处理思路的框架相同，但细节上差距还是不小。

## <span style="color: orange;">78\. 子集</span>

> 力扣链接：https://leetcode.cn/problems/subsets/
>
> 题目描述：
>
> 给你一个整数数组 `nums` ，数组中的元素 **互不相同** 。返回该数组所有可能的子集（幂集）。
>
> 解集 **不能** 包含重复的子集。你可以按 **任意顺序** 返回解集。
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0]
> 输出：[[],[0]]
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 10`
> - `-10 <= nums[i] <= 10`
> - `nums` 中的所有元素 **互不相同**

### <span style="color: burlywood;">解法-回溯</span>

- <span style="color: red;">c语言版</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
// 先贴一个错误的思路
int** res;
void backtrace(int* nums, int len, int* resSize, int** colSizes, int idx){
    for(int step = idx; step <= len; step++){
        int col = 0;
        res[*resSize] = malloc(sizeof(int) * len);
        for(int i = idx - 1; i < step && i < len; i++)
            res[*resSize][col++] = nums[i];
        (*colSizes)[(*resSize)++] = col;
        backtrace(nums, len, resSize, colSizes, step + 1);
    }
}

int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 10001);
    *returnColumnSizes = malloc(sizeof(int) * 100001);
    *returnSize = 0;
    *returnColumnSizes[(*returnSize)++] = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 1);
    return res;    
}
```

本代码的问题在于以为不需要回溯，具体哪里有问题，各位测试一下就知道了（算是思考题）

```c
// 回溯的重点在于收集的条件 和 选择的逻辑
```

对于c，收集有两种写法()：

```c
// 写法1 malloc临时数组赋给res
int col = 0;
int* tmp = malloc(sizeof(int) * len);
for(int i = idx - 1; i < step && i < len; i++)
    tmp[col++] = nums[i];
res[*resSize] = tmp;
```

```c
// 写法2 二维数组malloc列数
int col = 0;
res[*resSize] = malloc(sizeof(int) * len);
for(int i = idx - 1; i < step && i < len; i++)
    res[*resSize][col++] = nums[i];
```

- <span style="color: red;">c版</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
int* path;
int pathIndex;
void backtrace(int* nums, int len, int* resSize, int** colSizes, int idx){
    // 收集 收集条件为无条件收集
    int* tmp = malloc(sizeof(int) * pathIndex);
    for(int i = 0; i < pathIndex; i++)
        tmp[i] = path[i];
    res[*resSize] = tmp;
    (*colSizes)[(*resSize)++] = pathIndex;
    // 切割
    for(int i = idx; i < len; i++){
        path[pathIndex++] = nums[i];
        backtrace(nums, len, resSize, colSizes, i + 1);
        pathIndex--;
    }
}

int** subsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 10001);
    *returnColumnSizes = malloc(sizeof(int) * 10001);
    path = malloc(sizeof(int) * 10001);
    pathIndex = *returnSize = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 0);
    return res;    
}
```

- <span style="color: red;">python版</span>

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        def backtrace(idx: int) -> None:
            # 无条件收集
            res.append(path[:])
            # 选择
            for i in range(idx, len(nums)):
                path.append(nums[i])
                backtrace(i + 1)
                path.pop()
        backtrace(0)
        return res
```

如果经常看我的文章，会发现我写的`py`代码大都是函数中定义函数，这种写法的好处是对应内层函数来说，外层函数的变量就是全局变量，可以少传几个参数，对于递归来讲，性能会好一点。

下面贴上非函数中的函数代码：

```python
class Solution:
    def subsets(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        self.backtrace(nums, res, path, 0)
        return res
        
    def backtrace(self, nums: List[int], res: List[int], path: List[int], idx: int) -> None:
        res.append(path.copy())
        for i in range(idx, len(nums)):
            path.append(nums[i])
            self.backtrace(nums, res, path, i + 1)
            path.pop()
```

如果你发现哪里看不明白，建议再回看之前的文章，我的文章有些内容是环环相扣的，如果还是不明白，可以私我。

## <span style="color: orange;">90\. 子集 II</span>

> 力扣链接：https://leetcode.cn/problems/subsets-ii/
>
> 给你一个整数数组 `nums` ，其中可能包含重复元素，请你返回该数组所有可能的子集（幂集）。
>
> 解集 **不能** 包含重复的子集。返回的解集中，子集可以按 **任意顺序** 排列。
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,2]
> 输出：[[],[1],[1,2],[1,2,2],[2],[2,2]]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0]
> 输出：[[],[0]]
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 10`
> - `-10 <= nums[i] <= 10`

### <span style="color: burlywood;">解法-回溯</span>

- <span style="color: red;">c语言版</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
int* path;
int pathIndex;
int cmp(const void* a, const void* b){
    return *(int*)a - *(int*)b;
}
void backtrace(int* nums, int len, int* resSize, int** colSizes, int idx){
    // 收集
    int col = 0;
    int* tmp = malloc(sizeof(int) * pathIndex);
    for(int i = 0; i < pathIndex; i++)
        tmp[i] = path[i];
    res[*resSize] = tmp;
    (*colSizes)[(*resSize)++] = pathIndex;
    // 选择
    for(int i = idx; i < len; i++){
        // 对快排好的nums去重
        if(i > idx && nums[i] == nums[i - 1])
            continue;
        path[pathIndex++] = nums[i];
        backtrace(nums, len, resSize, colSizes, i + 1);
        pathIndex--;
    }
}

int** subsetsWithDup(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    qsort(nums, numsSize, sizeof(int), cmp);
    res = malloc(sizeof(int*) * 10001);
    path = malloc(sizeof(int) * numsSize);
    *returnColumnSizes = malloc(sizeof(int) * 10001);
    pathIndex = *returnSize = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 0);
    return res;
}
```

相比于昨天的题，本题的难点在于去重，好在前几天的《【回溯算法】组合总和II》中，我们已经学会了怎么去重：快排+`continue`

- <span style="color: red;">python版</span>

```python
class Solution:
    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        def backtrace(idx: int) -> None:
            # 收集
            res.append(path.copy())
            # 选择
            for i in range(idx, len(nums)):
                # 去重
                if i > idx and nums[i] == nums[i - 1]:
                    continue
                path.append(nums[i])
                backtrace(i+1)
                path.pop()
        nums.sort()
        backtrace(0)
        return res 
```

## <span style="color: orange;">491\. 递增子序列</span>

> 力扣链接：https://leetcode.cn/problems/non-decreasing-subsequences/
>
> 题目描述：
>
> 给你一个整数数组 `nums` ，找出并返回所有该数组中不同的递增子序列，递增子序列中 **至少有两个元素** 。你可以按 **任意顺序** 返回答案。
>
> 数组中可能含有重复元素，如出现两个整数相等，也可以视作递增序列的一种特殊情况。
>
> **示例 1：**
>
> ```
> 输入：nums = [4,6,7,7]
> 输出：[[4,6],[4,6,7],[4,6,7,7],[4,7],[4,7,7],[6,7],[6,7,7],[7,7]]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [4,4,3,2,1]
> 输出：[[4,4]]
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 15`
> - `-100 <= nums[i] <= 100`

### <span style="color: burlywood;">解法-回溯</span>

> 相比于昨天的题，本题的难点在于如何去重

- <span style="color: red;">c语言版</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
int* path;
int pathIndex;
void backtrace(int* nums, int len, int* resSize, int** colSizes, int idx){
    if(pathIndex >= 2){
        // 新的收集方法 - 调用memcpy函数
        int* tmp = malloc(sizeof(int) * pathIndex);
        memcpy(tmp, path, sizeof(int) * pathIndex);
        res[*resSize] = tmp;
        (*colSizes)[(*resSize)++] = pathIndex;
        //return;
    }
    int used[201] = {0};
    for(int i = idx; i < len; i++){        
        // nums[i] 属于 [-100, 100]，+100使索引在[0, 200]
        if(pathIndex > 0 && path[pathIndex - 1] > nums[i] 
           || used[nums[i] + 100] == 1)	// 不满足单调不减 或 用过的
            continue;
        
        path[pathIndex++] = nums[i];
        used[nums[i] + 100] = 1;	// 用完标记
        backtrace(nums, len, resSize, colSizes, i + 1);
        pathIndex--;
    }
}

int** findSubsequences(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 1000001);
    path = malloc(sizeof(int) * numsSize);
    *returnColumnSizes = malloc(sizeof(int) * 1000001);
    pathIndex = *returnSize = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 0);
    return res;
}
```

```c
// 去重
/*  昨天的去重方法在此处不不干净
if(i > idx && nums[i] == nums[i - 1])
    continue;
如：[1,2,3,4,5,6,7,8,9,10,1,1,1,1,1]
[1, 1], [1, 1, 1], [1, 1, 1, 1]就会多出现一次
究其原因：本题不能排序
*/
```

如今已学两种**去重**方法，三种**收集**方法，请注意积累

- <span style="color: red;">python版</span>

```python
class Solution:
    def findSubsequences(self, nums: List[int]) -> List[List[int]]:
        res = []
        path = []
        def backtrace(idx):
            if len(path) >= 2:
                res.append(path.copy())
            # c中的去重数组用python中的set实现
            used = set()
            for i in range(idx, len(nums)):
                if len(path) > 0 and path[-1] > nums[i] or nums[i] in used:
                    continue
                used.add(nums[i])
                path.append(nums[i])
                backtrace(i+1)
                path.pop()
        backtrace(0)
        return res
```

```python
# set() - 无序不重复元素集
# setItems.add(item) 向setItems增加元素
# item in setItems 检查item是否在setItems中，返回bool值
# 还可以计算 交并差补
```

## <span style="color: orange;">46\. 全排列</span>

> 力扣链接：https://leetcode.cn/problems/permutations/
>
> 题目描述：
>
> 给定一个不含重复数字的数组 `nums` ，返回其 *所有可能的全排列* 。你可以 **按任意顺序** 返回答案。
>
> **示例 1：**
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [0,1]
> 输出：[[0,1],[1,0]]
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [1]
> 输出：[[1]]
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 6`
> - `-10 <= nums[i] <= 10`
> - `nums` 中的所有整数 **互不相同**

### <span style="color: burlywood;">解法-回溯</span>

- <span style="color: red;">c语言版</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
void swap(int* nums, int idx1, int idx2){
    int tmp = nums[idx1];
    nums[idx1] = nums[idx2];
    nums[idx2] = tmp;
}

void backtrace(int* nums, int len, int* resSize, int** colSizes, int count){
    // 收集
    if(count == len){
        int* tmp = malloc(sizeof(int) * len);
        // copy nums即可
        memcpy(tmp, nums, sizeof(int) * len);
        (*colSizes)[*resSize] = len;
        res[(*resSize)++] = tmp;
        return;
    }
    // 选择
    for(int i = count; i < len; i++){
        // 通过交换的方式模拟排列
        swap(nums, i, count);
        // 此处传入的参数是count+1 不是i+1
        backtrace(nums, len, resSize, colSizes, count + 1);
        swap(nums, i, count);
    }
}

int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 1001);
    *returnColumnSizes = malloc(sizeof(int) * 1001);
    *returnSize = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 0);
    return res;
}
```

- <span style="color: red;">python版</span>

```python
 class Solution:
    def permute(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrace(idx):
            if(idx == len(nums)):
                res.append(nums[:])
            for i in range(idx, len(nums)):
                # python 内置交换两个数的方法
                nums[i], nums[idx] = nums[idx], nums[i]
                backtrace(idx+1)
                nums[i], nums[idx] = nums[idx], nums[i]
        
        backtrace(0)
        return res
```

## <span style="color: orange;">47\. 全排列 II</span>

> 力扣链接：https://leetcode.cn/problems/permutations-ii/
>
> 题目描述：
>
> 给定一个可包含重复数字的序列 `nums` ，***按任意顺序*** 返回所有不重复的全排列。
>
> **示例 1：**
>
> ```
> 输入：nums = [1,1,2]
> 输出：
> [[1,1,2],
> [1,2,1],
> [2,1,1]]
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 8`
> - `-10 <= nums[i] <= 10`

### <span style="color: burlywood;">解法-回溯</span>

- <span style="color: red;">c语言版</span>

```c
  /**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** res;
void swap(int* nums, int i, int j){
    int tmp = nums[i];
    nums[i] = nums[j];
    nums[j] = tmp;
}

void backtrace(int* nums, int len, int* resSize, int** colSizes, int idx){
    // 收集
    if(idx == len){
        int* tmp = malloc(sizeof(int) * len);
        memcpy(tmp, nums, sizeof(int) * len);
        res[*resSize] = tmp;
        (*colSizes)[(*resSize)++] = len;
    }
    // 前两天的去重方法
    int used[21] = {0};
    for(int i = idx; i < len; i++){
        if(used[nums[i] + 10] == 1)
            continue;
        used[nums[i] + 10] = 1;
        swap(nums, i, idx);
        backtrace(nums, len, resSize, colSizes, idx + 1);
        swap(nums, i, idx);
    }
}

int** permuteUnique(int* nums, int numsSize, int* returnSize, int** returnColumnSizes){
    res = malloc(sizeof(int*) * 10001);
    *returnColumnSizes = malloc(sizeof(int) * 10001);
    *returnSize = 0;
    backtrace(nums, numsSize, returnSize, returnColumnSizes, 0);
    return res;
}
```

- <span style="color: red;">python版</span>

```python
class Solution:
    def permuteUnique(self, nums: List[int]) -> List[List[int]]:
        res = []
        def backtrace(idx):
            # 收集
            if(idx == len(nums)):
                res.append(nums.copy())
            # 选择
            # set无序不重复元素集，可迭代对象
            used = set()
            for i in range(idx, len(nums)):
                if nums[i] in used:
                    continue
                used.add(nums[i])
                nums[i], nums[idx] = nums[idx], nums[i]
                backtrace(idx + 1)
                nums[i], nums[idx] = nums[idx], nums[i]
        
        backtrace(0)
        return res
```

### <span style="color: burlywood;">关于去重问题</span>

关于去重问题，有时候的用这种逻辑【逻辑一】去重：

```c
// candidates已排序
if(i > idx && candidates[i] == candidates[i - 1])	// 此处去重（由于数组有序）
        continue;
```

有时候去重的逻辑【逻辑二】又是这样的：

```c
if(used[nums[i] + 10] == 1)
            continue;
        used[nums[i] + 10] = 1;
```

所有问题在于什么时候用什么逻辑，我的理解是：

- 问题和单个元素的重复相关时，用【逻辑一】

    - 组合总和II
    - 子集 II
- 问题和多个元素的重复相关时，用【逻辑二】

    - 递增子序列
    - 全排列 II

再说清楚一点就是，**处理的问题是单兵作战还是团伙作案**。比如子集问题，就是一个一个取，递增序列则是需要考虑前一个元素。之所以说的这么随意，是因为我的理解水平仅限目前的层次。但是对大家绝对是知无不言言无不尽！

### <span style="color: burlywood;">闲聊</span>

接下来三天会有连续的`hard`题出现，请提前做好心理准备

原本打算再学下cpp的，不过精力有限，等我把python入门后，之后的代码会加入cpp的内容，如果把贪心算法、动态规划、图论这些内容更完，我后期会补上之前文章中python和cpp的解法。由于一天只能发布一篇文章，所以这部分内容可能需要在主页里找，我届时会放在一个好找的地方🤞

算法的这些内容我会按每日一更的速度更完，近期就不打周赛了，等到这些都更完，之后公众号的内容就是：

- 每周的周赛【1/7】
- 补之前文章的代码（含py和cpp）【尽量2/7】
- 官方每日一题【随缘】
- share 软件、电子书【随缘】

## <span style="color: orange;">51\. N 皇后</span>

> 力扣链接：https://leetcode.cn/problems/n-queens/
>
> 题目描述（示例图片请访问力扣查看）：
>
> 按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。
>
> **n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。
>
> 给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。
>
> 每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。
>
> **示例 1：**
>
> ```
> 输入：n = 4
> 输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
> 解释：如上图所示，4 皇后问题存在两个不同的解法。
> ```
>
> **示例 2：**
>
> ```
> 输入：n = 1
> 输出：[["Q"]]
> ```
>
> **提示：**
>
> - `1 <= n <= 9`

好消息，`hard`题被我砍了一个，因为那道题要用到图论，还是在图论的时候再刷

这道题有点抽象，大家可能想不来解的情况，这里给出提示：

-   本题与数独问题相似
-   按象棋馬走日理解题目意思

### <span style="color: burlywood;">解法-回溯</span>

- <font color='red'>c语言版</font>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
bool isValid(char** chessboard, int row, int col, int n){
    // 判断列（backtrack中已判断行）
    for(int i = 0; i < row; i++){
        if(chessboard[i][col] == 'Q')
            return false;
    }
    // 判断45°
    for(int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--){
        if(chessboard[i][j] == 'Q')
            return false;
    }
    // 判断135°
    for(int i = row - 1, j = col + 1; i >= 0 && j < n; i--, j++){
        if(chessboard[i][j] == 'Q')
            return false;
    }
    return true;
}

void backtrace(char*** res, char** chessboard, int n, int* resSize, int** colSizes, int idx){
    // 收集
    if(idx == n){
        res[*resSize] = malloc(sizeof(char*) * n);
        for(int i = 0; i < n; i++){
            res[*resSize][i] = malloc(sizeof(char) * (n + 1));
            memcpy(res[*resSize][i], chessboard[i], sizeof(char) * (n + 1));
        }
        (*colSizes)[(*resSize)++] = n;
        return;
    }
    // 选择 - 逐行检查，相当于判断行
    for(int i = 0; i < n; i++){
        if(isValid(chessboard, idx, i, n)){
            chessboard[idx][i] = 'Q';
            backtrace(res, chessboard, n, resSize, colSizes, idx + 1);
            chessboard[idx][i] = '.';   // 回溯时填充句号
        }
    }
    
}

char *** solveNQueens(int n, int* returnSize, int** returnColumnSizes){
    char *** res = malloc(sizeof(char**) * 1000);
    *returnColumnSizes = malloc(sizeof(int) * 1000);
    // 初始化棋盘
    char ** chessboard = malloc(sizeof(char*) * n);
    for(int i = 0; i < n; i++){
        chessboard[i] = malloc(sizeof(char) * (n + 1));
        memset(chessboard[i], '.', sizeof(char) * n);
        chessboard[i][n] = 0;
    }
    *returnSize = 0;
    backtrace(res, chessboard, n, returnSize, returnColumnSizes, 0);
    return res;
}
```

- <font color='red'>python版</font>

```python
class Solution:
    def solveNQueens(self, n: int) -> List[List[str]]:
        res = []
        chessboard = [ ['.'] * n for _ in range(n)]
        
        def backtrace(row):
            if(row == len(chessboard)):
                # join连接字符串
                tmp = [''.join(i) for i in chessboard]
                res.append(tmp)
                return
            for col in range(n):
                if not self.isValid(chessboard, row, col):
                    continue
                chessboard[row][col] = 'Q'
                backtrace(row+1)
                chessboard[row][col] = '.'
                
        backtrace(0)
        return res

    # 检查此处放Queen是否合法
    def isValid(self, board, row, col):
        n = len(board)

        # 检查列
        for i in range(row):
            if board[i][col] == 'Q':
                return False

        # 检查右上
        # zip 将对象打包为一个元组
        for i, j in zip(range(row -1, -1, -1), range(col + 1, n, 1)):
            if board[i][j] == 'Q':
                return False

        # 检查左上
        for i, j in zip(range(row - 1, -1, -1), range(col - 1, -1, -1)):
            if board[i][j] == 'Q':
                return False

        return True
```

## <span style="color: orange;">37\. 解数独</span>

> 力扣链接：https://leetcode.cn/problems/sudoku-solver/
>
> 题目描述（示例图片请访问力扣查看）：
>
> 编写一个程序，通过填充空格来解决数独问题。
>
> 数独的解法需 **遵循如下规则**：
>
> 1.  数字 `1-9` 在每一行只能出现一次。
> 2.  数字 `1-9` 在每一列只能出现一次。
> 3.  数字 `1-9` 在每一个以粗实线分隔的 `3x3` 宫内只能出现一次。（请参考示例图）
>
> 数独部分空格内已填入了数字，空白格用 `'.'` 表示。
>
> **示例 1：**
>
> ```
> 输入：board = [["5","3",".",".","7",".",".",".","."],["6",".",".","1","9","5",".",".","."],[".","9","8",".",".",".",".","6","."],["8",".",".",".","6",".",".",".","3"],["4",".",".","8",".","3",".",".","1"],["7",".",".",".","2",".",".",".","6"],[".","6",".",".",".",".","2","8","."],[".",".",".","4","1","9",".",".","5"],[".",".",".",".","8",".",".","7","9"]]
> 输出：[["5","3","4","6","7","8","9","1","2"],["6","7","2","1","9","5","3","4","8"],["1","9","8","3","4","2","5","6","7"],["8","5","9","7","6","1","4","2","3"],["4","2","6","8","5","3","7","9","1"],["7","1","3","9","2","4","8","5","6"],["9","6","1","5","3","7","2","8","4"],["2","8","7","4","1","9","6","3","5"],["3","4","5","2","8","6","1","7","9"]]
> 解释：输入的数独如上图所示，唯一有效的解决方案如下所示：
> ```
>
> **提示：**
>
> - `board.length == 9`
> - `board[i].length == 9`
> - `board[i][j]` 是一位数字或者 `'.'`
> - 题目数据 **保证** 输入数独仅有一个解

### <span style="color: burlywood;">解法-回溯</span>

- <font color='red'>c语言版</font>

```c
bool isValid(char** board, int row, int col, char val){
    // 检查行
    for(int i = 0; i < 9; i++){
        if(board[row][i] == val)
            return false;
    }
    // 检查列
    for(int i = 0; i < 9; i++){
        if(board[i][col] == val)
            return false;
    }
    // 检查九方格
    int startRow = (row / 3) * 3;
    int startCol = (col / 3) * 3;
    for(int i = startRow; i < startRow + 3; i++){
        for(int j = startCol; j < startCol + 3; j++){
            if(board[i][j] == val)
                return false;
        }
    }
    
    return true;
}

bool backtrace(char** board, int n){
   for(int i = 0; i < n; i++){
       for(int j = 0; j < n; j++){
           if(board[i][j] != '.')
               continue;
           for(char k = '1'; k <= '9'; k++){
               // 合法则保存
               if(isValid(board, i, j, k)){
                   board[i][j] = k;
                   // 如果下个位置也合法，返回true
                   if(backtrace(board, n))
                       return true;
                   // 下一个位置不合法，重置当前位置（回溯）
                   board[i][j] = '.';
               }
           }//for(char k)
           // 如果1-9都不能让下个位置合法，说明此数独无解
           return false;    
       }//for(int j)
   }// for(int i)
    return true;
}

void solveSudoku(char** board, int boardSize, int* boardColSize){
    backtrace(board, boardSize);
    return;
}
```

本题的解法形式与其他题不太一样，主要原因是本题需要把每个空都必须填一个数，而其他题是每个空选择合适的值，如果没有就不填。

- <font color='red'>python版</font>

```python
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        nums = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
        def backtrace():
            for i in range(9):
                for j in range(9):
                    if board[i][j] != '.':
                        continue
                    for k in nums:
                        # 如果合法
                        if isValid(i, j, k):
                            board[i][j] = k
                            # 如果下一个也合法，返回true
                            if backtrace():
                                return True
                            # 否则回溯
                            board[i][j] = '.'
                    # 无解
                    return False
            return True
        
        def isValid(row: int, col: int, k: str):
            # 检查行
            for i in range(0, 9):
                if board[row][i] == k:
                    return False
                
            # 检查列
            for i in range(0, 9):
                if board[i][col] == k:
                    return False
                
            # 检查九宫格
            startRow = int(row / 3) * 3
            startCol = int(col / 3) * 3
            for i in range(startRow, startRow+3):
                for j in range(startCol, startCol+3):
                    if(board[i][j] == k):
                        return False
                    
            return True
        backtrace()
```

感觉python没c写上舒服，纳闷半天为啥没过，结果是因为没调用backtrack()，不过把函数写外边就好了：

```python
# 调用函数时要用self，self表示当前类的对象
class Solution:
    def solveSudoku(self, board: List[List[str]]) -> None:
        nums = ['1', '2', '3', '4', '5', '6', '7', '8', '9']
        self.backtrace(board, nums)
        
    def backtrace(self, board, nums):
        for i in range(9):
            for j in range(9):
                if board[i][j] != '.':
                    continue
                for k in nums:
                    if self.isValid(board, i, j, k):
                        board[i][j] = k
                        if self.backtrace(board, nums):
                            return True
                        board[i][j] = '.'

                return False
        return True
        

    def isValid(self, board: List[List[str]], row: int, col: int, k: str):
        # 检查行
        for i in range(0, 9):
            if board[row][i] == k:
                return False

        # 检查列
        for i in range(0, 9):
            if board[i][col] == k:
                return False

        # 检查九宫格
        startRow = int(row / 3) * 3
        startCol = int(col / 3) * 3
        for i in range(startRow, startRow+3):
            for j in range(startCol, startCol+3):
                if(board[i][j] == k):
                    return False

        return True
```

### <font color='BurlyWood'>关于力扣上的self</font>

力扣的`python3`题解，其实是实现一个`Solution`类，系统测试这个类，如果通过所有样例，则AC。

所以在调用函数时，就要像处理类方法一样处理解题方法（调用加self，每个类方法的第一个参数是`self`）。

那`self`到底是什么，检索可知：表示当前类的对象。只要学过一门面向对象语言就知道，类方法的调用必须由类对象实现，所有`self`可以理解为一个临时的对象，主要为了完成`python`的`valid`语法而存在

# <font color='cornflowerblue'>总结</font>

本章能正儿八经的总结一下了，其他章节感觉内容太少，没必要用一篇文章去总结，穿插在之前的文章中即可

## <font color='orange'>回溯算法的精髓</font>

### <font color='BurlyWood'>若干种收集法</font>

>   对c语言而言，如果是python，`res.append(path.copy())`即可
>
>   用 N 皇后问题举例

和几维数组没关系，主要是思想

-   是否使用库函数memcpy
-   `malloc`临时数组给`res`赋指针，还是`malloc res`，直接赋值

```c
/* part 1:使用库函数memcpy / strcpy
	case 1:把res看成一维数组，每个数组中存放二维指针
		  因此需要malloc 二维指针（对于res而言），长度为n
		  在复制字符串时，二维指针就是存放字符串（字符指针模拟字符串）的一维数组
		  因此需要malloc n个字符串，每个字符串又是长度为 n+1的字符指针
*/
char ** tmp = malloc(sizeof(char*) * n);
for(int i = 0; i < n; i++){
    char* tmp1 = malloc(sizeof(char) * (n + 1));
    strcpy(tmp1, chessboard[i]);
    tmp[i] = tmp1;
}
res[*resSize] = tmp;

/*	case 2:把res看成二维数组，数组中的元素是字符串，用memcpy赋值
		   因此需要malloc n行，n+1列空间
*/
res[*resSize] = malloc(sizeof(char*) * n);
for(int i = 0; i < n; i++){
    res[*resSize][i] = malloc(sizeof(char) * (n + 1));
    memcpy(res[*resSize][i], chessboard[i], sizeof(char) * (n + 1));
}
```

>   问：`malloc tmp`时为什么不写成`memcpy(tmp, chessboard, sizeof(char) * (n + 1) * n)`
>
>   答：tmp是二维字符数组模拟一维字符串数组，但本质还是二维数组，每个元素是`char*`类型，如果不对每个元素`malloc`，就会出现内存问题。同时字符串有`'\0'`问题，直接memcpy二维数组存在内存问题。

$n$维数组需要`malloc` $n - 1$次

```c
/* part 2: 不使用 strcpy / memcpy
		case 1: 把res看成三维数组，每个数组中存放n行，n列的元素，每个元素又是长度为n+1的char型数据
*/
res[*resSize] = malloc(sizeof(char*) * n);
for(int i = 0; i < n; i++){
    res[*resSize][i] = malloc(sizeof(char) * (n + 1));
    memcpy(res[*resSize][i], chessboard[i], sizeof(char) * (n + 1));
    for(int j = 0; j < n + 1; j++)
        res[*resSize][i][j] = chessboard[i][j];
}
```

<font color='red'>小结</font>

>   如果从代码角度看，无非是用不用库函数，是否使用`malloc`过的中间变量收集结果，如果从返回值的角度思考，会发现用不同的方法实际上是对`res`不同角度的看法，而这种思考方式令不同方式的收集变得清晰起来

### <font color='BurlyWood'>两种去重方式</font>

>   在《【回溯算法】全排列 II》中总结过，现在贴过来

关于去重问题，有时候的用这种逻辑【逻辑一】去重：

```c
// candidates已排序
if(i > idx && candidates[i] == candidates[i - 1])	// 此处去重（由于数组有序）
        continue;
```

有时候去重的逻辑【逻辑二】又是这样的：

```c
if(used[nums[i] + 10] == 1)
            continue;
        used[nums[i] + 10] = 1;
```

所有问题在于什么时候用什么逻辑，我的理解是：

- 问题和单个元素的重复相关时，用【逻辑一】

    - 组合总和II
    - 子集 II
- 问题和多个元素的重复相关时，用【逻辑二】

    - 递增子序列
    - 全排列 II

再说清楚一点就是，<font color='red'>**处理的问题是单兵作战还是团伙作案**</font>。比如子集问题，就是一个一个取，递增序列则是需要考虑前一个元素。

## <font color='orange'>闲聊</font>

如果把这part跟下来，并且自己敲了，那自己总结个模版就是信手捏来：

```python
if isCollections:
    collections()
select()
```

如果在详细一点，就是：

```python 
def backtrace(*parameters, idx):
    if isCollections:
        res.append(path.copy())
	for i in range(idx):
        path.append(contents)
        backtrace(..., idx + 1)	# 也可能是i + 1, ...是省略号
        path.pop()
```

但是我的观点是不建议去找模版，看模版，背模版（这三件事哪一件都没必要）

模版会僵化你的思维，让你产生思维惰性，不愿意去思考回溯的过程。这个问题在我刷回溯算法问题的同类型题时就发现了（比如xxII，xxIII），这且是我不用模版的时候，如果用模版，我觉得这个过程会来得更早。

而这样的问题会带来什么结果：首先，如果是打比赛或是面试，没人告诉你这个题是回溯问题，你能判断清楚这个问题类型吗；其次，如果你第一步没问题，但是遇到的问题和之前的问题区别有点大，你能不通过模拟回溯的过程，而仅靠模版完成吗。

私以为人与人的差距在于效率，<font color='red'>在基础的知识都掌握的情况下，差距并不取决于见多少题，而重在吸收质量</font>。这句话适用于与学习相关的任何地方，考研数学也是一样，在智力相当的情况下，大家都刷880，但是为什么刷完之后的效果良莠不齐。