# <font color='cornflowerblue'>二叉树</font>

## <font color='orange'>二叉树的递归遍历</font>

### <font color='BurlyWood'>前序遍历</font>

>   力扣链接：https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/
>
>   题目描述：前序遍历并输出

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void traversal(struct TreeNode* root, int* res, int* resSize){
    if(root == NULL)    return;
    
    res[(*resSize)++] = root -> val;
    traversal(root -> left, res, resSize);
    traversal(root -> right, res, resSize);
}

int* preorderTraversal(struct TreeNode* root, int* returnSize){
    int* res = malloc(sizeof(int) * 100);
    *returnSize = 0;
    traversal(root, res, returnSize);
    return res;
}
```



### <font color='BurlyWood'>中序遍历</font>

>   力扣链接：https://leetcode.cn/problems/binary-tree-inorder-traversal/
>
>   题目描述：中序遍历并输出

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void traversal(struct TreeNode* root, int* res, int* resSize){
    if(root == NULL)    return NULL;
    traversal(root -> left, res, resSize);
    res[(*resSize)++] = root -> val;
    traversal(root -> right, res, resSize);
}

int* inorderTraversal(struct TreeNode* root, int* returnSize){
    int* res = malloc(sizeof(int) * 100);
    *returnSize = 0;
    traversal(root, res, returnSize);
    return res;
}
```



### <font color='BurlyWood'>后序遍历</font>

>   力扣链接：https://leetcode.cn/problems/binary-tree-postorder-traversal/submissions/
>
>   题目描述：后序遍历并输出

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void traversal(struct TreeNode* root, int* res, int* resSize){
    if(root == NULL)    return;
    traversal(root -> left, res, resSize);
    traversal(root -> right, res, resSize);
    res[(*resSize)++] = root -> val;
}

int* postorderTraversal(struct TreeNode* root, int* returnSize){
    int* res = malloc(sizeof(int) * 100);
    *returnSize = 0;
    traversal(root, res, returnSize);
    return res;
}
```



## <font color='orange'>二叉树的迭代遍历</font>

题目与昨天一样，本篇代码一定要手动模拟

### <font color='BurlyWood'>前序遍历</font>

>   力扣链接：https://leetcode.cn/problems/binary-tree-preorder-traversal/submissions/
>
>   题目描述：前序遍历并输出

-   思路：<font color='red'>用栈存数</font>

    >   入栈顺序为根左右，入一个，出一个

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* preorderTraversal(struct TreeNode* root, int* returnSize){
    int* res = malloc(sizeof(int) * 100);
    *returnSize = 0;
    struct TreeNode* stack[100];
    int top = 0;
    
    // 若栈和当前结点都为空，则跳出
    while(top > 0 || root != NULL){
        // 读根左
        while(root != NULL){
            res[(*returnSize)++] = root -> val;
            stack[top++] = root;
            root = root -> left;
        }
        // node为NULL，因此要跳到父节点
        root = stack[--top];
        // 向右遍历
        root = root -> right;
    }
    return res;
}
```

-   <font color='red'>解法：先序遍历迭代版</font>

```c
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     int numChildren;
 *     struct Node** children;
 * };
 */

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
// 利用栈
void order(struct Node* root, int* res, int* returnSize){
    if(root == NULL)
        return NULL;
    struct Node* stack[10000];
    int top = 0;
    stack[top++] = root;
    // 核心：每次本层各个元素倒序入栈，但只出第一个
    while(top != 0){
        struct Node* node = stack[--top];
        res[(*returnSize)++] = node -> val;
        for(int i = node -> numChildren - 1; i >= 0; i--)
            stack[top++] = node -> children[i];   
    }
}

int* preorder(struct Node* root, int* returnSize) {
    *returnSize = 0;
    int* res = malloc(sizeof(int) * 10000);
    order(root, res, returnSize);
    return res;
}
```

### <font color='BurlyWood'>中序遍历</font>

>   力扣链接：https://leetcode.cn/problems/binary-tree-inorder-traversal/
>
>   题目描述：中序遍历并输出

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* inorderTraversal(struct TreeNode* root, int* returnSize){
    int* res = malloc(sizeof(int) * 100);
    *returnSize = 0;    
    struct TreeNode* stack[100];
    int top = 0;
    
    while(top > 0 || root != NULL){
        // 存入根左
        while(root != NULL){
            stack[top++] = root;
            root = root -> left;
        }
        // 读左根
        root = stack[--top];
        res[(*returnSize)++] = root -> val;
        // 向右遍历
        root = root -> right;
    }
    return res;
}
```

### <font color='BurlyWood'>后序遍历</font>

>   力扣链接：https://leetcode.cn/problems/binary-tree-postorder-traversal/submissions/
>
>   题目描述：后序遍历并输出

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* postorderTraversal(struct TreeNode* root, int* returnSize){
    int* res = malloc(sizeof(int) * 100);
    *returnSize = 0;
    struct TreeNode* stack[100];
    struct TreeNode* prev = NULL;
    int top = 0;
    
    while(top > 0 || root != NULL){
        // 读根左
        while(root != NULL){
            stack[top++] = root;
            root = root -> left;
        }
        // 弹出栈顶
        root = stack[--top];
        /*若是叶子结点，必然是做叶子，优先输出，否则向右遍历*/
        // 若无右叶子结点，读两次栈
        if(root -> right == NULL || root -> right == prev){
            res[(*returnSize)++] = root -> val;
            prev = root;
            root = NULL;
        }
        // 若有右叶子结点，向右遍历
        else{
            stack[top++] = root;
            root = root -> right;
        }
    }
    return res;
}
```

## <font color='orange'>二叉树的层序遍历</font>

-   解法一：<font color='red'>迭代法</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
/* 关于本类题的参数：
	res是自己要申请的返回值
	returnSize 要返回行数，因此是整型指针
	returnColumnSizes 要返回（*returnSize）个列数，因此是一维数组的指针
*/

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    *returnSize = 0;
    if(root == NULL)    return NULL;
    int** res = (int**)malloc(sizeof(int*) * 2000);
    *returnColumnSizes = (int*)malloc(sizeof(int) * 2000);
    struct TreeNode* data[2001];
    int front = 0, rear = 0;
    struct TreeNode* cur;
    
    data[rear++] = root;
    while(front != rear){
        int colSize = 0;
        int last = rear;
        // 申请本层所需列数
        res[*returnSize] = (int*)malloc(sizeof(int) * (last - front));
        while(front < last){
            // 取出本层内容
            cur = data[front++];
            res[*returnSize][colSize++] = cur -> val;
            // 存入下一层内容
            if(cur -> left != NULL)
                data[rear++] = cur -> left;
            if(cur -> right != NULL)
                data[rear++] = cur -> right;
        }
        // 更新行数列数
        (*returnColumnSizes)[*returnSize] = colSize;
        (*returnSize)++;
    }
    return res;
}
```

-   解法二：<font color='red'>深度优先（DFS）</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
struct Queue{
    struct TreeNode* node;
    struct Queue* next;
};

// 插入到队尾
void enQueue(struct Queue * queueHead, struct TreeNode* node){
    struct Queue* queueIt = queueHead;
    while(queueIt -> next != NULL){
        queueIt = queueIt -> next;
    }
    struct Queue* queueNew = malloc(sizeof(struct Queue));
    queueNew -> node = node;
    queueNew -> next = NULL;
    queueIt -> next = queueNew;
}

// 从队头删除
struct TreeNode* deQueue(struct Queue* queueHead){
    struct Queue* queueIt = queueHead -> next;
    struct TreeNode* node;
    if(queueIt != NULL){
        queueHead -> next = queueIt -> next;
        node = queueIt -> node;
        free(queueIt);
        return node;
    }
    return NULL;
}

void freeQueue(struct Queue* queueHead){
    // 清理链表
    struct Queue* queueIt = queueHead -> next;
    struct Queue* queuePre = queueHead -> next;
    if(queueIt != NULL){
        queuePre = queueIt;
        queueIt = queueIt -> next;
        free(queuePre);
    }
    free(queueHead);
}

void bfs(int* returnSize, int** returnColumnSizes, int** res, struct Queue* queueHead){
    struct Queue* queueIt = queueHead -> next;
    if(queueIt -> node == NULL)
        return;
    int count = 0;
    res[*returnSize] = (int*)malloc(sizeof(int) * 2000);
    while(1){
        struct TreeNode* node = deQueue(queueHead);
        if(node == NULL)    break;
        // 读队列内容
        res[*returnSize][count++] = node -> val;
        
        // 下一层入队
        if(node -> left != NULL)
            enQueue(queueHead, node -> left);
        if(node -> right != NULL)
            enQueue(queueHead, node -> right);
    }
    enQueue(queueHead, NULL);
    (*returnColumnSizes)[*returnSize] = count;
    *returnSize = *returnSize + 1;
    bfs(returnSize, returnColumnSizes, res, queueHead);
}

int** levelOrder(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    *returnSize = 0;
    if(root == NULL)    return NULL;
    int** res = (int**)malloc(sizeof(int*) * 2000);
    *returnColumnSizes = (int*)malloc(sizeof(int) * 2000);
    struct Queue *queueHead = malloc(sizeof(struct Queue));
    queueHead -> next = NULL;
    queueHead -> node = NULL;
    enQueue(queueHead, root);
    enQueue(queueHead, NULL);
    
    bfs(returnSize, returnColumnSizes, res, queueHead);
    free(queueHead);
    return res;
}
```

明天题就来了

### <font color='BurlyWood'>题目I</font>

>   力扣链接：https://leetcode.cn/problems/binary-tree-level-order-traversal/
>
>   题目描述：层序遍历

本题的答案就是昨天那篇，因此略过。

### <font color='BurlyWood'>题目II</font>

>   力扣链接：https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/
>
>   题目描述：给你二叉树的根节点 `root` ，返回其节点值 **自底向上的层序遍历** 。 （即按从叶子节点所在层到根节点所在的层，逐层从左向右遍历）

-   解法：<font color='red'>层序遍历 + 二维数组的逆置</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
void leverOrder(struct TreeNode* root, int ** res, int* returnSize, int ** returnColumnSizes){
    struct TreeNode* queue[2000];
    int front = 0, rear = 0;
    struct TreeNode* cur;
    queue[rear++] = root;
    
    while(front < rear){
        int colSize = 0;
        int last = rear;
        res[*returnSize] = (int*)malloc(sizeof(int) * (last - front));
        // 处理本层
        while(front < last){
            cur = queue[front++];
            res[*returnSize][colSize++] = cur -> val;
            
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
        }
        (*returnColumnSizes)[*returnSize] = colSize;
        (*returnSize)++;
    }
}

int** levelOrderBottom(struct TreeNode* root, int* returnSize, int** returnColumnSizes){
    int ** res = (int*)malloc(sizeof(int*) * 2000);
    *returnSize = 0;
    *returnColumnSizes = (int*)malloc(sizeof(int) * 2000);
    if(root == NULL)    return NULL;
    // 层序遍历
    leverOrder(root, res, returnSize, returnColumnSizes);
    // 交换列数组指针
    for(int i = 0; i < (*returnSize) / 2; i++){
        (*returnColumnSizes)[i] ^= (*returnColumnSizes)[*returnSize - i - 1];
        (*returnColumnSizes)[*returnSize - i - 1] ^= (*returnColumnSizes)[i];
        (*returnColumnSizes)[i] ^= (*returnColumnSizes)[*returnSize - i - 1];
    }
    // 二维数组的逆置
    int ** ans = (int*)malloc(sizeof(int*) * (*returnSize));
    for(int i = 0; i < *returnSize; i++){
        ans[i] = (int*)malloc(sizeof(int) * (*returnColumnSizes)[i]);
    }
    
    for(int i = 0; i < (*returnSize); i++){
        for(int j = 0; j < (*returnColumnSizes)[i]; j++){
            int row = *returnSize - 1 - i;
            ans[i][j] = res[row][j];
        }
    }
    return ans;
}
```



### <font color='BurlyWood'>题目III</font>

>   力扣链接：https://leetcode.cn/problems/binary-tree-right-side-view/
>
>   题目描述：给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

-   解法：<font color='red'>层序遍历</font>

>   在每一层处理结束后再读cur结点

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* rightSideView(struct TreeNode* root, int* returnSize){
    *returnSize = 0;
    if(root == NULL)    return NULL;
    int * res = (int*)malloc(sizeof(int) * 100);
    struct TreeNode* queue[100];
    int front = 0, rear = 0;
    struct TreeNode* cur;
    queue[rear++] = root;
    
    while(rear != front){
        int last = rear;
        // 处理本层
        while(front < last){
            cur = queue[front++];
            
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
        }
        // 读cur
        res[(*returnSize)++] = cur -> val;
    }
    return res;
}
```



### <font color='BurlyWood'>题目IV</font>

>   力扣链接：https://leetcode.cn/problems/average-of-levels-in-binary-tree/
>
>   题目描述：给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。与实际答案相差 `10-5` 以内的答案可以被接受。

-   解法：<font color='red'>层序遍历</font>

>   把每层的数字暂存起来，每层处理结束后求出平均值

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
double average(double* arr, int len){
    double sum = 0;
    for(int i = 0; i < len; i++)
        sum += arr[i];
    return sum / len;
}

double* averageOfLevels(struct TreeNode* root, int* returnSize){
    *returnSize = 0;
    double* res = (double*)malloc(sizeof(double) * 10000);
    double tmp[10000];
    struct TreeNode* queue[10000];
    int front = 0, rear = 0;
    struct TreeNode* cur;

    queue[rear++] = root;
    while(rear != front){
        int len = 0;
        int last = rear;
        while(front < last){
            cur = queue[front++];
            // 暂存
            tmp[len++] = (double)cur -> val;
            
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
        }
        // 求平均值
        res[(*returnSize)++] = average(tmp, len);
    }
    return res;
}
```



### <font color='BurlyWood'>题目Ⅴ</font>

>   力扣链接：https://leetcode.cn/problems/n-ary-tree-level-order-traversal/
>
>   题目描述：给定一个 N 叉树，返回其节点值的*层序遍历*。（即从左到右，逐层遍历）。
>
>   树的序列化输入是用层序遍历，每组子节点都由 null 值分隔。

-   解法：<font color='red'>层序遍历</font>

```c
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     int numChildren;
 *     struct Node** children;
 * };
 */

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** levelOrder(struct Node* root, int* returnSize, int** returnColumnSizes) {
    int ** res = (int**)malloc(sizeof(int*) * 10000);
    *returnColumnSizes = (int*)malloc(sizeof(int) * 10000);
    *returnSize = 0;
    if(root == NULL)    return NULL;
    struct Node* queue[10000];
    int front = 0, rear = 0;
    
    queue[rear++] = root;
    while(rear != front){
        int colSize = 0;
        int last = rear;
        struct Node* cur;
        res[*returnSize] = (int*)malloc(sizeof(int) * (last - front));
        // 遍历本层
        while(front < last){
            cur = queue[front++];
            res[*returnSize][colSize++] = cur -> val;
            // 遍历cur的子节点
            for(int i = 0; i < cur -> numChildren; i++){
                if((cur -> children)[i] != NULL)
                    queue[rear++] = (cur -> children)[i];
            }
        }
        (*returnColumnSizes)[*returnSize] = colSize;
        (*returnSize)++;
    }
    return res;
}
```



### <font color='BurlyWood'>题目Ⅵ</font>

>   力扣链接：https://leetcode.cn/problems/find-largest-value-in-each-tree-row/
>
>   题目描述：给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。

-   解法：<font color='red'>层序遍历</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int max(int* arr, int len){
    int res = INT_MIN;
    for(int i = 0; i < len; i++){
        if(res < arr[i])
            res = arr[i];
    }
    return res;
}

int* largestValues(struct TreeNode* root, int* returnSize){
    int* res = (int*)malloc(sizeof(int) * 10000);
    int arr[1000];
    *returnSize = 0;
    if(root == NULL)    return NULL;
    struct TreeNode* queue[10000];
    int front = 0, rear = 0;
    
    queue[rear++] = root;
    while(rear != front){
        int last = rear;
        int len = 0;
        struct TreeNode* cur;
        while(front < last){
            cur = queue[front++];
            arr[len++] = cur -> val;
            
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
        }
        // 每层结束时求最小值
        res[(*returnSize)++] = max(arr, len);
    }
    return res;
}
```

### <font color='BurlyWood'>题目Ⅶ</font>

>   力扣链接：https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/
>
>   题目描述：给定一个 完美二叉树 ，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：
>
>   ```c
>   struct Node {
>     int val;
>     Node *left;
>     Node *right;
>     Node *next;
>   }
>   ```
>
>   填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL。
>
>   初始状态下，所有 next 指针都被设置为 NULL。

-   <font color='red'>解法：层序遍历+每层结束时处理</font>

```c
// 只要理解题意就不难
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     struct Node *left;
 *     struct Node *right;
 *     struct Node *next;
 * };
 */

struct Node* connect(struct Node* root) {
	struct Node* queue[0xfff];
    struct Node* tmp[0xfff];
    int rear = 0, front = 0;
    if(root == NULL)    return NULL;
    
    queue[rear++] = root;
    while(rear != front){
        int last = rear;
        int len = 0;
        struct Node* cur;
        while(front < last){
            cur = queue[front++];
            tmp[len++] = cur;
            
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
        }
        for(int i = 0; i < len - 1; i++){
            tmp[i] -> next = tmp[i + 1];
        }
        tmp[len - 1] -> next = NULL;
    }
    return root;
}
```

这题果然可以偷鸡，但是下面那个不行

-   <font color='red'>官解：具体问题具体分析</font>

```c
/* 分为亲兄弟的next和堂兄弟的next两种情况
	空间复杂复更低O(1)
*/
struct Node* connect(struct Node* root) {
    if (root == NULL) {
        return root;
    }

    // 从根节点开始
    struct Node* leftmost = root;

    while (leftmost->left != NULL) {
        // 遍历这一层节点组织成的链表，为下一层的节点更新 next 指针
        struct Node* head = leftmost;

        while (head != NULL) {
            // CONNECTION 1 - 亲兄弟
            head->left->next = head->right;

            // CONNECTION 2 - 堂兄弟
            if (head->next != NULL) {
                head->right->next = head->next->left;
            }

            // 指针向后移动
            head = head->next;
        }

        // 去下一层的最左的节点
        leftmost = leftmost->left;
    }

    return root;
}
```



### <font color='BurlyWood'>题目Ⅷ</font>

>   力扣链接：https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/
>
>   题目描述：给定一个二叉树：
>
>   ```c
>   struct Node {
>     int val;
>     Node *left;
>     Node *right;
>     Node *next;
>   }
>   ```
>
>   填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 NULL 。
>
>   初始状态下，所有 next 指针都被设置为 NULL 。

-   <font color='red'>解法： 同上</font>

```c
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     struct Node *left;
 *     struct Node *right;
 *     struct Node *next;
 * };
 */

struct Node* connect(struct Node* root) {
	struct Node* queue[6000];
    struct Node* tmp[6000];
    int rear = 0, front = 0;
    if(root == NULL)    return NULL;
    
    queue[rear++] = root;
    while(rear != front){
        int last = rear;
        int len = 0;
        struct Node* cur;
        while(front < last){
            cur = queue[front++];
            tmp[len++] = cur;
            
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
        }
        for(int i = 0; i < len - 1; i++){
            tmp[i] -> next = tmp[i + 1];
        }
        tmp[len - 1] -> next = NULL;
    }
    return root;
}
```



### <font color='BurlyWood'>题目Ⅸ</font>

>   力扣链接：https://leetcode.cn/problems/maximum-depth-of-binary-tree/
>
>   题目描述：给定一个二叉树，找出其最大深度。
>
>   二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
>   说明: 叶子节点是指没有子节点的节点。
>
>   示例：
>   给定二叉树 [3,9,20,null,null,15,7]，
>
>   ```c
>      3
>      / \
>     9  20
>       /  \
>      15   7
>   // 返回它的最大深度 3
>   ```

-   <font color='red'>解法：层序遍历+统计</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


int maxDepth(struct TreeNode* root){
    int res = 0;
    if(root == NULL)    return res;
    
    struct TreeNode* queue[0xffff];
    int front = 0, rear = 0;
    queue[rear++] = root;
    while(rear != front){
        int last = rear;
        struct TreeNode* cur;
        while(front < last){
            cur = queue[front++];
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur ->right;
        }
        res++;
    }
    return res;
}
```

### <font color='BurlyWood'>题目Ⅹ</font>

>   力扣链接：https://leetcode.cn/problems/minimum-depth-of-binary-tree/
>
>   题目描述：给定一个二叉树，找出其最小深度。
>
>   最小深度是从根节点到最近叶子节点的最短路径上的节点数量。
>
>   **说明：**叶子节点是指没有子节点的节点。

-   <font color='red'>解法：层序遍历+统计</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


int minDepth(struct TreeNode* root){
    int res = 0;
    if(root == NULL)    return 0;
    
    struct TreeNode* queue[0xffff];
    int rear = 0, front = 0;
    queue[rear++] = root;
    while(rear != front){
        int last = rear;
        struct TreeNode* cur;
        res++;
        while(front < last){
            cur = queue[front++];
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
            if(cur -> left == NULL && cur -> right == NULL)
                return res;
        }
    }
    return res;
}
```



## <font color='orange'>226. 翻转二叉树</font>

>   树这一章的题目描述不太好复制，推荐去力扣官网看，大家将就下~
>
>   刷题一定要动手，不要看会了就行！！

>   力扣链接：https://leetcode.cn/problems/invert-binary-tree/
>
>   题目描述：给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点。
>
>    ```c
>   // 示例 1：
>   输入：root = [4,2,7,1,3,6,9]
>   输出：[4,7,2,9,6,3,1]
>       
>   // 示例 2：
>   输入：root = [2,1,3]
>   输出：[2,3,1]
>    ```

-   <font color='red'>解法：层序遍历</font>

    >   如果一棵二叉树，每层的兄弟都换，就能达到翻转的效果。类似于数组的原地逆置
    >
    >   建议画几颗二叉树试试

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* invertTree(struct TreeNode* root){
    if(root == NULL)
        return NULL;
    struct TreeNode* queue[100];
    int front = 0, rear = 0;
    queue[rear++] = root;
    struct TreeNode* cur;
    struct TreeNode* tmp = NULL;
    while(rear != front){
        int last = rear;
        while(front < last){
            cur = queue[front++];
            // 下一层入队
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
		   // 交换
            tmp = cur -> left;
            cur -> left = cur -> right;
            cur -> right = tmp;
            
        }
    }
    return root;
}
```

## <font color='orange'>101. 对称二叉树</font>

>   力扣链接：https://leetcode.cn/problems/symmetric-tree/
>
>   题目描述：
>
>   给你一个二叉树的根节点 `root` ， 检查它是否轴对称。
>
>   ```c
>   // 示例1
>   输入：root = [1,2,2,3,4,4,3]
>   输出：true
>       
>   // 示例2
>   输入：root = [1,2,2,null,3,null,3]
>   输出：false
>   ```
>
>   提示：
>
>   -   树中节点数目在范围 `[1, 1000]` 内
>   -   `-100 <= Node.val <= 100`

-   <font color='red'>解法一：递归</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
bool compare(struct TreeNode* left, struct TreeNode* right){
    // 如果左右两边都是空
    if(left == NULL && right == NULL)
        return true;
    // 如果仅有一边是空
    if(left == NULL || right == NULL)
        return false;
    // 如果两边都不是空，而且两边值不一样
    if(left -> val != right -> val)
        return false;
    // 仅当两对都匹配时，才为真
    return compare(left -> left, right -> right) && compare(left -> right, right -> left);
        
}

bool isSymmetric(struct TreeNode* root){
    return compare(root -> left, root -> right);
}
```

-   <font color='red'>解法二：队列</font>

    >   有层序的思想在里面

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */   

bool isSymmetric(struct TreeNode* root){
    struct TreeNode *queue[1000];
    int front = 0, rear = 0;
    queue[rear++] = root -> left;
    queue[rear++] = root -> right;
  
    while(rear != front){
        // 一对一对出队
        struct TreeNode *leftNode = queue[front++];
        struct TreeNode *rightNode = queue[front++];
        // !leftNode <=> leftNode == NULL
        if(!leftNode && !rightNode)
            continue;
        // 递归不对称判断条件的整合
        if(!leftNode || !rightNode || (leftNode -> val != rightNode -> val))
            return false;
        // 一对一对入队
        queue[rear++] = leftNode -> left;
        queue[rear++] = rightNode -> right;
        queue[rear++] = leftNode -> right;
        queue[rear++] = rightNode -> left;
    }
    return true;
}
```

## <font color='orange'>222. 完全二叉树的节点个数</font>

>   力扣链接：https://leetcode.cn/problems/count-complete-tree-nodes/
>
>   题目描述：
>
>   给你一棵 完全二叉树 的根节点 root ，求出该树的节点个数。
>
>   完全二叉树 的定义如下：在完全二叉树中，除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2h 个节点。
>
>   ```c
>   // 示例 1：
>   输入：root = [1,2,3,4,5,6]
>   输出：6
>       
>   // 示例 2：
>   输入：root = []
>   输出：0
>   
>   // 示例 3：
>   输入：root = [1]
>   输出：1
>    
>   ```
>
>   提示：
>
>   -   树中节点的数目范围是[0, 5 * 104]
>   -   0 <= Node.val <= 5 * 104
>   -   题目数据保证输入的树是完全二叉树

-   <font color='red'>解法：层序遍历</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


int countNodes(struct TreeNode* root){
    if(root == NULL)
        return 0;
    struct TreeNode *queue[50000];
    struct TreeNode *cur;
    int front = 0, rear = 0;
    queue[rear++] = root;
    int res = 0;
    
    while(rear != front){
        int last = rear;
        while(front < last){
            // 出队一个，统计一次
            cur = queue[front++];
            res++;
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
        }
    }
    return res;
}
```

-   <font color='red'>解法：递归</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


int countNodes(struct TreeNode* root){
    if(root == NULL)
        return 0;
    // 每遍历一个结点，就加1，十分优雅
    return countNodes(root -> left) + countNodes(root -> right) + 1;    
}
```

## <font color='orange'>104. 二叉树的最大深度</font>

>    力扣链接：https://leetcode.cn/problems/maximum-depth-of-binary-tree/
>
>    题目描述：
>
>    给定一个二叉树，找出其最大深度。
>
>    二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
>
>    说明: 叶子节点是指没有子节点的节点。
>
>    ```c
>    示例：
>    给定二叉树 [3,9,20,null,null,15,7]，
>    
>             3
>            / \
>            9  20
>          /  \
>         15   7
>       返回它的最大深度 3 
>    ```
>
>    这个题当初在层序遍历里做过，不过这种题用层序遍历太浪费了，这里再提供一种递归解法，并为明天的题做准备

-   解法：递归

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


int maxDepth(struct TreeNode* root){
    if(root == NULL)
        return 0;
    // fmax() 求最大值的库函数
    return fmax(maxDepth(root -> left) , maxDepth(root -> right)) + 1;
}
```

## <font color='orange'>110. 平衡二叉树</font>

>   力扣链接：https://leetcode.cn/problems/balanced-binary-tree/
>
>   题目描述：
>
>   给定一个二叉树，判断它是否是高度平衡的二叉树。
>
>   本题中，一棵高度平衡二叉树定义为：
>
>   一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1 。
>
>    ```c
>   // 示例 1：
>   输入：root = [3,9,20,null,null,15,7]
>   输出：true
>       
>   // 示例 2：
>   输入：root = [1,2,2,3,3,null,null,4,4]
>   输出：false
>       
>   // 示例 3：
>   输入：root = []
>   输出：true
>    ```
>
>
>   提示：
>
>   树中的节点数在范围 [0, 5000] 内
>   $-10^4 <= Node.val <= 10^4$

-   <font color='red'>解法：自顶而下递归</font>

    >   递归的难度在于代码量少，而让你产生一种掌握的错觉

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// 求树高函数
int height(struct TreeNode* root){
    if(root == NULL)
        return 0;
    else
        return fmax(height(root -> left), height(root -> right)) + 1;
}
// 先判断root，再判断root -> left, root -> right
bool isBalanced(struct TreeNode* root){
    if(root == NULL)
        return true;
    else
        // 若结点满足BST定义 && 本结点的左子树满足 && 本结点的右子树满足，才算满足
        return abs(height(root -> left) - height(root -> right)) <= 1 &&
                  isBalanced(root -> left) && isBalanced(root -> right);
}
```

-   <font color='red'>解法：自底而上递归</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
int height(struct TreeNode *root){
    if(root == NULL)
        return 0;
    // 遍历到最左边的叶子结点
    int leftHeight = height(root -> left);
    // 到叶子结点后return 0，跳出递归最内层
    int rightHeight = height(root -> right);
    // 判断第一个叶子结点
    if(leftHeight == -1 || rightHeight == -1 || abs(leftHeight - rightHeight) > 1)
        return -1;
    // 第一个叶子结点必然满足，然后跳到第15行
    else
        return fmax(leftHeight, rightHeight) + 1;
    // 把栈中的结点往外弹，如果不满足，则之后的判断必满足17行
}

bool isBalanced(struct TreeNode* root){
    return height(root) >= 0;
}
```

## <font color='orange'>257. 二叉树的所有路径</font>

>    力扣链接：https://leetcode.cn/problems/binary-tree-paths/
>
>   题目描述：
>
>   给你一个二叉树的根节点 root ，按 任意顺序 ，返回所有从根节点到叶子节点的路径。
>
>   叶子节点 是指没有子节点的节点。
>
>   ```c
>   // 示例 1：
>   输入：root = [1,2,3,null,5]
>   输出：["1->2->5","1->3"]
>       
>   // 示例 2：
>   输入：root = [1]
>   输出：["1"]
>   ```
>
>
>   提示：
>
>   树中节点的数目在范围 [1, 100] 内
>   -100 <= Node.val <= 100

-   <font color='red'>解法：深度优先</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void construct_paths(struct TreeNode* root, char** paths, int* returnSize, int* stack, int top){
    // 为空跳出
    if(root == NULL) return;
    // 若是叶子
    if(root -> left == NULL && root -> right == NULL){
        char* tmp = (char*)malloc(1001);
        int len = 0;
        // 若栈不是空
        for(int i = 0; i < top; i++)
            // 从栈底开始读（咋感觉像队列呢
            len += sprintf(tmp + len, "%d->", stack[i]);
        sprintf(tmp + len, "%d", root -> val);
        paths[(*returnSize)++] = tmp;
    }
    // 若不是叶子
    else{
        // 先序遍历入栈
        stack[top++] = root -> val;
        construct_paths(root -> left, paths, returnSize, stack, top);
        construct_paths(root -> right, paths, returnSize, stack, top);
    }
}
// 返回存字符指针的数组 <=> 返回字符串数组
char ** binaryTreePaths(struct TreeNode* root, int* returnSize){
    char** paths = (char**)malloc(sizeof(char*) * 1001);
    *returnSize = 0;
    int stack[1001];
    construct_paths(root, paths, returnSize, stack, 0);
    return paths;
}
```

注意：c是没有字符串的，上面的说法是为了便于理解。

-   <font color='red'>解法：广度优先</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
// 层序遍历
char ** binaryTreePaths(struct TreeNode* root, int* returnSize){
    char** paths = (char**)malloc(sizeof(char*) * 1001);
    *returnSize = 0;
    if(root == NULL)
        return NULL;
    struct TreeNode* queue[1001];
    // 由于返回的最小元素都是字符串，因此需要队列暂存
    char* path_queue[1001];
    char* tmp = (char*)malloc(sizeof(char) * 1001);
    sprintf(tmp, "%d", root -> val);
    int front = 0, rear = 0;
    queue[rear] = root;
    path_queue[rear++] = tmp;
    // 层序遍历
    while(rear != front){
        struct TreeNode *cur = queue[front];
        char *path = path_queue[front++];
        // 到叶子结点，为paths赋值
        if(cur -> left == NULL && cur -> right == NULL)
            paths[(*returnSize)++] = path;
        else{
            int n = strlen(path);
            if(cur -> left != NULL){
                char *tmp = malloc(sizeof(char) * 1001);
                for(int i = 0; i < n; i++)
                    tmp[i] = path[i];
                sprintf(tmp + n, "->%d", cur -> left -> val);
                queue[rear] = cur -> left;
                path_queue[rear++] = tmp;
            }
            if(cur -> right != NULL){
                char* tmp = (char*)malloc(sizeof(char) * 1001);
                for(int i = 0; i < n; i++)
                    tmp[i] = path[i];
                sprintf(tmp + n, "->%d", cur -> right -> val);
                queue[rear] = cur -> right;
                path_queue[rear++] = tmp;
            }
        }
    }
    return paths;
}
```

## <font color='orange'>404. 左叶子之和</font>

>   力扣链接：https://leetcode.cn/problems/sum-of-left-leaves/
>
>   题目描述：
>
>   给定二叉树的根节点 root ，返回所有左叶子之和。
>
>    ```c
>   // 示例 1：
>   输入: root = [3,9,20,null,null,15,7] 
>   输出: 24 
>   解释: 在这个二叉树中，有两个左叶子，分别是 9 和 15，所以返回 24
>       
>   // 示例 2:
>   输入: root = [1]
>   输出: 0
>    ```
>
>
>   提示:
>
>   节点数在 [1, 1000] 范围内
>   -1000 <= Node.val <= 1000

-   <font color='red'>解法：递归</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
int countLeaves(struct TreeNode *root){
    int count = 0;
    if(root == NULL)
        return count;
    // 若是左叶子结点
    if(root -> left != NULL && root -> left -> left == NULL && root -> left -> right == NULL)
        count += root -> left -> val;
    // 处理左边
    if(root -> left != NULL)
        count += countLeaves(root -> left);
    // 处理右边
    if(root -> right != NULL)
        count += countLeaves(root -> right);
    return count;
}


int sumOfLeftLeaves(struct TreeNode* root){
    return countLeaves(root);
}
```

```c
// 精简版
int countLeaves(struct TreeNode *root){
    int count = 0;
    if(root == NULL)
        return count;
    if(root -> left != NULL && root -> left -> left == NULL && root -> left -> right == NULL)
        count += root -> left -> val;
    
    return count + countLeaves(root -> left) + countLeaves(root -> right);
}
int sumOfLeftLeaves(struct TreeNode* root){
    return countLeaves(root);
}
```

-   <font color='red'>解法：广度优先</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// BDS yysd
int sumOfLeftLeaves(struct TreeNode* root){
    int count = 0;
    if(root == NULL)
        return count;
    
    struct TreeNode *cur;
    struct TreeNode* queue[10001];
    int front = 0, rear = 0;
    queue[rear++] = root;
    while(rear != front){
        int last = rear;
        while(front < last){
            cur = queue[front++];
            
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
            
            if(cur -> left != NULL && cur -> left -> left == NULL
              && cur -> left -> right == NULL)
                count += cur -> left -> val;
        }
    }
    return count;
}
```

## <font color='orange'>513. 找树左下角的值</font>

>   力扣链接：https://leetcode.cn/problems/find-bottom-left-tree-value/
>
>   题目描述：
>
>   给定一个二叉树的 根节点 root，请找出该二叉树的 最底层 最左边 节点的值。
>
>   假设二叉树中至少有一个节点。
>
>    ```c
>   // 示例 1:
>   输入: root = [2,1,3]
>   输出: 1
>       
>   // 示例 2:
>   输入: [1,2,3,4,null,5,6,null,null,7]
>   输出: 7
>    ```
>
>
>   提示:
>
>   -   二叉树的节点个数的范围是 [1,104]
>   -   $-2^{31} <= Node.val <= 2^{31} - 1$

-   <font color='red'>解法：广度优先</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
int findBottomLeftValue(struct TreeNode* root){
    if(root == NULL)
        return 0;
    struct TreeNode* queue[10001];
    struct TreeNode *cur;
    int front = 0, rear = 0;
    queue[rear++] = root;
    while(front != rear){
        int last = rear;
        int tmp = front;
        // 遍历本层
        while(tmp < last){
            cur = queue[tmp++];
            // 如果本层不全为叶子结点，跳过
            if(cur -> left != NULL || cur -> right != NULL){
                tmp = -1;
                break;
            }
        }
        if(tmp != -1)
            return queue[front] -> val;
        while(front < last){
            cur = queue[front++];
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
        }
        
    }
    return 0;
}
```

```c
// 精简一下
int findBottomLeftValue(struct TreeNode* root){
    int res = 0;
    if(root == NULL)
        return 0;
    struct TreeNode* queue[10001];
    struct TreeNode *cur;
    int front = 0, rear = 0;
    queue[rear++] = root;
    while(front != rear){
        int last = rear;
        int tmp = front;
        
        while(front < last){
            // 仅取队列第一个元素，直至遍历结束
            if(tmp == front)
                res = queue[front] -> val;
            cur = queue[front++];
            if(cur -> left != NULL)
                queue[rear++] = cur -> left;
            if(cur -> right != NULL)
                queue[rear++] = cur -> right;
        }
        
    }
    return res;
}
```

-   <font color='red'>解法：深度优先</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// 先序遍历
void dfs(const struct TreeNode *root, int height, int *curVal, int *curHeight){
    if(root == NULL)
        return;
    height++;
    dfs(root -> left, height, curVal, curHeight);
    dfs(root -> right, height, curVal, curHeight);
    // 此处curHeight只会在遍历到更深的地方首次更新，因而必是最深的第一个
    if(height > *curHeight){
        *curHeight = height;
        *curVal = root -> val;
    }
}

int findBottomLeftValue(struct TreeNode* root){
    int curVal, curHeight = 0;
    dfs(root, 0, &curVal, &curHeight);
    return curVal;
}
```

需要注意，本题中的左下是指最后一层的第一个，如：

```c
			1
		   /  \
          2		3
         /	   /
        4     5
               \
                 6
// 应返回6而不是4
```

## <font color='orange'>112. 路径总和</font>

>   力扣链接：https://leetcode.cn/problems/path-sum/
>
>   题目描述：
>
>   给你二叉树的根节点 root 和一个表示目标和的整数 targetSum 。判断该树中是否存在 根节点到叶子节点 的路径，这条路径上所有节点值相加等于目标和 targetSum 。如果存在，返回 true ；否则，返回 false 。
>
>   叶子节点 是指没有子节点的节点。
>
>    ```c
>   // 示例 1：
>   输入：root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22
>   输出：true
>   解释：等于目标和的根节点到叶节点路径如上图所示。
>       
>   // 示例 2：
>   输入：root = [1,2,3], targetSum = 5
>   输出：false
>   解释：树中存在两条根节点到叶子节点的路径：
>   (1 --> 2): 和为 3
>   (1 --> 3): 和为 4
>   不存在 sum = 5 的根节点到叶子节点的路径。
>       
>   // 示例 3：
>   输入：root = [], targetSum = 0
>   输出：false
>   解释：由于树是空的，所以不存在根节点到叶子节点的路径。
>    ```
>
>
>   提示：
>
>   -   树中节点的数目在范围 [0, 5000] 内
>   -   -1000 <= Node.val <= 1000
>   -   -1000 <= targetSum <= 1000

-   <font color='red'>解法：深度优先-递归</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
bool dfs(struct TreeNode *root, int val){
    // 若是叶子结点
    if(root != NULL && root -> left == NULL && root -> right == NULL){
        if(val == 0)
            return true;
        else
            return false;
    }
    // 左子树
    if(root -> left != NULL)
        if(dfs(root -> left, val - root -> left -> val))
            return true;
    // 右子树
    if(root -> right != NULL)
        if(dfs(root -> right, val - root -> right -> val))
            return true;
    
    return false;
}

bool hasPathSum(struct TreeNode* root, int targetSum){
    if(root == NULL)
        return false;
    // 每次递归用 总和 - 当前的值 （很妙）
    return dfs(root, targetSum - root -> val);
}
```

-   <font color='red'>解法：深度优先-迭代</font> 

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// 每个结点到根的sum需要一个结构体保存
struct Pair{
    struct TreeNode *node;
    int sum;
};

bool hasPathSum(struct TreeNode* root, int targetSum){
    struct Pair stack[1000];
    int stackTop = 0;
    
    if(root != NULL){
        struct Pair newPair = {root, root -> val};
        stack[stackTop++] = newPair;
    }
    // 先序遍历
    while(stackTop != 0){
        struct Pair topPair = stack[--stackTop];
        if(topPair.node -> left == NULL && topPair.node -> right == NULL 
           && topPair.sum == targetSum)
            return true;
        
        if(topPair.node -> left != NULL){
            struct Pair newPair = {topPair.node -> left, 
                                   topPair.sum + topPair.node -> left -> val};
            stack[stackTop++] = newPair;
        }
        if(topPair.node -> right != NULL){
            struct Pair newPair = {topPair.node -> right, 
                                  topPair.sum + topPair.node -> right -> val};
            stack[stackTop++] = newPair;
        }
    }
    return false;
}
```

## <font color='orange'>106. 从中序与后序遍历序列构造二叉树</font>

>   力扣链接：https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/
>
>   题目描述：
>
>   给定两个整数数组 inorder 和 postorder ，其中 inorder 是二叉树的中序遍历， postorder 是同一棵树的后序遍历，请你构造并返回这颗 二叉树 。
>
>   ```c
>   // 示例 1:
>   输入：inorder = [9,3,15,20,7], postorder = [9,15,7,20,3]
>   输出：[3,9,20,null,null,15,7]
>       
>   // 示例 2:
>   输入：inorder = [-1], postorder = [-1]
>   输出：[-1]
>   ```
>
>
>   提示:
>
>   -   1 <= inorder.length <= 3000
>   -   postorder.length == inorder.length
>   -   -3000 <= inorder[i], postorder[i] <= 3000
>   -   inorder 和 postorder 都由 不同 的值组成
>   -   postorder 中每一个值都在 inorder 中
>   -   inorder 保证是树的中序遍历
>   -   postorder 保证是树的后序遍历

-   <font color='red'>解法：递归</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
typedef struct{
    int key;
    int val;
    UT_hash_handle hh;
}hashTable;
int post_id;
hashTable *id_map;

void insertHashTable(int x, int y){
    hashTable *cur = (hashTable*)malloc(sizeof(hashTable));
    cur -> key = x;
    // 作为唯一标识/索引
    cur -> val = y;
    HASH_ADD_INT(id_map, key, cur);
}

int queryHashTable(int x){
    hashTable *cur;
    HASH_FIND_INT(id_map, &x, cur);
    return cur -> val;
}

// 后序遍历倒着输出，就是根右左
// 中序遍历（存在hash中）限定左右子树的范围
struct TreeNode* helper(int left, int right, int* postorder){
    if(left > right)
        return NULL;
    // 为根赋值
    int val = postorder[post_id];
    struct TreeNode *root = malloc(sizeof(struct TreeNode));
    root -> val = val;
    // 查根的索引
    int index = queryHashTable(val);
    
    // 控制后序遍历倒着输出
    post_id--;
    // 根的右子树是后序遍历的前一个【逐层向下】
    root -> right = helper(index + 1, right, postorder);
    // 上一句满足left > right，说明到左子树【逐层向上】
    root -> left = helper(left, index - 1, postorder);
    return root;
}

struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){
    post_id = postorderSize - 1;
    
    id_map = NULL;
    int id = 0;
    // 按中序遍历存入hash
    for(int i = 0; i < inorderSize; i++)
        insertHashTable(inorder[i], id++);
    
    return helper(0, inorderSize - 1, postorder);
}
```

搞清楚基本逻辑，就可以写一个数组模拟hash的代码：

```c
int post_id;

int queryHashTable(const int* hash, int val, int len){
    for(int i = 0; i <= len; i++)
        if(val == hash[i])
            return i;
    return -1;
}

struct TreeNode* helper(int left, int right, int* postorder, const int* hash){
    if(left > right)
        return NULL;
    
    int val = postorder[post_id];
    struct TreeNode *root = malloc(sizeof(struct TreeNode));
    root -> val = val;
    
    int index = queryHashTable(hash, val, right);
    
    post_id--;
    root -> right = helper(index + 1, right, postorder, hash);
    root -> left = helper(left, index - 1, postorder, hash);
    return root;
}

struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){
    post_id = postorderSize - 1;
    int hash[inorderSize];
    int id = 0;
    for(int i = 0; i < inorderSize; i++)
        hash[i] = inorder[i];
    
    return helper(0, inorderSize - 1, postorder, hash);
}
```

-   <font color='red'>解法：栈+迭代</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* createTreeNode(int val){
    struct TreeNode* ret = malloc(sizeof(struct TreeNode));
    ret -> val = val;
    ret -> left = NULL;
    ret -> right = NULL;
    return ret;
}

struct TreeNode* buildTree(int* inorder, int inorderSize, int* postorder, int postorderSize){
    if(postorderSize == 0)
        return NULL;
    // 根的值为后序遍历的最后一个数
    struct TreeNode* root = createTreeNode(postorder[postorderSize - 1]);
    struct TreeNode** s = malloc(sizeof(struct TreeNode*) * 10001);
    int top = 0;
    s[top++] = root;
    int inorderIndex = inorderSize - 1;
    for(int i = postorderSize - 2; i >= 0; i--){
        int val = postorder[i];
        struct TreeNode *node = s[top - 1];
        // 左子树入一个取一个（inorder比post慢一步）
        if(node -> val != inorder[inorderIndex]){
            node -> right = createTreeNode(val);
            s[top++] = node -> right;
        }
        // 右子树入完再取
        else{
            // 模拟递归的逐层向上【找到左子树的根】
            while(top > 0 && s[top - 1] -> val == inorder[inorderIndex]){
                node = s[--top];
                inorderIndex--;
            }
            node -> left = createTreeNode(val);
            s[top++] = node -> left;
        }
    }
    return root;
}
```

#### <font color='red'>总结：后序遍历倒序输出，中序遍历限定子树范围；右子树自顶而下建立，左子树自底而上建立</font>

## <font color='orange'>654. 最大二叉树</font>

>   力扣链接：https://leetcode.cn/problems/maximum-binary-tree/
>
>   题目描述：
>
>   给定一个不重复的整数数组 nums 。 最大二叉树 可以用下面的算法从 nums 递归地构建:
>
>   创建一个根节点，其值为 nums 中的最大值。
>   递归地在最大值 左边 的 子数组前缀上 构建左子树。
>   递归地在最大值 右边 的 子数组后缀上 构建右子树。
>   返回 nums 构建的 最大二叉树 。
>
>    ```c
>   // 示例 1：
>   输入：nums = [3,2,1,6,0,5]
>   输出：[6,3,5,null,2,0,null,null,1]
>   /*
>   解释：递归调用如下所示：
>   - [3,2,1,6,0,5] 中的最大值是 6 ，左边部分是 [3,2,1] ，右边部分是 [0,5] 。
>       - [3,2,1] 中的最大值是 3 ，左边部分是 [] ，右边部分是 [2,1] 。
>           - 空数组，无子节点。
>           - [2,1] 中的最大值是 2 ，左边部分是 [] ，右边部分是 [1] 。
>               - 空数组，无子节点。
>               - 只有一个元素，所以子节点是一个值为 1 的节点。
>       - [0,5] 中的最大值是 5 ，左边部分是 [0] ，右边部分是 [] 。
>           - 只有一个元素，所以子节点是一个值为 0 的节点。
>           - 空数组，无子节点。
>   */
>       
>   // 示例 2：
>   输入：nums = [3,2,1]
>   输出：[3,null,2,null,1]
>   ```
>
>
>   提示：
>
>   -   1 <= nums.length <= 1000
>   -   0 <= nums[i] <= 1000
>   -   nums 中的所有整数 互不相同

-   <font color='red'>解法：深度优先+递归</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

struct TreeNode* construct(int* nums, int left, int right){
    if(left > right)
        return NULL;
    int max = right;
    // 找出最大值
    for(int i = left; i < right; i++){
        if(nums[max] < nums[i])
            max = i;
    }
    // 先序递归逻辑
    struct TreeNode* root = malloc(sizeof(struct TreeNode));
    root -> val = nums[max];
    root -> left = construct(nums, left, max - 1);
    root -> right = construct(nums, max + 1, right);
    return root;
}

struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize){
    return construct(nums, 0, numsSize - 1);
}
```

-   <font color='red'>解法：深度优先+单调栈</font>

>   以 [3,2,1,6,0,5] 为例：
>
>   -   构造节点 3，入栈；
>   -   构造节点 2，它比栈顶元素 3 小，所以，它是 3 的右子节点，直接入栈；
>   -   构造节点 1，它比栈顶元素 2 小，所以，它是 2 的右子节点，直接入栈；
>   -   构造节点 6，它比栈顶元素 1 大，所以，1 是它的左子节点，弹出 1；同样地，栈顶元素 2 也比它小，弹出 2 并做为它的左子节点；把栈顶所有比它小的元素都弹出，最后弹出的是 3，所以，最终是 3 做为 6 的左子节点，并把 6 入栈；
>   -   构造节点 0，它比栈顶元素 6 小，所以，它是 6 的右子节点，直接入栈；
>   -   构造节点 5，它比栈顶元素 0 大，所以，0 是它的左子节点，弹出 0；接着比较，它比栈顶元素 6 小，所以，它是 6 的右子节点，入栈；
>   -   最后，栈中元素为 [6,5]，栈底元素为 6，是最终的根节点；
>
>   作者：tong-zhu
>   链接：https://leetcode.cn/problems/maximum-binary-tree/solution/by-tong-zhu-btly/

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// 单调栈元素单调递减
struct TreeNode* constructMaximumBinaryTree(int* nums, int numsSize){
    struct TreeNode* stack[numsSize];
    int index = 0;
    for(int i = 0; i < numsSize; i++){
        struct TreeNode *node = malloc(sizeof(struct TreeNode));
        node -> left = NULL;
        node -> right = NULL;
        node -> val = nums[i];
        // 当前元素的左子树是单调栈的大于本元素的后一个结点 / 栈中第一个（栈中元素全都比他小）
        while(index != 0 && nums[i] > stack[index - 1] -> val)
            node -> left = stack[--index];
        // 若当前元素小于栈顶元素，则当前元素为栈顶元素的右子树
        if(index != 0)
            stack[index - 1] -> right = node;
        stack[index++] = node;
    }
    // 由于单调栈中的第一个元素必然是nums中最大的，因此为根节点
    return stack[0];
}
```

### <font color='BurlyWood'>单调栈的使用场景</font>

1.  最近小或者最近大问题：直接单调栈【本题就是这种情况】
2.  最远小或者最远大问题：排序后优先队列（不需要单调栈，因为问题相似就拎出来了）
3.  最大小于或者最小大于问题：排序后单调栈

## <font color='orange'>657合并二叉树</font>

>   力扣链接：https://leetcode.cn/problems/merge-two-binary-trees/
>
>   题目描述：
>
>   给你两棵二叉树： root1 和 root2 。
>
>   想象一下，当你将其中一棵覆盖到另一棵之上时，两棵树上的一些节点将会重叠（而另一些不会）。你需要将这两棵树合并成一棵新二叉树。合并的规则是：如果两个节点重叠，那么将这两个节点的值相加作为合并后节点的新值；否则，不为 null 的节点将直接作为新二叉树的节点。
>
>   返回合并后的二叉树。
>
>   注意: 合并过程必须从两个树的根节点开始。
>
>   ```c
>   // 示例 1：
>   输入：root1 = [1,3,2,5], root2 = [2,1,3,null,4,null,7]
>   输出：[3,4,5,5,4,null,7]
>   
>   // 示例 2：
>   输入：root1 = [1], root2 = [1,2]
>   输出：[2,2]
>   ```
>
>
>   提示：
>
>   -   两棵树中的节点数目在范围 [0, 2000] 内
>   -   -104 <= Node.val <= 104

-   <font color='red'>解法：递归</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){
    if(root1 == NULL)
        return root2;
    if(root2 == NULL)
        return root1;
    struct TreeNode* root = malloc(sizeof(struct TreeNode));
    root -> val = root1 -> val + root2 -> val;
    root -> left = mergeTrees(root1 -> left, root2 -> left);
    root -> right = mergeTrees(root1 -> right, root2 -> right);
    return root;
}
```

注意，有人可能会这样写：

````c
struct TreeNode* mergeTrees(struct TreeNode* root1, struct TreeNode* root2){
    if(root1 == NULL && root2 == NULL)
        return NULL;
    struct TreeNode* root = malloc(sizeof(struct TreeNode));
    if(root1 != NULL)
        root -> val = root1 -> val;
    if(root2 != NULL)
        root -> val += root2 -> val;  
    // 若是root1或root2有一个是空，则访问空指针的left和right就会报错，望周知
    root -> left = mergeTrees(root1 -> left, root2 -> left);
    root -> right = mergeTrees(root1 -> right, root2 -> right);
    return root;
}
// 我第一次就是这样写的orz
````

-   <font color='red'>解法：层序遍历</font>

```css
 https://leetcode.cn/problems/merge-two-binary-trees/solution/he-bing-er-cha-shu-by-leetcode-solution/
```

这个层序遍历太掉san了，orz；

## <font color='orange'>700.二叉搜索树中的搜索</font>

>   力扣链接：https://leetcode.cn/problems/search-in-a-binary-search-tree/
>
>   题目描述：
>
>   给定二叉搜索树（BST）的根节点 root 和一个整数值 val。
>
>   你需要在 BST 中找到节点值等于 val 的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 null 。
>
>   ```c
>   // 示例 1:
>   输入：root = [4,2,7,1,3], val = 2
>   输出：[2,1,3]
>   
>   // 示例 2:
>   输入：root = [4,2,7,1,3], val = 5
>   输出：[]
>   ```
>
>
>   提示：
>
>   -   数中节点数在 [1, 5000] 范围内
>   -   1 <= Node.val <= 107
>   -   root 是二叉搜索树
>   -   1 <= val <= 107

-   <font color='red'>解法：递归</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* searchBST(struct TreeNode* root, int val){
    if(root == NULL)
        return NULL;
    if(root -> val == val)
        return root;
    /*
    if(root -> val > val)
        return searchBST(root -> left, val);
    else
        return searchBST(root -> right, val);
        */
    return (root -> val > val) ? searchBST(root -> left, val)
        : searchBST(root -> right, val);
}
```

-   <font color='red'>解法：迭代</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* searchBST(struct TreeNode* root, int val){
    if(root == NULL)
        return NULL;
    struct TreeNode *cur = root;
    while(cur != NULL){
        if(cur -> val == val)
            break;
        if(cur -> val > val)
            cur = cur -> left;
        else
            cur = cur -> right;
    }
    return cur;
}
```

## <font color='orange'>98. 验证二叉搜索树</font>

>   力扣链接：https://leetcode.cn/problems/validate-binary-search-tree/
>
>   题目描述：
>
>   给你一个二叉树的根节点 root ，判断其是否是一个有效的二叉搜索树。
>
>   有效 二叉搜索树定义如下：
>
>   节点的左子树只包含 小于 当前节点的数。
>   节点的右子树只包含 大于 当前节点的数。
>   所有左子树和右子树自身必须也是二叉搜索树。
>
>   ```c
>   // 示例 1：
>   输入：root = [2,1,3]
>   输出：true
>       
>   // 示例 2：
>   输入：root = [5,1,4,null,null,3,6]
>   输出：false
>   解释：根节点的值是 5 ，但是右子节点的值是 4 。
>   ```
>
>
>   提示：
>
>   -   树中节点数目范围在[1, 10^4] 内
>   -   -2^31 <= Node.val <= 2^31 - 1

-   <font color='red'>解法：中序遍历递归版</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// 本题一定要记录父节点的值
bool valid(struct TreeNode* root, long min, long max){
    if(root == NULL)
        return true;

    if(root -> val <= min || root -> val >= max)
        return false;
    
    return valid(root -> left, min, root -> val) 
        && valid(root -> right, root -> val, max);
}

bool isValidBST(struct TreeNode* root){
    return valid(root, LONG_MIN, LONG_MAX);
}
```

-   <font color='red'>解法：中序遍历迭代版</font>

```c
// 中序遍历循序：左根右
bool isValidBST(struct TreeNode* root){
    if(root == NULL)
        return true;
    struct TreeNode* stack[5000];
    int top = 0;
    long inorder = LONG_MIN;
    while(top > 0 || root != NULL){
        while(root != NULL){
            stack[top++] = root;
            root = root -> left;
        }
        // 一层一层向外弹
        root = stack[--top];
        // 只需满足：左<根<右即可。或是上一个>当前值，否则return false
        if(root -> val <= inorder)
            return false;
        inorder = root -> val;
        root = root -> right;
    }
    return true;
}
```

## <font color='orange'>530. 二叉搜索树的最小绝对差</font>

>   力扣链接：https://leetcode.cn/problems/minimum-absolute-difference-in-bst/
>
>   题目描述：
>
>   给你一个二叉搜索树的根节点 root ，返回 树中任意两不同节点值之间的最小差值 。
>
>   差值是一个正数，其数值等于两值之差的绝对值。
>
>    ```c
>   // 示例 1：
>   输入：root = [4,2,6,1,3]
>   输出：1
>       
>   // 示例 2：
>   输入：root = [1,0,48,null,null,12,49]
>   输出：1
>    ```
>
>
>   提示：
>
>   -   树中节点的数目范围是 [2, 10^4]
>   -   0 <= Node.val <= 10^5

-   <font color='red'>解法：中序遍历递归版</font>

    >   对BST中序遍历 => 升序数组
    >
    >   答案必然是升序数组中相邻两数差的min

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

void inorder(struct TreeNode* root, int* res, int* len){
    if(root == NULL)
        return NULL;
    
    inorder(root -> left, res, len);
    res[(*len)++] = root -> val;
    inorder(root -> right, res, len);
}


int getMinimumDifference(struct TreeNode* root){
    int len = 0;
    int* arr = (int*)malloc(sizeof(int) * 10000);
    inorder(root, arr, &len);
    int min = arr[1] - arr[0];
    for(int i = 1; i < len - 1; i++){
        int tmp = arr[i + 1] - arr[i];
        if(min > tmp)
            min = tmp;
    }
    return min;
}
```

-   <font color='red'>解法：中序遍历迭代版</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */

void inorder(struct TreeNode* root, int* res, int* len){
    struct TreeNode* stack[10000];
    int top = 0;
    while(top > 0 || root != NULL){
        while(root != NULL){
            stack[top++] = root;
            root = root -> left;
        }
        root = stack[--top];
        res[(*len)++] = root -> val;
        root = root -> right;
    }
    return 0;
}


int getMinimumDifference(struct TreeNode* root){
    int len = 0;
    int* arr = (int*)malloc(sizeof(int) * 10000);
    inorder(root, arr, &len);
    int min = arr[1] - arr[0];
    for(int i = 1; i < len - 1; i++){
        int tmp = arr[i + 1] - arr[i];
        if(min > tmp)
            min = tmp;
    }
    return min;
}
```

## <font color='orange'>501. 二叉搜索树中的众数</font>

>   力扣链接：https://leetcode.cn/problems/find-mode-in-binary-search-tree/
>
>   题目描述：
>
>   给你一个含重复值的二叉搜索树（BST）的根节点 root ，找出并返回 BST 中的所有 众数（即，出现频率最高的元素）。
>
>   如果树中有不止一个众数，可以按 任意顺序 返回。
>
>   假定 BST 满足如下定义：
>
>   结点左子树中所含节点的值 小于等于 当前节点的值
>   结点右子树中所含节点的值 大于等于 当前节点的值
>   左子树和右子树都是二叉搜索树
>
>   ```c
>   // 示例 1：
>   输入：root = [1,null,2,2]
>   输出：[2]
>       
>   // 示例 2：
>   输入：root = [0]
>   输出：[0]
>   ```
>
>
>   提示：
>
>   -   树中节点的数目在范围 [1, 10^4] 内
>   -   -10^5 <= Node.val <= 10^5

-   <font color='red'>解法：中序遍历递归版</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void inorder(struct TreeNode* root, int* nums, int* len){
    if(root == NULL)
        return NULL;
    inorder(root -> left, nums, len);
    nums[(*len)++] = root -> val;
    inorder(root -> right, nums, len);
}

int* findMode(struct TreeNode* root, int* returnSize){
    int* nums = (int*)malloc(sizeof(int) * 10000);
    *returnSize = 0;
    int len = 0;
    inorder(root, nums, &len);
    int count = 1;
    int tmp = 1;
    // 此处计算众数
    // 先统计出众数的出现次数
    for(int i = 1; i < len; i++){
        if(nums[i - 1] == nums[i]){
            tmp++;
        }
        else{
            count = (count > tmp) ? count : tmp;
            tmp = 1;
        }
    }
    count = (count > tmp) ? count : tmp;
	// 出现次数与count相同的计入众数
    tmp = 1;
    for(int i = 1; i < len; i++){
        if(nums[i - 1] == nums[i])
            tmp++;
        else{
            if(tmp == count)
                nums[(*returnSize)++] = nums[i - 1];
            tmp = 1;
        }
    }
    if(tmp == count)
        nums[(*returnSize)++] = nums[len - 1];
    
    return nums;
}
```

-   <font color='red'>解法：中序遍历迭代版</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void inorder(struct TreeNode* root, int* nums, int* len){
    struct TreeNode* stack[5000];
    int top = 0;
    while(top > 0 || root != NULL){
        while(root != NULL){
            stack[top++] = root;
            root = root -> left;
        }
        root = stack[--top];
        nums[(*len)++] = root -> val;
        root = root -> right;
    }
}

int* findMode(struct TreeNode* root, int* returnSize){
    int* nums = (int*)malloc(sizeof(int) * 10000);
    *returnSize = 0;
    int len = 0;
    inorder(root, nums, &len);
    int count = 1;
    int tmp = 1;
    // 此处计算众数
    // 先统计出众数的出现次数
    for(int i = 1; i < len; i++){
        if(nums[i - 1] == nums[i]){
            tmp++;
        }
        else{
            count = (count > tmp) ? count : tmp;
            tmp = 1;
        }
    }
    count = (count > tmp) ? count : tmp;
	// 出现次数与count相同的计入众数
    tmp = 1;
    for(int i = 1; i < len; i++){
        if(nums[i - 1] == nums[i])
            tmp++;
        else{
            if(tmp == count)
                nums[(*returnSize)++] = nums[i - 1];
            tmp = 1;
        }
    }
    if(tmp == count)
        nums[(*returnSize)++] = nums[len - 1];
    
    return nums;
}
```

## <font color='orange'>236. 二叉树的最近公共祖先</font>

>   力扣链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/
>
>   题目描述：
>
>   给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。
>
>   百度百科中最近公共祖先的定义为：“对于有根树 T 的两个节点 p、q，最近公共祖先表示为一个节点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
>
>    ```c
>   // 示例 1：
>   输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
>   输出：3
>   解释：节点 5 和节点 1 的最近公共祖先是节点 3 。
>       
>   // 示例 2：
>   输入：root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
>   输出：5
>   解释：节点 5 和节点 4 的最近公共祖先是节点 5 。因为根据定义最近公共祖先节点可以为节点本身。
>       
>   // 示例 3：
>   输入：root = [1,2], p = 1, q = 2
>   输出：1
>    ```
>
>
>   提示：
>
>   -   树中节点数目在范围 [2, 10^5] 内。
>   -   -10^9 <= Node.val <= 10^9
>   -   所有 Node.val 互不相同 。
>   -   p != q
>   -   p 和 q 均存在于给定的二叉树中。

-   <font color='red'>解法：中序遍历递归版</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// 关键：找到回溯点
struct TreeNode *res;
bool postOrder(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q){
    if(root == NULL)    return false;
    bool lson = postOrder(root -> left, p, q);
    bool rson = postOrder(root -> right, p, q);
    // 若是 不是叶子 || （左子树或右子树匹配 且 该节点只有一个孩子），向前回溯
    if((lson && rson) || (root -> val == p -> val || root -> val == q -> val)
      && (lson || rson)){
        res = root;
    }
    // 可能匹配到结点或已经匹配到结点时，返回true
    return lson || rson || root -> val == p -> val || root -> val == q -> val;
}

struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    postOrder(root, p, q);
    return res;
}
```

如果用迭代的话，需要借助队列哈希表，二刷的时候补上

## <font color='orange'>235. 二叉搜索树的最近公共祖先</font>

>   力扣链接：https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/
>
>   题目描述:
>
>   给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。
>
>   百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”
>
>   例如，给定如下二叉搜索树:  root = [6,2,8,0,4,7,9,null,null,3,5]
>
>   ```c
>   // 示例 1:
>   输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
>   输出: 6 
>   解释: 节点 2 和节点 8 的最近公共祖先是 6。
>   
>   // 示例 2:
>   输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
>   输出: 2
>   解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。
>   ```
>
>
>   说明:
>
>   -   所有节点的值都是唯一的。
>   -   p、q 为不同节点且均存在于给定的二叉搜索树中。

-   <font color='red'>解法：与昨天的题是一样的</font>

```c
// 这几天有点忙，不然这两道会放在一天
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNOde* res;
bool postOrder(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q){
    if(root == NULL)
        return false;
    bool lres = postOrder(root -> left, p, q);
    bool rres = postOrder(root -> right, p, q);
    if((lres && rres) || (root -> val == p -> val || root -> val == q -> val)
      && (lres || rres))
        res = root;
    return lres || rres || root -> val == p -> val || root -> val == q -> val;
}

struct TreeNode* lowestCommonAncestor(struct TreeNode* root, struct TreeNode* p, struct TreeNode* q) {
    postOrder(root, p, q);
    return res;
}
```

## <font color='orange'>701. 二叉搜索树中的插入操作</font>

>   力扣链接：https://leetcode.cn/problems/insert-into-a-binary-search-tree/
>
>   题目描述：
>
>   给定二叉搜索树（BST）的根节点 root 和要插入树中的值 value ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 保证 ，新值和原始二叉搜索树中的任意节点值都不同。
>
>   注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 任意有效的结果
>
>   ```c
>   // 示例 1：
>   输入：root = [4,2,7,1,3], val = 5
>   输出：[4,2,7,1,3,5]
>   解释：另一个满足题目要求可以通过的树是：
>   
>   // 示例 2：
>   输入：root = [40,20,60,10,30,50,70], val = 25
>   输出：[40,20,60,10,30,50,70,null,null,25]
>   
>   // 示例 3：
>   输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5
>   输出：[4,2,7,1,3,5]
>   ```
>
>
>   提示：
>
>   -   树中的节点数将在 [0, 10^4]的范围内。
>   -   -10^8 <= Node.val <= 10^8
>   -   所有值 Node.val 是 独一无二 的。
>   -   -10^8 <= val <= 10^8
>   -   保证 val 在原始BST中不存在。

-   <font color='red'>解法：迭代模拟</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// 虽然插入的方式有很多，但是遍历到叶子结点插入一定是最好实现的
struct TreeNode* insertIntoBST(struct TreeNode* root, int val){
    struct TreeNode* cur = root;
    // 记录父节点
    struct TreeNode* tmp;
    int LorR = 0;
    // 空结点的处理
    if(root == NULL){
        LorR = -1;
    }
    // 遍历到叶子
    while(cur != NULL){
        if(cur -> val > val){
            if(cur -> left == NULL){
                LorR = 0;
                tmp = cur;
            }
            cur = cur -> left;
        }
        else{
            if(cur -> right == NULL){
                tmp = cur;
                LorR = 1;
            }
            cur = cur -> right;
        }
    }
    // cur此时一定是空
    cur = malloc(sizeof(struct TreeNode));
    cur -> val = val;
    cur -> left = NULL;
    cur -> right = NULL;
    // root为空，插在tmp左边，插在tmp右边的三种情况
    switch(LorR){
        case -1:
            return cur;
        case 0:
            tmp -> left = cur;
            break;
        case 1:
            tmp -> right = cur;
    }
    return root;
}
```

-   <font color='red'>解法：递归模拟</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// 优势：递归在处理添加结点这个问题时，没有根为空的特判（根是不是空 手法都一样）
struct TreeNode* insertIntoBST(struct TreeNode* root, int val){
    // 直接遍历
    if(root == NULL){
        struct TreeNode* res = malloc(sizeof(struct TreeNode));
        res -> val = val;
        res -> left = res -> right = NULL;
        return res;
    }
    // 关键逻辑
    if(root -> val > val)
        root -> left = insertIntoBST(root -> left, val);
    else
        root -> right = insertIntoBST(root -> right, val);
    return root;
}
```

## <font color='orange'>450. 删除二叉搜索树中的节点</font>

>    力扣链接：https://leetcode.cn/problems/delete-node-in-a-bst/
>
>   题目描述：
>
>   给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。
>
>   一般来说，删除节点可分为两个步骤：
>
>   首先找到需要删除的节点；
>   如果找到了，删除它。
>
>   ```c
>   // 示例 1:
>   输入：root = [5,3,6,2,4,null,7], key = 3
>   输出：[5,4,6,2,null,null,7]
>   解释：给定需要删除的节点值是 3，所以我们首先找到 3 这个节点，然后删除它。
>   一个正确的答案是 [5,4,6,2,null,null,7], 如下图所示。
>   另一个正确答案是 [5,2,6,null,4,null,7]。
>   
>   // 示例 2:
>   输入: root = [5,3,6,2,4,null,7], key = 0
>   输出: [5,3,6,2,4,null,7]
>   解释: 二叉树不包含值为 0 的节点
>       
>   // 示例 3:
>   输入: root = [], key = 0
>   输出: []
>   ```
>
>   提示:
>
>   -   节点数的范围 [0, 10^4].
>   -   -10^5 <= Node.val <= 10^5
>   -   节点值唯一
>   -   root 是合法的二叉搜索树
>   -   -10^5 <= key <= 10^5

-   <font color='red'>解法：迭代法</font>

>   根据二叉搜索树的性质：
>
>   -   如果目标节点大于当前节点值，则去右子树中删除；
>   -   如果目标节点小于当前节点值，则去左子树中删除；
>   -   如果目标节点就是当前节点，分为以下三种情况：
>       -   其无左子：其右子顶替其位置，删除了该节点；
>       -   其无右子：其左子顶替其位置，删除了该节点；
>       -   其左右子节点都有：其左子树转移到其右子树的最左节点的左子树上，然后右子树顶替其位置，由此删除了该节点。
>
>   作者：Terry2020
>   链接：https://leetcode.cn/problems/delete-node-in-a-bst/solution/miao-dong-jiu-wan-shi-liao-by-terry2020-tc0o/

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* deleteNode(struct TreeNode* root, int key){
    if(root == NULL)
        return NULL;
    if(root -> val > key)
        root -> left = deleteNode(root -> left, key);
    else if(root -> val < key)
        root -> right = deleteNode(root -> right, key);
    else{
        // 情况一：左空补右结点
        if(root -> left == NULL)
            return root -> right;
        // 情况二：右空补左结点
        if(root -> right == NULL)
            return root -> left;
        // 情况三：左右均不空
        // 找右子树的最左结点
        struct TreeNode* node = root -> right;
        while(node -> left != NULL){
            node = node -> left;
        }
        // 右子树的最左结点 其左子树为 目标结点的左子树
        node -> left = root -> left;
        root = root -> right;
    }
    return root;
}
```

注意，本算法会增加树高，因此二刷时我会补上树高不变的算法。挖坑ing

## <font color='orange'>669. 修剪二叉搜索树</font>

>    力扣链接：https://leetcode.cn/problems/trim-a-binary-search-tree/
>
>   题目描述：
>
>   给你二叉搜索树的根节点 root ，同时给定最小边界low 和最大边界 high。通过修剪二叉搜索树，使得所有节点的值在[low, high]中。修剪树 不应该 改变保留在树中的元素的相对结构 (即，如果没有被移除，原有的父代子代关系都应当保留)。 可以证明，存在 唯一的答案 。
>
>   所以结果应当返回修剪好的二叉搜索树的新的根节点。注意，根节点可能会根据给定的边界发生改变。
>
>    ```c
>   // 示例 1：
>   输入：root = [1,0,2], low = 1, high = 2
>   输出：[1,null,2]
>   
>   // 示例 2：
>   输入：root = [3,0,4,null,2,null,null,1], low = 1, high = 3
>   输出：[3,2,null,1]
>    ```
>
>
>   提示：
>
>   -   树中节点数在范围 [1, 10^4] 内
>   -   0 <= Node.val <= 10^4
>   -   树中每个节点的值都是 唯一 的
>   -   题目数据保证输入是一棵有效的二叉搜索树
>   -   0 <= low <= high <= 10^4

-   <font color='red'>解法：先序遍历迭代版-深度优先</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
struct TreeNode* trimBST(struct TreeNode* root, int low, int high){
    if(root == NULL)
        return root;
    // 如果不在范围内
    if(root -> val < low)
        // 小于范围，则考察右子树
        return trimBST(root -> right, low, high);
    // 大于范围，考察左子树
    if(root -> val > high)
        return trimBST(root -> left, low, high);
    // 在范围内，则考察左右子树
    root -> left = trimBST(root -> left, low, high);
    root -> right = trimBST(root -> right, low, high);
    return root;
}
```

-   <font color='red'>解法：深度优先迭代版</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


struct TreeNode* trimBST(struct TreeNode* root, int low, int high){
    // 如果找不到符合条件的结点，直接结束
    while(root != NULL && (root -> val < low || root -> val > high)){
        if(root -> val < low)
            root = root -> right;
        else
            root = root -> left;
    }
    if(root == NULL)
        return root;
    // 若有符合条件的结点，从本结点开始
    // 对左子树操作（嫁接）
    struct TreeNode* node = root;
    while(node -> left != NULL){
        if(node -> left -> val < low)
            node -> left = node -> left -> right;
        else
            node = node -> left;
    }
    node = root;
    // 对右子树操作（嫁接）
    while(node -> right != NULL){
        if(node -> right -> val > high)
            node -> right = node -> right -> left;
        else
            node = node -> right;
    }
    return root;
}
```

## <font color='orange'>108. 将有序数组转换为二叉搜索树</font>

>   力扣链接：https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/
>
>   题目描述：
>
>   给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
>
>   高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
>
>   ```c
>   // 示例 1：
>   输入：nums = [-10,-3,0,5,9]
>   输出：[0,-3,9,-10,null,5]
>   解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
>   
>   // 示例 2：
>   输入：nums = [1,3]
>   输出：[3,1]
>   解释：[1,null,3] 和 [3,1] 都是高度平衡二叉搜索树。
>   ```
>
>
>   提示：
>
>   -   1 <= nums.length <= 10^4
>   -   -104 <= nums[i] <= 10^4
>   -   nums 按 严格递增 顺序排列

平衡二叉树、红黑树，这些在二叉树中的地位无异于KMP在串的中地位。

-   <font color='red'>解法：先序遍历递归版</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// 由于每次要创建一个结点，所有root是返回值而不是形参
// left和right是索引值
struct TreeNode* toBST(int* nums, int left, int right){
    if(left > right)
        return NULL;
    struct TreeNode* root = malloc(sizeof(struct TreeNode));
    /* int mid = (left + right + 1) >> 1;也可
       上面这行是优先取中间靠右的结点做根节点
       下面是优先取中间靠左的结点
    */
    int mid = (left + right) >> 1;
    root -> val = nums[mid];
    root -> left = toBST(nums, left, mid - 1);
    root -> right = toBST(nums, mid + 1, right);
    return root;
}

struct TreeNode* sortedArrayToBST(int* nums, int numsSize){
    return toBST(nums, 0, numsSize - 1);
}
```

## <font color='orange'>538. 把二叉搜索树转换为累加树</font>

>   力扣链接：https://leetcode.cn/problems/convert-bst-to-greater-tree/
>
>   题目描述：
>
>   给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。
>
>   提醒一下，二叉搜索树满足下列约束条件：
>
>   -   节点的左子树仅包含键 小于 节点键的节点。
>
>   -   节点的右子树仅包含键 大于 节点键的节点。
>
>   -   左右子树也必须是二叉搜索树。
>
>       >   注意：本题和 1038: https://leetcode-cn.com/problems/binary-search-tree-to-greater-sum-tree/ 相同
>
>   ```c
>   // 示例 1
>   输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
>   输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]
>   
>   // 示例 2：
>   输入：root = [0,null,1]
>   输出：[1,null,1]
>   
>   // 示例 3：
>   输入：root = [1,0,2]
>   输出：[3,3,2]
>   
>   // 示例 4：
>   输入：root = [3,2,4,1]
>   输出：[7,9,4,10]
>   ```
>
>
>   提示：
>
>   -   树中的节点数介于 0 和 10^4 之间。
>   -   每个节点的值介于 -10%4 和 10%4 之间。
>   -   树中的所有值 互不相同 。
>   -   给定的树为二叉搜索树。

-   <font color='red'>解法：右根左遍历</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
// 若sum定义为全局变量，则测试时sum内存不会被释放，导致结果错误
void convert(struct TreeNode* root, int* sum){
    if(root == NULL)
        return NULL;
    convert(root -> right, sum);
    *sum += root -> val;
    root -> val = *sum;
    convert(root -> left, sum);
}
struct TreeNode* convertBST(struct TreeNode* root){
    int sum = 0;
    convert(root, &sum);
    return root;
}
```

如果本题想先遍历二叉树，求和，再通过减的方式，则会复杂很多。不如直接在原有基础上处理，只要把右子树的内容加上即可。

# <font color='cornflowerblue'>二叉树总结篇</font>

二叉树的主要题目已经刷完了，接下来的题目会和之前的题目有相似之处，主要是为了巩固二叉树的知识。如果之前的内容比较吃力，建议解决本篇题目时，分配更多思考的时间，即使ac不了，也要有大致思路！

## <font color='orange'>589. N 叉树的前序遍历</font>

>   力扣链接：https://leetcode.cn/problems/n-ary-tree-preorder-traversal/
>
>   题目描述：
>
>   给定一个 n 叉树的根节点  `root` ，返回 *其节点值的 **前序遍历*** 。
>
>   n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 `null` 分隔（请参见示例）。
>
>   **示例 1：**
>
>   ```
>   输入：root = [1,null,3,2,4,null,5,6]
>   输出：[1,3,5,6,2,4]
>   ```
>
>   **示例 2：**
>
>   ```
>   输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
>   输出：[1,2,3,6,7,11,14,4,8,12,5,9,13,10]
>   ```
>
>   **提示：**
>
>   -   节点总数在范围 `[0, 10^4]`内
>   -   `0 <= Node.val <= 10^4`
>   -   n 叉树的高度小于或等于 `1000`

-   <font color='red'>解法：先序遍历递归版</font>

```c
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     int numChildren;
 *     struct Node** children;
 * };
 */

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void order(struct Node* root, int* res, int* returnSize){
    if(root == NULL)
        return NULL;
    res[(*returnSize)++] = root -> val;
    int num = root -> numChildren;
    for(int i = 0; i < num; i++){
        order(root -> children[i], res, returnSize);
    }
}

int* preorder(struct Node* root, int* returnSize) {
    *returnSize = 0;
    int* res = malloc(sizeof(int) * 10000);
    order(root, res, returnSize);
    return res;
}
```

-   <font color='red'>解法：先序遍历迭代版</font>

```c
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     int numChildren;
 *     struct Node** children;
 * };
 */

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void order(struct Node* root, int* res, int* returnSize){
    if(root == NULL)
        return NULL;
    struct Node* stack[10000];
    int top = 0;
    stack[top++] = root;
    // 每次倒序入栈一层，出栈一个，相当于先序遍历
    while(top != 0){
        struct Node* node = stack[--top];
        res[(*returnSize)++] = node -> val;
        for(int i = node -> numChildren - 1; i >= 0; i--)
            stack[top++] = node -> children[i];   
    }
}

int* preorder(struct Node* root, int* returnSize) {
    *returnSize = 0;
    int* res = malloc(sizeof(int) * 10000);
    order(root, res, returnSize);
    return res;
}
```

## <font color='orange'>590. N 叉树的后序遍历</font>

>   力扣链接：https://leetcode.cn/problems/n-ary-tree-postorder-traversal/
>
>   题目描述：
>
>   给定一个 n 叉树的根节点 `root` ，返回 *其节点值的 **后序遍历*** 。
>
>   n 叉树 在输入中按层序遍历进行序列化表示，每组子节点由空值 `null` 分隔（请参见示例）。
>
>   **示例 1：**
>
>   ```
>   输入：root = [1,null,3,2,4,null,5,6]
>   输出：[5,6,3,2,4,1]
>   ```
>
>   **示例 2：**
>
>   ```
>   输入：root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14]
>   输出：[2,6,14,11,7,3,12,8,4,13,9,10,5,1]
>   ```
>
>   **提示：**
>
>   -   节点总数在范围 `[0, 104]` 内
>   -   `0 <= Node.val <= 104`
>   -   n 叉树的高度小于或等于 `1000`

-   <font color='red'>解法：后序遍历递归版</font>

```c
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     int numChildren;
 *     struct Node** children;
 * };
 */

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void order(struct Node* root, int* res, int* returnSize){
    if(root == NULL)
        return NULL;
    for(int i = 0; i < root -> numChildren; i++)
        order(root -> children[i], res, returnSize);
    res[(*returnSize)++] = root -> val;
}

int* postorder(struct Node* root, int* returnSize) {
    *returnSize = 0;
    int* res = malloc(sizeof(int) * 10000);
    order(root, res, returnSize);
    return res;
}
```

-   <font color='red'>解法：后序遍历迭代版</font>

```c
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     int numChildren;
 *     struct Node** children;
 * };
 */
/*
int a, b;
a ^= b;
b ^= a;
a ^= b;
*/
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */

void order(struct Node* root, int* res, int* returnSize){
    if(root == NULL)
        return NULL;
    struct Node* stack[10000];
    int top = 0;
    stack[top++] = root;
    // 
    while(top != 0){
        // 若当前不是叶子，则其子树倒序入栈
        if(root -> numChildren > 0){
            for(int i = root -> numChildren - 1; i >= 0; i--)
                stack[top++] = root -> children[i];
            // 防止反复入栈
            root -> numChildren = 0;
        }
        // 若是叶子，则输出，否则跳到28行
        root = stack[--top];
        if(root -> numChildren > 0)
            stack[top++] = root;
        else
            res[(*returnSize)++] = root -> val;
    }
}

int* postorder(struct Node* root, int* returnSize) {
    *returnSize = 0;
    int* res = malloc(sizeof(int) * 10000);
    order(root, res, returnSize);
    return res;
}
```

-   <font color='red'>解法：先序遍历+逆置</font>

>   先序遍历和后序遍历都是每一层逆序入栈，区别在于先序先访问根，后序先访问叶子，所以如果将先序的每一层逆序入栈改为顺序入栈，则得到的数组就是后序遍历的逆置数组。
>
>   下面用先序遍历的迭代实现的，递归也可

```c
/**
 * Definition for a Node.
 * struct Node {
 *     int val;
 *     int numChildren;
 *     struct Node** children;
 * };
 */

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
void reserve(int* res, int size){
    for(int i = 0; i < size / 2; i++){
        res[i] ^= res[size - i - 1];
        res[size - i - 1] ^= res[i];
        res[i] ^= res[size - i - 1];
    }
}

void order(struct Node* root, int* res, int* returnSize){
    if(root == NULL)
        return NULL;
    struct Node* stack[10000];
    int top = 0;
    stack[top++] = root;
    // 每次倒序入栈一层，出栈一个，相当于先序遍历
    while(top != 0){
        struct Node* node = stack[--top];
        res[(*returnSize)++] = node -> val;
        for(int i = 0; i < node -> numChildren; i++)
            stack[top++] = node -> children[i];   
    }
}

int* postorder(struct Node* root, int* returnSize) {
    *returnSize = 0;
    int* res = malloc(sizeof(int) * 10000);
    order(root, res, returnSize);
    reserve(res, *returnSize);
    return res;
}
```

## <font color='orange'>100. 相同的树</font>

>   力扣链接：https://leetcode.cn/problems/same-tree/
>
>   题目描述：
>
>   给你两棵二叉树的根节点 `p` 和 `q` ，编写一个函数来检验这两棵树是否相同。
>
>   如果两个树在结构上相同，并且节点具有相同的值，则认为它们是相同的。
>
>   **示例 1：**
>
>   ```
>   输入：p = [1,2,3], q = [1,2,3]
>   输出：true
>   ```
>
>   **示例 2：**
>
>   ```
>   输入：p = [1,2], q = [1,null,2]
>   输出：false
>   ```
>
>   **示例 3：**
>
>   ```
>   输入：p = [1,2,1], q = [1,1,2]
>   输出：false
>   ```
>
>   **提示：**
>
>   -   两棵树上的节点数目都在范围 `[0, 100]` 内
>   -   `-104 <= Node.val <= 104`

-   <font color='red'>解法：广度优先（层序遍历）</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */


bool isSameTree(struct TreeNode* p, struct TreeNode* q){
    /* if(p == NULL && q == NULL)
        return true;
    if(p == NULL || q == NULL)
        return false;
        下面两行等价于上面四行，如果p和q中存在为空的，则必须两者都为空，否则返回false
    */
    if(p == NULL || q == NULL)
        return q == NULL && p == NULL;
    // 标准的层序遍历
    struct TreeNode* queue1[100];
    struct TreeNode* queue2[100];
    int front = 0, rear = 0;
    queue1[rear] = p;
    queue2[rear++] = q;
    while(front != rear){
        struct TreeNode* cur1;
        struct TreeNode* cur2;
        int last = rear;
        while(last != front){
            cur1 = queue1[front];
            cur2 = queue2[front++];
            if(cur1 -> val != cur2 -> val)
                return false;
            if(cur1 -> left != NULL && cur2 -> left != NULL){
                queue1[rear] = cur1 -> left;
                queue2[rear++] = cur2 -> left;
            }
            if(cur1 -> right != NULL && cur2 -> right != NULL){
                queue1[rear] = cur1 -> right;
                queue2[rear++] = cur2 -> right;
            }
            // 如果左孩子或右孩子不匹配，返回false
            if((cur1 -> left == NULL && cur2 -> left != NULL) ||
            (cur1 -> left != NULL && cur2 -> left == NULL) ||
            (cur1 -> right == NULL && cur2 -> right != NULL) ||
              (cur1 -> right != NULL && cur2 -> right == NULL))
                return false;
        }
    }
    return true;
}
```

-   <font color='red'>解法：深度优先（先序遍历）</font>

```c
bool isSameTree(struct TreeNode* p, struct TreeNode* q){
    // 上面解释过，不在赘述
    if(p == NULL || q == NULL)
        return q == NULL && p == NULL;
    // 判断值是否一样
    if(p -> val != q -> val)
        return false;
    // 仅当两边都满足，才算满足
    return isSameTree(p -> left, q -> left) && isSameTree(p -> right, q -> right);
}
```

### <font color='BurlyWood'>纠错</font>

<font color='red'>之前我说过深度优先就是先序遍历，这个是错的。</font>

深度优先分为先序遍历、中序遍历和后序遍历，具体可看这篇文章：https://www.geeksforgeeks.org/dfs-traversal-of-a-tree-using-recursion/。

广度优先确实是层序遍历，这个没问题。

## <font color='orange'>572. 另一棵树的子树</font>

>   力扣链接：https://leetcode.cn/problems/subtree-of-another-tree/
>
>   题目描述：
>
>   给你两棵二叉树 `root` 和 `subRoot` 。检验 `root` 中是否包含和 `subRoot` 具有相同结构和节点值的子树。如果存在，返回 `true` ；否则，返回 `false` 。
>
>   二叉树 `tree` 的一棵子树包括 `tree` 的某个节点和这个节点的所有后代节点。`tree` 也可以看做它自身的一棵子树。
>
>   **示例 1：**
>
>   ```
>   输入：root = [3,4,5,1,2], subRoot = [4,1,2]
>   输出：true
>   ```
>
>   **示例 2：**
>
>   ```
>   输入：root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
>   输出：false
>   ```
>
>   **提示：**
>
>   -   `root` 树上的节点数量范围是 `[1, 2000]`
>   -   `subRoot` 树上的节点数量范围是 `[1, 1000]`
>   -   `-104 <= root.val <= 104`
>   -   `-104 <= subRoot.val <= 104`

-   <font color='red'>解法：深度优先</font>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
bool check(struct TreeNode* root, struct TreeNode* subRoot){
    if(root == NULL && subRoot == NULL)
        return true;
    if((root != NULL && subRoot == NULL) ||
      (root == NULL && subRoot != NULL) ||
      (root -> val != subRoot -> val))
        return false;
    return check(root -> left, subRoot -> left) 
        && check(root -> right, subRoot -> right);
}

bool dfs(struct TreeNode *root, struct TreeNode *subRoot){
    if(root == NULL)
        return false;
    return check(root, subRoot) || dfs(root -> left, subRoot) ||
        dfs(root -> right, subRoot);
}

bool isSubtree(struct TreeNode* root, struct TreeNode* subRoot){
    return dfs(root, subRoot);
}
```

至此，二叉树的所有内容已经结束了。从数组到二叉树，这些都是本科学过的，所有大家难免会有所轻视。接下来要学习回溯算法、贪心算法、动态规划、图论的内容，私以为将要迈入算法的中级阶段，因此希望大家能多花功夫取模拟，而不是为了刷题而刷题（思想！）。

与君共勉！