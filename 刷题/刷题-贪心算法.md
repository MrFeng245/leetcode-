# <span style="color: cornflowerblue;">贪心算法</span>

## <span style="color: orange;">455\. 分发饼干</span>

> 力扣链接：https://leetcode.cn/problems/assign-cookies/
>
> 题目描述：
>
> 假设你是一位很棒的家长，想要给你的孩子们一些小饼干。但是，每个孩子最多只能给一块饼干。
>
> 对每个孩子 `i`，都有一个胃口值 `g[i]`，这是能让孩子们满足胃口的饼干的最小尺寸；并且每块饼干 `j`，都有一个尺寸 `s[j]` 。如果 `s[j] >= g[i]`，我们可以将这个饼干 `j` 分配给孩子 `i` ，这个孩子会得到满足。你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。
>
> **示例 1:**
>
> ```
> 输入: g = [1,2,3], s = [1,1]
> 输出: 1
> 解释: 
> 你有三个孩子和两块小饼干，3个孩子的胃口值分别是：1,2,3。
> 虽然你有两块小饼干，由于他们的尺寸都是1，你只能让胃口值是1的孩子满足。
> 所以你应该输出1。
> ```
>
> **示例 2:**
>
> ```
> 输入: g = [1,2], s = [1,2,3]
> 输出: 2
> 解释: 
> 你有两个孩子和三块小饼干，2个孩子的胃口值分别是1,2。
> 你拥有的饼干数量和尺寸都足以让所有孩子满足。
> 所以你应该输出2.
> ```
>
> **提示：**
>
> - `1 <= g.length <= 3 * 104`
> - `0 <= s.length <= 3 * 104`
> - `1 <= g[i], s[j] <= 231 - 1`

贪心、动态规划、单调栈、图论

这四个一更，就完结了🙌

### <span style="color: burlywood;">分析</span>

贪心算法其实就是在每个阶段都达到最优，从而让整体最优。

就本题而言，最小的饼干给刚适配的小孩最优。于是把两个数组快排，遍历。如果适配两个指针都向后，否则仅向后遍历饼干，即双指针+贪心

### <span style="color: burlywood;">代码</span>

- <span style="color: red;">c</span>

```c
int cmp(const void *a, const void *b){
    return *(int*)a -*(int*)b;
}

int findContentChildren(int* g, int gSize, int* s, int sSize){
    qsort(g, gSize, sizeof(int), cmp);
    qsort(s, sSize, sizeof(int), cmp);
    
    int res = 0;
    
    for(int i = 0, j = 0; i < gSize && j < sSize; j++){
        if(s[j] < g[i])
            continue;
        else{
            i++;
            res++;
        }
    }
    return res;
}
```

- <span style="color: red;">python3</span>

```python
class Solution:
    def findContentChildren(self, g: List[int], s: List[int]) -> int:
        res = 0
        s.sort(), g.sort()
        
        m, n = len(g), len(s)
        i, j = 0, 0
        while i < m and j < n:
            if s[j] >= g[i]:
                i += 1
                j += 1
                res += 1
            else:
                j += 1
                
        return res
```

## <span style="color: orange;">376\. 摆动序列</span>

> 力扣链接：https://leetcode.cn/problems/wiggle-subsequence/
>
> 题目描述：
>
> 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为 **摆动序列 。**第一个差（如果存在的话）可能是正数或负数。仅有一个元素或者含两个不等元素的序列也视作摆动序列。
>
> - 例如， `[1, 7, 4, 9, 2, 5]` 是一个 **摆动序列** ，因为差值 `(6, -3, 5, -7, 3)` 是正负交替出现的。
> - 相反，`[1, 4, 7, 2, 5]` 和 `[1, 7, 4, 5, 5]` 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
>
> **子序列** 可以通过从原始序列中删除一些（也可以不删除）元素来获得，剩下的元素保持其原始顺序。
>
> 给你一个整数数组 `nums` ，返回 `nums` 中作为 **摆动序列** 的 **最长子序列的长度** 。
>
> **示例 1：**
>
> ```
> 输入：nums = [1,7,4,9,2,5]
> 输出：6
> 解释：整个序列均为摆动序列，各元素之间的差值为 (6, -3, 5, -7, 3) 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1,17,5,10,13,15,10,5,16,8]
> 输出：7
> 解释：这个序列包含几个长度为 7 摆动序列。
> 其中一个是 [1, 17, 10, 13, 10, 16, 8] ，各元素之间的差值为 (16, -7, 3, -3, 6, -8) 。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [1,2,3,4,5,6,7,8,9]
> 输出：2
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 1000`
> - `0 <= nums[i] <= 1000`

### <span style="color: burlywood;">分析</span>

先看一种经典的错误：

```c
int wiggleMaxLength(int* nums, int numsSize){
    int res = 1;
    int lock = 0;
    int index = 0;
    for(int i = 0; i < numsSize - 1; i++){
        int offset = nums[i+1] - nums[index];
        if(offset == 0)
            continue;
        // 互斥锁lock = 0 仅出现一次，之后就是来回荡
        if((lock == 0 || lock == -1) && offset > 0){
            index = i + 1;
            res++;
            lock = 1;
        }
        else if((lock == 0 || lock == 1) && offset < 0){
            index = i + 1;
            res++;
            lock = -1;
        }
    }
    return res;
}
```

此解法的问题在于没有考虑之后的情况。比如开始是左右，结果第二个数以后就是右左右左，而且数很小：

```c
/*示例：*/1, 2, 100, 10, 75, 50
// 此代码摆动序列：(1, 2)
// 实际摆动序列：(2, 100, 10, 75, 50)
```

如果去掉其中的index，`offset = nums[i+1]-nums[i]`，仅考虑局部最优，最终结果也会最优。

```c
// 示例：[7, 2, 5, 1, 2, 100, 10, 75, 50]
// 摆动序列是：[7, 2, 5, 1, 100, 10, 75, 50]
```

其实就是仅取峰值作为摆动序列，两个if直接互锁

### <span style="color: burlywood;">代码</span>

- <span style="color: red;">c</span>

```c
int wiggleMaxLength(int* nums, int numsSize){
    int res = 1;
    int lock = 0;
    int i = 0;
    for(int i = 0; i < numsSize - 1; i++){
        int offset = nums[i+1] - nums[i];
        if(offset == 0)
            continue;
        // 互斥锁lock = 0 仅出现一次，之后就是来回荡
        if((lock == 0 || lock == -1) && offset > 0){ // 上升
            res++;
            lock = 1;
        }
        // 两个if互锁，因此 if-else if 和 if if 效果相同
        if((lock == 0 || lock == 1) && offset < 0){ // 下落
            res++;
            lock = -1;
        }
    }
    return res;
}
```

```c
// 优化判断条件
if(lock != 1 && offset > 0)
    
if(lock != -1 && offset < 0)
```

```c
// 另一种写法 实际还是贪心
// 在有极值的区域记录(++), up和down每次继承以前贪心的结果
int wiggleMaxLength(int* nums, int numsSize){
    if(numsSize == 1)
        return 1;
    int up = 1;
    int down = 1;
    for(int i = 1; i < numsSize; i++){
        if(nums[i] > nums[i - 1])
            up = down + 1;
        if(nums[i] < nums[i - 1])
            down = up + 1;
    }
    return fmax(down, up);
} 
```

- <span style="color: red;">python3</span>

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        res = 1
        tag = 0
        for i in range(1, len(nums)):
            if nums[i - 1] < nums[i] and tag != 1:
                res += 1
                tag = 1
            if nums[i - 1] > nums[i] and tag != -1:
                res += 1
                tag = -1
        return res
```

```python
class Solution:
    def wiggleMaxLength(self, nums: List[int]) -> int:
        up, down = 1, 1
        for i in range(1, len(nums)):
            if(nums[i - 1] > nums[i]):
                down = up + 1
            if(nums[i - 1] < nums[i]):
                up = down + 1
                
        return max(down, up)
```

## <span style="color: orange;">53\. 最大子数组和</span>

> 力扣链接：https://leetcode.cn/problems/maximum-subarray/
>
> 题目描述：
>
> 给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
>
> **子数组** 是数组中的一个连续部分。
>
> **示例 1：**
>
> ```
> 输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
> 输出：6
> 解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [1]
> 输出：1
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [5,4,-1,7,8]
> 输出：23
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 105`
> - `-104 <= nums[i] <= 104`

### <span style="color: burlywood;">分析</span>

虽然昨天的代码我分析的很多，估计大家还是没理解来怎么贪。

就今天的问题而言，求最长子数组，如果第一个数是负数，我们不要，如果前两个数都是负数，我们也不要，问题在于如果一正一负怎么办。

如果前两个数的和大于0，那对后面的数就是有收益的，否则就不要。这个思路行不行。答案是不行：

```c
[-2,1,-3,4,-1,2,1,-5,4]
// 预期：6
// 实际：5
```

错在哪？-5把前面的收益砍了，后面的结果没之前的收益大。如果每次收益清零之前保存一个，这个问题就解决了。

然后提交，发现另一个错误：

```c
[-2,-1]
// 预期：-1
// 实际：0
```

对于全是负数的情况，取最大值即可。

### <span style="color: burlywood;">代码</span>

- <span style="color: red;">c</span>

```c
int maxSubArray(int* nums, int numsSize){
    int res = 0;
    int tmp = 0;
    // 全是负数的判断逻辑
    int tag = 0;
    int max  = nums[0];
    for(int i = 0; i < numsSize; i++){
        // 若全是小于0的数，tag为0
        if(nums[i] > 0){
            tag = 1;
            break;
        }
        if(nums[i] > max)
            max = nums[i];
    }
    if(tag == 0)
        return max;
    // 正负相间的逻辑
    for(int i = 0; i < numsSize; i++){
        tmp += nums[i]; 
        // 若之前的没有收益，就清零
        if(tmp < 0)	
            tmp = 0;
        // 保存最大值
        if(tmp > res)
            res = tmp;
    }
    return res;
}
```

- <span style="color: red;">python</span>

```python
class Solution:
    def maxSubArray(self, nums: List[int]) -> int:
        res = nums[0]
        tmp = 0
        tag = 0
        for num in nums:
            if num > 0:
                tag = 1
                break
            if res < num:
                res = num
                
        if tag == 0:
            return res
            
        for num in nums:
            tmp += num
            if tmp < 0:
                tmp = 0
            if(tmp > res):
                res = tmp
        return res
```

## <span style="color: orange;">122\. 买卖股票的最佳时机 II</span>

> 力扣链接：https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/
>
> 给你一个整数数组 `prices` ，其中 `prices[i]` 表示某支股票第 `i` 天的价格。
>
> 在每一天，你可以决定是否购买和/或出售股票。你在任何时候 **最多** 只能持有 **一股** 股票。你也可以先购买，然后在 **同一天** 出售。
>
> 返回 *你能获得的 **最大** 利润* 。
>
> **示例 1：**
>
> ```
> 输入：prices = [7,1,5,3,6,4]
> 输出：7
> 解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>   随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。
>   总利润为 4 + 3 = 7 。
> ```
>
> **示例 2：**
>
> ```
> 输入：prices = [1,2,3,4,5]
> 输出：4
> 解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。
>   总利润为 4 。
> ```
>
> **示例 3：**
>
> ```
> 输入：prices = [7,6,4,3,1]
> 输出：0
> 解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。
> ```
>
> **提示：**
>
> - `1 <= prices.length <= 3 * 104`
> - `0 <= prices[i] <= 104`

### <span style="color: burlywood;">分析</span>

本题也能贪，只不过是从后往前贪。如果后一个减前一个大于零，则加到结果中（有点像脑筋急转弯）

### <span style="color: burlywood;">代码</span>

- <span style="color: red;">c</span>

```c
int maxProfit(int* prices, int pricesSize){
    int profit = 0;
    for(int i = pricesSize - 2; i >= 0; i--){
        int tmp = prices[i + 1] - prices[i];
        if(tmp > 0){
            profit += tmp;
        }
    }
    return profit;
}
```

- <span style="color: red;">python</span>

```python
class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        profit = 0
        # python 从后往前遍历
        for i in range(len(prices) - 2, -1, -1):
            tmp = prices[i + 1] - prices[i]
            if(tmp > 0):
                profit += tmp
                
        return profit
```

## <span style="color: orange;">55\. 跳跃游戏</span>

> 力扣链接：https://leetcode.cn/problems/jump-game/
>
> 给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。
>
> 数组中的每个元素代表你在该位置可以跳跃的最大长度。
>
> 判断你是否能够到达最后一个下标。
>
> **示例 1：**
>
> ```
> 输入：nums = [2,3,1,1,4]
> 输出：true
> 解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [3,2,1,0,4]
> 输出：false
> 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 3 * 104`
> - `0 <= nums[i] <= 105`

### <span style="color: burlywood;">分析</span>

本题需要先确定题意（以下输入得到的输出是什么）：

```c
[0] // ouput:true
[1,0] // output:true
```

因而可知，需要到达最后一个下标，而不是到最后一个下标时还要跳一下【这将决定临界条件】。

下面提供两种思路：

- 思路一：

> 遍历数组，循环内部的代码实现如下功能：
>
> 反向遍历当前步长，如果找到下次步长最大的索引，把索引再加到外层索引上
>
> 如果循环期间遇到下次最大步长对应的值都为0，则返回false，否则返回true

```c
bool canJump(int* nums, int numsSize){

    if(numsSize == 1)
        return true;
    if(nums[0] == 0)
        return false;
    int i = 0;
    while(i < numsSize - 1){
        // 找到可以跳到的位置中，数值最大的索引
        int maxIndex = nums[i];
        for(int j = nums[i] - 1; j > 0; j--){ 
            // 可以跳出
            if(i + nums[i] >= numsSize - 1)
                return true;
            if(nums[i + j] > nums[i + maxIndex])
                maxIndex = j;
        }

        // 如果跳到的最大位置的值为0，且没有跳到索引为numsSize-1的位置
        if(nums[i + maxIndex] == 0 && i + maxIndex != numsSize - 1)
            return false;
        i += maxIndex;
    }
    return true;
}
```

这个代码不能通过的实例是(倒数第二个)：

```c
[4,2,0,0,1,1,4,4,4,0,4,0]
```

原因留给你们思考

- 思路二：

> 循环遍历数组，在循环内部：
>
> 如果遇到步数更大的值，替换掉当前步数
>
> 每向后遍历一次，索引+1，步数-1

思路一贪的是下一次的最大步数，思路二贪的是向后遍历过程中遇到的最大步数

### <span style="color: burlywood;">代码</span>

- <span style="color: red;">c</span>

```c
bool canJump(int* nums, int numsSize){

    if(numsSize == 1)
        return true;
    int i = 0, step = nums[0];
    while(i < numsSize - 1){
        while(step){
            // 若当前位置加最大步数到达或超过超过最后一个元素的索引值，则可达
            if(step + i >= numsSize - 1)
                return true;
            // 当前元素向后遍历一位，步数减一
            i++, step--;
            // 如果当前遍历的值大于步数，替换步数
            if(nums[i] > step)
                step = nums[i];
        }
        return false;
    }
    return false;
}
```

- <span style="color: red;">python</span>

```python
class Solution:
    def canJump(self, nums: List[int]) -> bool:
        if len(nums) == 1:
            return True
        i, step = 0, nums[0]
        while i < len(nums) - 1:
            while step:
                if i + step >= len(nums) - 1:
                    return True
                i += 1
                step -= 1
                if nums[i] > step:
                    step = nums[i]
            return False
        return False
```

## <span style="color: orange;">45\. 跳跃游戏 II</span>

> 力扣链接：https://leetcode.cn/problems/jump-game-ii/
>
> 给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置为 `nums[0]`。
>
> 每个元素 `nums[i]` 表示从索引 `i` 向前跳转的最大长度。换句话说，如果你在 `nums[i]` 处，你可以跳转到任意 `nums[i + j]` 处:
>
> - `0 <= j <= nums[i]`
> - `i + j < n`
>
> 返回到达 `nums[n - 1]` 的最小跳跃次数。生成的测试用例可以到达 `nums[n - 1]`。
>
> **示例 1:**
>
> ```
> 输入: nums = [2,3,1,1,4]
> 输出: 2
> 解释: 跳到最后一个位置的最小跳跃数是 2。
>      从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
> ```
>
> **示例 2:**
>
> ```
> 输入: nums = [2,3,0,1,4]
> 输出: 2
> ```
>
> **提示:**
>
> - `1 <= nums.length <= 104`
> - `0 <= nums[i] <= 1000`
> - 题目保证可以到达 `nums[n-1]`

### <span style="color: burlywood;">分析</span>

这个问题可以用昨天有`bug`的代码做，改改就是答案。

昨天的思路一，其问题在于优先贪心离当前最远的，因此但离当前最远的不一定能跳过去，因此不可取。

但是本题说明题目保证可达，因此稍加修改便可使用。

> 思路一的精髓在于更新下次的index，下面举例说明：
>
> ```c
> [2,3,0,1,4]
> ```
>
> 外层循环`i`先指向0，下次可跳到的位置`maxIndex`，内层循环找出`maxIndex`的下次最远距离的索引（本例是1）。
>
> 内层`j`从$[1,nums[i]]$开始遍历：
>
> 1.  `j`遍历1，如果先跳到`nums[1]`，则下次可跳到`nums[3]`的位置
> 2.  `j`遍历2，如果先跳到`nums[2]`，下次可跳到`nums[2]`
>
> 虽然第二次跳出失败，但`j`遍历1显然大于`j`遍历2，所以取`maxIndex=i`, `i+=maxIndex`。
>
> 如果每个元素下次可达的最远距离都一样，则优先选取最后一个，因此可以给`maxIndex`赋初值`nums[i]`，内层循环$[1,nums[i]-1]$，倒序进行，这样在距离相等是就不用反复赋值。
>
> 至于`maxIndex`的判断条件，可以以`i`为起始点，则`j`遍历1的距离就是`nums[0+j]+j`，`maxIndex`可达的距离就是`nums[i+maxIndex]+maxIndex`，在前者大于后者时交换。

### <span style="color: burlywood;">代码</span>

- <span style="color: red;">c</span>

```c
int jump(int* nums, int numsSize){
    int res = 1;
    // 1的特判
    if(numsSize == 1)
        return 0;
    int i = 0;
    while(i < numsSize - 1){
        // 若本次可达的最远距离可以到达（甚至超过）最后一位，则返回
        if(i + nums[i] >= numsSize - 1)
                return res;
        // 找到可以跳到的位置中，数值最大的索引
        int maxIndex = nums[i];
        for(int j = nums[i] - 1; j > 0; j--){ 
            // 更新maxIndex
            if(nums[i + j] + j > nums[i + maxIndex] + maxIndex)
                maxIndex = j;
        }
        // 更新i和res
        i += maxIndex;
        res++;
    }
    return res;
}
```

- <span style="color: red;">python</span>

```python
class Solution:
    def jump(self, nums: List[int]) -> int:
        if len(nums) == 1:
            return 0
        res = 1
        i = 0
        while i < len(nums) - 1:
            if nums[i] + i >= len(nums) - 1:
                return res
            maxIndex = nums[i]
            # range设置步长为-1，左闭右开
            for j in range(nums[i] - 1, 0, -1):
                if nums[i + j] + j > nums[i + maxIndex] + maxIndex:
                    maxIndex = j
                
            i += maxIndex
            res += 1
        return res
```

### <span style="color: burlywood;">闲聊</span>

刚试了一下，发现昨天那个题思路一没问题，合着是我代码不够硬，没把思路表达出来

```c
// https://leetcode.cn/problems/jump-game/submissions/
bool canJump(int* nums, int numsSize){

    int res = 1;
    // 1的特判
    if(numsSize == 1)
        return true;
    int i = 0;
    while(i < numsSize - 1){
        // 若本次可达的最远距离可以到达（甚至超过）最后一位，则返回
        if(i + nums[i] >= numsSize - 1)
                return true;
        // 找到可以跳到的位置中，数值最大的索引
        int maxIndex = nums[i];
        for(int j = nums[i] - 1; j > 0; j--){ 
            // 更新maxIndex
            if(nums[i + j] + j > nums[i + maxIndex] + maxIndex)
                maxIndex = j;
        }
        if(nums[i + maxIndex] == 0 && i + maxIndex != numsSize - 1)
            return false;
        // 更新i和res
        i += maxIndex;
        res++;
    }
    return true;
}
```

## <span style="color: orange;">1005\. K 次取反后最大化的数组和</span>

> 力扣链接：https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/
>
> 给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：
>
> - 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。
>
> 重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。
>
> 以这种方式修改数组后，返回数组 **可能的最大和** 。
>
> **示例 1：**
>
> ```
> 输入：nums = [4,2,3], k = 1
> 输出：5
> 解释：选择下标 1 ，nums 变为 [4,-2,3] 。
> ```
>
> **示例 2：**
>
> ```
> 输入：nums = [3,-1,0,2], k = 3
> 输出：6
> 解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
> ```
>
> **示例 3：**
>
> ```
> 输入：nums = [2,-3,-1,5,-4], k = 2
> 输出：13
> 解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
> ```
>
> **提示：**
>
> - `1 <= nums.length <= 104`
> - `-100 <= nums[i] <= 100`
> - `1 <= k <= 104`

### <span style="color: burlywood;">分析</span>

这个问题的复杂之处在于你如果把这个问题往复杂里想，它就很难。

如果你能看出它是贪心问题，就比较简单：

要得到最大值，那就每次把nums里最小的（必须是负数）取反，如果不是负数，则就要考虑k了

1.  如果k是偶数，则直接赋值0
2.  如果k是奇数，则只能把当前的最小值赋值为0

（如果k是偶数，则可以反复对一个数取反，不影响结果）

最后把nums加起来即可。

### <span style="color: burlywood;">代码</span>

```c
int largestSumAfterKNegations(int* nums, int numsSize, int k){
    while(k){
        int minIndex = 0;
        //找最小索引
        for(int i = 1; i < numsSize; i++){
            if(nums[i] < nums[minIndex])
                minIndex = i;
        }
        // 如果最小索引对应的值小于0，取反即可
        if(nums[minIndex] < 0)
            nums[minIndex] *= -1;
        // 如果不是小于0
        else{
            // 同时k是奇数，只能把当前值取反
            if(k % 2 == 1)
                nums[minIndex] *= -1;
            k = 1; // 此处k取1即可，下面的k--会使k为0，从而跳出循环
        }
        k--;
    }
    int res = 0;
    for(int i = 0; i < numsSize; i++)
        res += nums[i];
    return res;
}
```

```python
class Solution:
    def largestSumAfterKNegations(self, nums: List[int], k: int) -> int:
        while k:
            minIndex = 0
            for i in range(1, len(nums)):
                if nums[i] < nums[minIndex]:
                    minIndex = i
                
            if nums[minIndex] < 0:
                nums[minIndex] *= -1
            else:
                if k % 2 == 1:
                    nums[minIndex] *= -1
                k = 1
            k -= 1
            
        return sum(nums)
```

## <span style="color: orange;">134\. 加油站</span>

> 力扣链接：https://leetcode.cn/problems/gas-station/
>
> 在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。
>
> 你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。
>
> 给定两个整数数组 `gas` 和 `cost` ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。
>
> **示例 1:**
>
> ```
> 输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
> 输出: 3
> 解释:
> 从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
> 开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
> 开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
> 开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
> 开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
> 开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
> 因此，3 可为起始索引。
> ```
>
> **示例 2:**
>
> ```
> 输入: gas = [2,3,4], cost = [3,4,3]
> 输出: -1
> 解释:
> 你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
> 我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
> 开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
> 开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
> 你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
> 因此，无论怎样，你都不可能绕环路行驶一周。
> ```
>
> **提示:**
>
> - `gas.length == n`
> - `cost.length == n`
> - `1 <= n <= 105`
> - `0 <= gas[i], cost[i] <= 104`

### <span style="color: burlywood;">分析</span>

如果只是单纯的模拟，会被判超时：

```c
int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize){
    int res = 0, n = gasSize;
    int tag = 1;

    // 遍历gas
    for(int i = 0; i < n; i++){
        if(gas[i] != 0 && gas[i] >= cost[i]){
            res = i;
            int left = 0;
            // 模拟加油的过程
            for(int j = i; j < n; j++){
                left += gas[j] - cost[j];
                if(left < 0){
                    tag = 0;
                    break;
                }
            }
            for(int j = 0; j < i; j++){
                left += gas[j] - cost[j];
                if(left < 0){
                    tag = 0;
                    break;
                }
            }
            // 如果没出现油不够的情况，说明可达
            if(tag == 1)
                return res;
            tag = 1;
        }
    }
    
    return -1;
}
```

至于本题的思路，推荐阅读：https://leetcode.cn/problems/gas-station/solution/dang-lao-si-ji-xue-hui-liao-tan-xin-suan-8s2g/

需要理解：

- 如果gas和小于cost和，无法达到，否则可以到达
- 如果选择站点 `i` 作为起点「恰好」无法走到站点 `j`，那么 `i` 和 `j` 中间的任意站点 `k` 都不可能作为起点。

### <span style="color: burlywood;">图像法 & 贪心算法</span>

- <span style="color: red;">c</span>

```c
// 图像法
int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize){
    int n = gasSize;
    int res = minSum = sum = 0;
    int min = gas[0] - cost[0];
    for(int i = 0; i < n; i++){
        sum += gas[i] - cost[i];
        // 找最小的差值和
        if(sum < minSum){
            res = i + 1;
            minSum = sum;
        }
    }
    if(sum < 0)
        return -1;
    return res == n ? 0 : res;
}
```

```c
// 贪心算法
int canCompleteCircuit(int* gas, int gasSize, int* cost, int costSize){
    int n = gasSize;
    int sum = 0;
    for(int i = 0; i < n; i++)
        sum += gas[i] - cost[i];
    
    if(sum < 0)
        return -1;
    
    int left = 0, start = 0;
    for(int i = 0; i < n; i++){
        left += gas[i] - cost[i];
        if(left < 0){
            left = 0;
            start = i + 1;
        }
    }
    return start == n ? 0 : start;
}
```

- <span style="color: red;">python</span>

```python
# 图像法
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        min_value = gas[0] - cost[0]
        sum_value, min_sum, res = 0, 0, 0
        for i in range(len(gas)):
            sum_value += gas[i] - cost[i]
            if sum_value <= min_value:
                min_value = sum_value
                res = i + 1
        
        if sum_value < 0:
            return -1
        if res == len(gas):
            return 0
        return res
```

```python
# 贪心算法
class Solution:
    def canCompleteCircuit(self, gas: List[int], cost: List[int]) -> int:
        if sum(gas) - sum(cost) < 0:
            return -1
        
        start, left = 0, 0
        for i in range(len(gas)):
            left += gas[i] - cost[i]
            if left < 0:
                left = 0
                start = i + 1
                
        if start == len(gas):
            return 0
        return start
```

## <span style="color: orange;">135.分发糖果</span>

> 力扣链接：https://leetcode.cn/problems/candy/
>
> `n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。
>
> 你需要按照以下要求，给这些孩子分发糖果：
>
> - 每个孩子至少分配到 `1` 个糖果。
> - 相邻两个孩子评分更高的孩子会获得更多的糖果。
>
> 请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。
>
> **示例 1：**
>
> ```
> 输入：ratings = [1,0,2]
> 输出：5
> 解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
> ```
>
> **示例 2：**
>
> ```
> 输入：ratings = [1,2,2]
> 输出：4
> 解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
>      第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
> ```
>
> **提示：**
>
> - `n == ratings.length`
> - `1 <= n <= 2 * 104`
> - `0 <= ratings[i] <= 2 * 104`

### <span style="color: burlywood;">分析</span>

定义一个数组arr，从左往右遍历，第一个值赋为1，之后若ratings当前值大于其前一个，则arr的当前值等于前一个加1，否则arr的当前值就等于当前值减1。然后处理arr中小于1的值，先找出最小值，最后把arr加起来和为sum。结果就是`sum + (1 - min) * ratingsSize`。这样的思路，会导致最后产生的**最小值抬高整个结果**，所以不能执行减1操作。

但是如果只考虑一个方向（从左往右遍历ratings），就与题意不符（每个孩子最多有两边），比如：

```c
[1,0,2]
```

所以还要考虑从右向左遍历ratings。第二次遍历过程中可能会遇到`arr[i] + 1`没有`arr[i - 1]`大的情况，此时取最大的作为`arr[i]`

最终过程如下：

- 先申请一个数组arr，赋初值为1。
- 从左往右遍历ratings，如果ratings的后一个大于前一个，arr后一个的值等于arr前一个值加1；
- 再从右往左遍历ratings，如果ratings的前一个大于后一个 && arr后一个值加1后小于arr前一个的值，arr的前一个等于后一个加1。
- 最后把arr求和，就是结果

### <span style="color: burlywood;">代码</span>

```c
int candy(int* ratings, int ratingsSize){
    int arr[ratingsSize];
    for(int i = 0; i < ratingsSize; i++)
        arr[i] = 1;
    // 向后遍历
    for(int i = 1; i < ratingsSize; i++){
        if(ratings[i] > ratings[i - 1])
            arr[i] = arr[i - 1] + 1;
    }
    // 向前遍历
    for(int i = ratingsSize - 1; i > 0; i--){
        if(ratings[i - 1] > ratings[i]){
            int tmp = arr[i] + 1;
            if(tmp > arr[i - 1])
                arr[i - 1] = tmp;
        }
    }
    int sum = 0;
    for(int i = 0; i < ratingsSize; i++)
        sum += arr[i];
    return sum;
}
```

```python
class Solution:
    def candy(self, ratings: List[int]) -> int:
        arr = [1 for _ in range(len(ratings))]
        for i in range(1, len(ratings)):
            if ratings[i] > ratings[i - 1]:
                arr[i] = arr[i - 1] + 1
        
        for i in range(len(ratings) - 1, 0, -1):
            if ratings[i - 1] > ratings[i] and arr[i - 1] < arr[i] + 1:
                arr[i - 1] = arr[i] + 1
                
        return sum(arr)
```

## <span style="color: orange;">860\. 柠檬水找零</span>

> 力扣链接：https://leetcode.cn/problems/lemonade-change/)
>
> 在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。
>
> 每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。
>
> 注意，一开始你手头没有任何零钱。
>
> 给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。
>
> **示例 1：**
>
> ```
> 输入：bills = [5,5,5,10,20]
> 输出：true
> 解释：
> 前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
> 第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
> 第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
> 由于所有客户都得到了正确的找零，所以我们输出 true。
> ```
>
> **示例 2：**
>
> ```
> 输入：bills = [5,5,10,10,20]
> 输出：false
> 解释：
> 前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
> 对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
> 对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
> 由于不是每位顾客都得到了正确的找零，所以答案是 false。
> ```
>
> **提示：**
>
> - `1 <= bills.length <= 105`
> - `bills[i]` 不是 `5` 就是 `10` 或是 `20`

### <span style="color: burlywood;">分析</span>

这题直接模拟就行，给5直接收，给10或20判断一下能不能找零

### <span style="color: burlywood;">代码</span>

```c
bool lemonadeChange(int* bills, int billsSize){
    int five = 0, ten = 0;
    for(int i = 0; i < billsSize; i++){
        // 直接收钱
        if(bills[i] == 5)
            five++;
        // 找钱
        else{
            switch(bills[i]){
                case 10:
                    if(five == 0)
                        return false;
                    five--;
                    ten++;
                    break;
                case 20:
                    if(five < 1 || (five < 3 && ten < 1))
                        return false;
                    if(ten >= 1){
                        ten--;
                        five--;
                    }
                    else if(five >= 3){
                        five -= 3;
                    }
                    break;
            }
            
        }
    }
    return true;
}
```

```python
class Solution:
    def lemonadeChange(self, bills: List[int]) -> bool:
        five, ten = 0, 0
        for i in range(len(bills)):
            # 收钱
            if bills[i] == 5:
                five += 1
            else: # 找钱
                match bills[i]:
                    case 10:
                        if five == 0:
                            return False
                        five -= 1
                        ten += 1
                    case 20:
                        if five < 1 or (five < 3 and ten < 1):
                            return False
                        if ten >= 1:
                            ten -= 1
                            five -= 1
                        else:
                            five -= 3
        return True
```

## <span style="color: orange;">406\. 根据身高重建队列</span>

> 力扣链接：https://leetcode.cn/problems/queue-reconstruction-by-height/
>
> 假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。
>
> 请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。
>
> **示例 1：**
>
> ```
> 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
> 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
> 解释：
> 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
> 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
> 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
> 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
> 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
> 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
> 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
> ```
>
> **示例 2：**
>
> ```
> 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
> 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
> ```
>
> **提示：**
>
> - `1 <= people.length <= 2000`
> - `0 <= hi <= 106`
> - `0 <= ki < people.length`
> - 题目数据确保队列可以被重建

### <span style="color: burlywood;">分析</span>

> 对于一行两列的数组，排序之后会简单。两种排序方式：如果按第一个元素升序排，在第一个元素相等的情况下，第二个元素按降序排，第二中正好相反。 ——sunny【力扣的一位用户】

基于上面的套路，排序之后再遍历。如果$k_i$比当前索引$i$小或是相等，则加到结果的尾部，否则按$k_i$的位置插入元素。如果要对`people`进行操作，c语言需要实现统一后移操作。

对于本题，排序`people`时，按第一个元素降序排列，这样在遍历的时候就不会因为它现在的位置影响它的$k_i$，如果`people`的第一个元素相等，排序时按第二个元素升序排，目的是为了满足相同身高的情况。

以上均是基于知道本题的解法时给出的分析。一方面，算法学习需要思考，另一方面则需要积累。本题单是人脑模拟就十分吃力了，更别说用编码解决，因而需要积累。就像数组问题没有头绪是考虑排序一样，本题的排序属于小技巧。

### <span style="color: burlywood;">代码</span>

> 先看python，则c代码更好理解

```python
class Solution:
    def reconstructQueue(self, people: List[List[int]]) -> List[List[int]]:
        # (-x[0]第一个字段逆序，x[1]第二个字段顺序)x只是个字母，可也是y，z
        people = sorted(people, key=lambda x: (-x[0], x[1]))
        i = 0
        while i < len(people):
            if i > people[i][1]:
                # insert(index, value)
                people.insert(people[i][1], people[i])
                # 需要把多余的弹出
                people.pop(i+1)
            i += 1

        return people
```

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int cmp(int** a, int** b){
    if(a[0][0] != b[0][0])
        return b[0][0] - a[0][0];
    else
        return a[0][1] - b[0][1];
}
//从left到right统一后移
void moveBack(int** people, int left, int right){
    for(int i = right; i > left; i--){
        people[i] = people[i - 1];
    }
}

int** reconstructQueue(int** people, int peopleSize, int* peopleColSize, int* returnSize, int** returnColumnSizes){
    *returnSize = peopleSize;
    *returnColumnSizes = malloc(sizeof(int) * peopleSize);
    for(int i = 0; i < peopleSize; i++)
        returnColumnSizes[0][i] = 2;
    // 排序
    qsort(people, peopleSize, sizeof(people[0]), cmp);
    for(int i = 0; i < peopleSize; i++){
        // 如果索引当前people不在位置
        if(i > people[i][1]){
            int sit = people[i][1];
            int* tmp = people[i];
            moveBack(people, sit, i);

            people[sit] = tmp;
        }
    }
    return people;
}
```

## <span style="color: orange;">452\. 用最少数量的箭引爆气球</span>

> 力扣链接：https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/
>
> 有一些球形气球贴在一堵用 XY 平面表示的墙面上。墙面上的气球记录在整数数组 `points` ，其中`points[i] = [xstart, xend]` 表示水平直径在 `xstart` 和 `xend`之间的气球。你不知道气球的确切 y 坐标。
>
> 一支弓箭可以沿着 x 轴从不同点 **完全垂直** 地射出。在坐标 `x` 处射出一支箭，若有一个气球的直径的开始和结束坐标为 `x``start`，`x``end`， 且满足 `xstart ≤ x ≤ x``end`，则该气球会被 **引爆** 。可以射出的弓箭的数量 **没有限制** 。 弓箭一旦被射出之后，可以无限地前进。
>
> 给你一个数组 `points` ，*返回引爆所有气球所必须射出的 **最小** 弓箭数* 。
>
> **示例 1：**
>
> ```
> 输入：points = [[10,16],[2,8],[1,6],[7,12]]
> 输出：2
> 解释：气球可以用2支箭来爆破:
> -在x = 6处射出箭，击破气球[2,8]和[1,6]。
> -在x = 11处发射箭，击破气球[10,16]和[7,12]。
> ```
>
> **示例 2：**
>
> ```
> 输入：points = [[1,2],[3,4],[5,6],[7,8]]
> 输出：4
> 解释：每个气球需要射出一支箭，总共需要4支箭。
> ```
>
> **示例 3：**
>
> ```
> 输入：points = [[1,2],[2,3],[3,4],[4,5]]
> 输出：2
> 解释：气球可以用2支箭来爆破:
> - 在x = 2处发射箭，击破气球[1,2]和[2,3]。
> - 在x = 4处射出箭，击破气球[3,4]和[4,5]。
> ```
>
> **提示:**
>
> - `1 <= points.length <= 105`
> - `points[i].length == 2`
> - `-231 <= xstart < xend <= 231 - 1`

### <span style="color: burlywood;">分析</span>

昨天那题估计大家还是有些蒙，但是如果你对昨天的题还有印象，今天的题就很好想（题不难，就是容易把人绕晕）

不用说，先排序，而且是按points的第一个元素排，第二个元素无所谓。排好后就要考虑把箭从哪里射进去。

如果从第一个元素开始遍历，每一箭都是沿$x_{start}$射出去的，那属于是铺张浪费，肯定要沿$x_{end}$射出去，此时需要考虑一个问题：

```c
[[10,16],[2,8],[1,6],[7,12][2,3]]
```

如果是从6射出去的第一箭，那就把\[2,3\]漏了，所以需要pos记录x的最靠左的end。

那什么时候结束呢，第一箭是x=3，那需要判断是否逃出当前遍历的start，由于咱不需要考虑一箭中了几个，就在x逃出的时候给结果res++，同时气球最少是1个，所有res初值为1。

### <span style="color: burlywood;">代码</span>

```c
// c语言快排库函数：https://www.cnblogs.com/CCBB/archive/2010/01/15/1648827.html
int cmp(int** a, int** b){
    return a[0][0] > b[0][0];
}

int findMinArrowShots(int** points, int pointsSize, int* pointsColSize){
    int res = 1;
    qsort(points, pointsSize, sizeof(points[0]), cmp);
    // pos 指向最远可达的右端点，即箭射出的位置
    int pos = points[0][1];
    for(int i = 1; i < pointsSize; i++){
        if(pos > points[i][1])
            pos = points[i][1];
        if(pos < points[i][0]){
            pos = points[i][1];
            res++;
        }
    }
    return res;
}
```

```python
class Solution:
    def findMinArrowShots(self, points: List[List[int]]) -> int:
        points = sorted(points, key=lambda x:(x[0], x[1]))

        pos = points[0][1]
        res = 1
        for i in range(1, len(points)):
            if pos > points[i][1]:
                pos = points[i][1]
            if pos < points[i][0]:
                res += 1
                pos = points[i][1]

        return res
```

## <span style="color: orange;">435\. 无重叠区间</span>

> 力扣链接：https://leetcode.cn/problems/non-overlapping-intervals/
>
> 给定一个区间的集合 `intervals` ，其中 `intervals[i] = [starti, endi]` 。返回 *需要移除区间的最小数量，使剩余区间互不重叠* 。
>
> **示例 1:**
>
> ```
> 输入: intervals = [[1,2],[2,3],[3,4],[1,3]]
> 输出: 1
> 解释: 移除 [1,3] 后，剩下的区间没有重叠。
> ```
>
> **示例 2:**
>
> ```
> 输入: intervals = [ [1,2], [1,2], [1,2] ]
> 输出: 2
> 解释: 你需要移除两个 [1,2] 来使剩下的区间没有重叠。
> ```
>
> **示例 3:**
>
> ```
> 输入: intervals = [ [1,2], [2,3] ]
> 输出: 0
> 解释: 你不需要移除任何区间，因为它们已经是无重叠的了。
> ```
>
> **提示:**
>
> - `1 <= intervals.length <= 105`
> - `intervals[i].length == 2`
> - `-5 * 104 <= starti < endi <= 5 * 104`

### <span style="color: burlywood;">分析</span>

有的题你看着唬人，其实就那样。

这和昨天的题其实是一类题，改改就能ac，直接上代码

### <span style="color: burlywood;">代码</span>

```c
int cmp(int** a, int** b){
    return a[0][0] > b[0][0];
}

int findMinArrowShots(int** points, int pointsSize, int* pointsColSize){
    int res = 1;
    qsort(points, pointsSize, sizeof(points[0]), cmp);
    // pos 指向最远可达的右端点，即重复的位置
    int pos = points[0][1];
    for(int i = 1; i < pointsSize; i++){
        if(pos > points[i][1])
            pos = points[i][1];
        if(pos < points[i][0]){
            pos = points[i][1];
            res++;
        }
    }
    return res;
}
```

```python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        intervals = sorted(intervals, key=lambda x:(x[0]))

        same = 1
        pos = intervals[0][1]
        for i in range(1, len(intervals)):
            if pos > intervals[i][1]:
                pos = intervals[i][1]
            if pos <= intervals[i][0]:
                same += 1
                pos = intervals[i][1]

        return len(intervals)-same
```

## <span style="color: orange;">763\. 划分字母区间</span>

> 力扣链接：https://leetcode.cn/problems/partition-labels/
>
> 给你一个字符串 `s` 。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。
>
> 注意，划分结果需要满足：将所有划分结果按顺序连接，得到的字符串仍然是 `s` 。
>
> 返回一个表示每个字符串片段的长度的列表。
>
> **示例 1：**
>
> ```
> 输入：s = "ababcbacadefegdehijhklij"
> 输出：[9,7,8]
> 解释：
> 划分结果为 "ababcbaca"、"defegde"、"hijhklij" 。
> 每个字母最多出现在一个片段中。
> 像 "ababcbacadefegde", "hijhklij" 这样的划分是错误的，因为划分的片段数较少。 
> ```
>
> **示例 2：**
>
> ```
> 输入：s = "eccbbbbdec"
> 输出：[10]
> ```
>
> **提示：**
>
> - `1 <= s.length <= 500`
> - `s` 仅由小写英文字母组成

### <span style="color: burlywood;">分析</span>

题目翻译一下：在一个序列中，如果当前位置的元素s\[i\]是最后出现的，**且在此之前比s\[i\]大的元素之后不会出现**，则在此处截断。

那么我们需要得到26个字母最后出现的索引，其次需要判断当前位置是否是s\[i\]最后出现的位置，至于加粗的条件，用贪心的思想就能很好解决，具体看代码。

### <span style="color: burlywood;">代码</span>

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* partitionLabels(char * s, int* returnSize){
    *returnSize = 0;
    int len = strlen(s);
    int* res = malloc(sizeof(int) * len);
    int last[26];
    // 找到26个字母最后出现的位置
    for(int i = 0; i < len; i++){
        last[s[i] - 'a'] = i;
    }
    int start = 0, end = 0;
    for(int i = 0; i < len; i++){
        end = fmax(end, last[s[i] - 'a']);
        // 若当前位置是s[i]这个字母最后出现，则此处截止
        if(i == end){
            res[(*returnSize)++] = end - start + 1;
            start = end + 1;
        }
    }
    return res;
}
```

```python
class Solution:
    def partitionLabels(self, s: str) -> List[int]:
        last = {}
        for i in range(len(s)):
            last[s[i]] = i

        res = []
        start, end = 0, 0
        for i in range(len(s)):
            end = max(end, last[s[i]])
            if i == end:
                res.append(end - start + 1)
                start = end + 1
        return res
```

## <span style="color: orange;">56\. 合并区间</span>

> 力扣链接：https://leetcode.cn/problems/merge-intervals/
>
> 以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。
>
> **示例 1：**
>
> ```
> 输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
> 输出：[[1,6],[8,10],[15,18]]
> 解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
> ```
>
> **示例 2：**
>
> ```
> 输入：intervals = [[1,4],[4,5]]
> 输出：[[1,5]]
> 解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
> ```
>
> **提示：**
>
> - `1 <= intervals.length <= 104`
> - `intervals[i].length == 2`
> - `0 <= starti <= endi <= 104`

### <span style="color: burlywood;">分析</span>

本题理应会让你想到《用最少数量的箭引爆气球》，那篇确实经典，究其本质，就是判断区间相交的问题。

与那题不同的是，那题当时用min作为每次射箭的位置，而本题则需要max来实现最大的右区间

### <span style="color: burlywood;">代码</span>

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int cmp(int** a, int **b){
    return a[0][0] > b[0][0];
}

int** merge(int** intervals, int intervalsSize, int* intervalsColSize, int* returnSize, int** returnColumnSizes){
    qsort(intervals, intervalsSize, sizeof(intervals[0]), cmp);
    int** res = malloc(sizeof(int*) * intervalsSize);
    for(int i = 0; i < intervalsSize; i++)
        res[i] = malloc(sizeof(int) * 2);
    *returnColumnSizes = malloc(sizeof(int) * intervalsSize);
    *returnSize = 0;
    // 存储右边界的值
    int max = intervals[0][1];
    // 为初始左边界赋值
    res[0][0] = intervals[0][0];
    for(int i = 1; i < intervalsSize; i++){
        // 获取区域内最大的右边界
        if(max < intervals[i - 1][1])
            max = intervals[i - 1][1];
        // 若本次脱离合并范围，则为右边界赋值
        if(intervals[i][0] > max){
            res[*returnSize][1] = max;
            (*returnColumnSizes)[(*returnSize)++] = 2;
            res[*returnSize][0] = intervals[i][0];
        }
    }
    // 最后一次右边界赋值逻辑
    if(max < intervals[intervalsSize - 1][1])
        max = intervals[intervalsSize - 1][1];
    res[*returnSize][1] = max;
    (*returnColumnSizes)[(*returnSize)++] = 2;
    return res;
}
```

最后一次右边界可以精简一下，相当于白嫖一次求max的逻辑，变化部分如下

```c
// < 变为 <=
for(int i = 1; i <= intervalsSize; i++){
        if(max < intervals[i - 1][1])
            max = intervals[i - 1][1];
    	// 不能越界
        if(i != intervalsSize && intervals[i][0] > max){
            res[*returnSize][1] = max;
            (*returnColumnSizes)[(*returnSize)++] = 2;
            res[*returnSize][0] = intervals[i][0];
        }
    }
res[*returnSize][1] = max;
(*returnColumnSizes)[(*returnSize)++] = 2;
```

```python
class Solution:
    def merge(self, intervals: List[List[int]]) -> List[List[int]]:
        intervals.sort()
        res = []
        left = intervals[0][0]
        right = intervals[0][1]
        for i in range(1, len(intervals)):
            right = max(right, intervals[i - 1][1])
            if intervals[i][0] > right:
                # python添加整行
                res.append([left, right])
                left = intervals[i][0]

        right = max(right, intervals[len(intervals) - 1][1])
        res.append([left, right])
        return res
```

## <span style="color: orange;">738\. 单调递增的数字</span>

> 力扣链接：https://leetcode.cn/problems/monotone-increasing-digits/
>
> 当且仅当每个相邻位数上的数字 `x` 和 `y` 满足 `x <= y` 时，我们称这个整数是**单调递增**的。
>
> 给定一个整数 `n` ，返回 *小于或等于 `n` 的最大数字，且数字呈 **单调递增*** 。
>
> **示例 1:**
>
> ```
> 输入: n = 10
> 输出: 9
> ```
>
> **示例 2:**
>
> ```
> 输入: n = 1234
> 输出: 1234
> ```
>
> **示例 3:**
>
> ```
> 输入: n = 332
> 输出: 299
> ```
>
> **提示:**
>
> - `0 <= n <= 109`

### <span style="color: burlywood;">分析</span>

本题看似简单，实则细节很多。

比较常见的思路就是把数字转成数组（python则是转为列表），同时求出数组长度。先遍历到数组不符合规则的位置，再向回遍历，遍历到第一个要修改的位置（如332虽然断点是在index=1的位置，但是第一个要修改的位置是index=0，和重复次数有关，实际情况更复杂），在把第一个要修改位置后面的全部改为9。最后字符串转为数字。

事实上，在写代码的时候需要考虑1234是转为"1234"还是转为"4321"，第一次遍历是从后往前还是从前往后。其实亮着对应即可。

上述是c的逻辑，对于python，将其转为列表更好操作（切片 && python的字符串不能直接修改）。不过最后需要手动转为数字。

### <span style="color: burlywood;">代码</span>

```c
// 数字转字符串，并返回字符串长度
// 1234 转为 "1234" 并返回4
void itoa(int num, char* str, int* strSize){
    *strSize = 0;
    while(num > 0){
        str[(*strSize)++] = num % 10 + '0';
        num /= 10;
    }
    for(int i = 0; i < (*strSize) / 2; i++){
        int tmp = str[i];
        str[i] = str[(*strSize) - 1 - i];
        str[(*strSize) - 1 - i] = tmp;
    }
}

int monotoneIncreasingDigits(int n){
    int strSize;
    char arr[11];
    itoa(n, arr, &strSize);
    int i = 1;
    // 找到断点，arr="1234"   '1' <= '2'
    while(i < strSize && arr[i - 1] <= arr[i]){
        i++;
    }
    // 如果不满足条件（例：332）
    if(i < strSize){
        // '3' > '2'
        while(i > 0 && arr[i - 1] > arr[i]){
            arr[i - 1]--;
            i--;
        }
        i++;
        // 此时"332"变为"222"，i=1
        while(i < strSize){
            arr[i++] = '9';
        }
    }
    // 字符串转数字
    return atoi(arr);
}
```

```python
class Solution:
    def monotoneIncreasingDigits(self, n: int) -> int:
        # 生成式 数字转数字列表 1234转[1,2,3,4]
        digits = [int(i) for i in list(str(n))]
        if len(digits) == 1:
            return n
        # 1234从4向1遍历
        for i in range(len(digits)-1, 0, -1):
            # 若不满足条件 下面逻辑重复体现了贪心的局部性
            if digits[i] < digits[i - 1]:
                # 把不满足条件的部分赋值为9，前一个减1
                digits[i:] = [9] * (len(digits) - i)
                digits[i - 1] -= 1
        
        res = 0
        for num in digits:
            res = res * 10 + num

        return res
```

## <span style="color: orange;">968\. 监控二叉树</span>

> 力扣链接：https://leetcode.cn/problems/binary-tree-cameras/
>
> 给定一个二叉树，我们在树的节点上安装摄像头。
>
> 节点上的每个摄影头都可以监视**其父对象、自身及其直接子对象。**
>
> 计算监控树的所有节点所需的最小摄像头数量。
>
> **示例 1：**
>
> ```
> 输入：[0,0,null,0,0]
> 输出：1
> 解释：如图所示，一台摄像头足以监控所有节点。
> ```
>
> **示例 2：**
>
> ```
> 输入：[0,0,null,0,null,0,null,null,0]
> 输出：2
> 解释：需要至少两个摄像头来监视树的所有节点。 上图显示了摄像头放置的有效位置之一。
> ```
>
> **提示：**
>
> 1.  给定树的节点数的范围是 `[1, 1000]`。
> 2.  每个节点的值都是 0。

### <span style="color: burlywood;">分析</span>

这题我贴个地址：https://leetcode.cn/problems/binary-tree-cameras/solution/968-jian-kong-er-cha-shu-di-gui-shang-de-zhuang-ta/。

其实公众号的刷题顺序就是按代码随想录的顺序刷的，之后我需要降低更新频率以保证内容质量（如之后的动态规划需要列方程），可能两天一更。建议大家按carl哥的代码随想录去刷题🙌

### <span style="color: burlywood;">代码</span>

```c
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     struct TreeNode *left;
 *     struct TreeNode *right;
 * };
 */
int res;
// 后序遍历
/* 0：该结点无覆盖
   1：该节点有摄像头
   2：该节点有覆盖
*/
int traversal(struct TreeNode* cur){
    // 空结点设置为有覆盖，则不会影响后序遍历
    if(cur == NULL)
        return 2;        
    
    int left = traversal(cur -> left);
    int right = traversal(cur -> right);
    // 如果两边都被覆盖，则该节点无需覆盖
    if(left == 2 && right == 2)
        return 0;
    // 如果两边有一边无覆盖，则该节点需覆盖，res++，并设置该节点有摄像头
    if(left == 0 || right == 0){
        res++;
        return 1;
    }
    // 如果该节点左右两个存在一个摄像头，则该节点被覆盖
    if(left == 1 || right == 1)
        return 2;
    // 最后的返回值不会影响结果，因为所有的情况均被覆盖
    return -1;
}

int minCameraCover(struct TreeNode* root){
    res = 0;
    // 若头结点未被覆盖
    if(traversal(root) == 0){
        res++;
    }
    return res;
}
```

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def __init__(self):
        self.res = 0

    def minCameraCover(self, root: Optional[TreeNode]) -> int:
        if self.traversal(root) == 0:
            self.res += 1
        return self.res
    

    def traversal(self, cur):
        if cur == None:
            return 2
        
        left = self.traversal(cur.left)
        right = self.traversal(cur.right)

        if left == 2 and right == 2:
            return 0

        if left == 0 or right == 0:
            self.res += 1
            return 1

        if left == 1 or right == 1:
            return 2
        
        return -1
```

## <font color='orange'>总结</font>

>   本篇主要是捋一下贪心算法这一章刷过的题每一道是怎么贪的（之前还有几题把tag打错了）

<font color='red'>**局部最优可以推出全局最优，那就是贪心**</font>

### <font color='BurlyWood'>力扣455题：分发饼干</font>

本题当时是快排+双指针。快排是为了让整体问题可用局部思想解决，双指针是为了求局部最佳（匹配小的饼干尽量匹配大胃口），妥妥的贪心。

### <font color='BurlyWood'>力扣376题：摆动序列</font>

这道题当时讲的不太明白：其实就是一个二维折线图，而摆动序列就是折线图上的极值点。所有每次贪的都是一个极值区间的极大值和极小值。

### <font color='BurlyWood'>力扣53题：最大子数组和</font>

本题需要求最大的子数组之和，其实要考虑的是区间上的最大。当时用tmp保存大于0的子数组和，每次判断是不是最大，用res接收最大值，而tmp小于0，则tmp只能清零。

### <font color='BurlyWood'>力扣122题：买卖股票的最佳时机 II</font>

这题我当时一句话带过了，因为当时是没想出来。对于股票，利润=后一天的价格-前一天的价格，如果从后往前看，就是第一个-第二个，而这个差值如果大于0，则就是有收益的，加入到结果里即可，把局部最优放在整体得到最优，贪心无疑。

### <font color='BurlyWood'>力扣55题：跳跃游戏</font>

这题当时以为贪下一步的最优解是错的，结果第二天就发现其实能解，这种思路更好理解一些。至于思路二，很巧妙，也建议掌握。思路二没有回头，但是较难理解，思路一相比之下就没那么优雅。

### <font color='BurlyWood'>力扣45题：跳跃游戏II</font>

用上一题的思路一正好能解，贪的是下一次的最佳。

### <font color='BurlyWood'>力扣1005题：K次取反后最大化的数组和</font>

这题比较简单，就是判断起来有一点点绕。至于贪心的思想，可能仅体现在当数组全为正之后，贪最小值的取反。

### <font color='BurlyWood'>力扣134题：加油站</font>

这题我当时只会模拟。重点在于如果**选择站点 `i` 作为起点「恰好」无法走到站点 `j`，那么 `i` 和 `j` 中间的任意站点 `k` 都不可能作为起点。**有些偏数学。

### <font color='BurlyWood'>力扣135题：分发糖果</font>

众所周知，力扣题目越幼稚，题目难度越地狱。实际上也没那么吓人，需要双向思维。

### <font color='BurlyWood'>力扣860题：柠檬水找零</font>

如果说1005题有点绕，那这个判断就绕死了，单纯的判断题，优先找10￥就行

### <font color='BurlyWood'>力扣406题：根据身高重建队列</font>

本题有一个技巧：列长为2的数组先排序。本题最后的解法为：先排序后插队

### <font color='BurlyWood'>力扣452题：用最少数量的箭引爆气球</font>

本题相当经典，可以说是<font color='red'>区间相交问题的标杆</font>。后面和区间相关的问题都用到本题的思路，同时本题有不是很难想

### <font color='BurlyWood'>力扣435题：无重叠区间</font>

如果要说个贪心的话，这题和上一题都是往右区间，而下一个的左区间则是判断是否满足条件。

### <font color='BurlyWood'>力扣764题：划分字母区间</font>

这题的精妙之处在于找26个字母最后出现的位置，难点在于理解要找26个字母最后出现的位置，贪的也是26个字母最后出现的位置。

### <font color='BurlyWood'>力扣56题：合并区间</font>

合并重叠区间，又是区间相交问题，不再赘述

### <font color='BurlyWood'>力扣738题：单调递增的数字</font>

众所周知，力扣题的参数越单纯，题的难度越邪恶。不过对于大数问题，或者数组切割问题，一般的思路转为数组或字符串，python的话就转为列表。如果有这个思路，这题就是磨性子题，因为细节有点多。

### <font color='BurlyWood'>力扣968题：监控二叉树</font>

这题是本章唯一的一道树的问题，所有难免心生惶恐。其实树就两点需要考虑：根怎么处理，叶子怎么处理。之后就是递归。本题的贪心也是从下往上。数组的贪心一般是从左到右或从右到左。